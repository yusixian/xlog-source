{"characterId":52270,"noteId":110,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreic7bxzkhl2nwkrnqcdrjyoifglg2xg3hyh6nyotjuujipu3vzmovy","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-08-27T00:03:47.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":13,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":13,"metadata":{"uri":"ipfs://bafkreic7bxzkhl2nwkrnqcdrjyoifglg2xg3hyh6nyotjuujipu3vzmovy","type":"NOTE","content":{"tags":["post","c++","数据结构","排序算法"],"type":"note","title":"归并排序循环实现（存用）","content":"---\ntitle: 归并排序循环实现（存用）\nlink: 归并排序循环实现（存用）\ncatalog: true\nlang: cn\ndate:  2020-08-27 00:03:47\nsubtitle: 参考MOOC浙大数据结构，归并排序的非递归算法\ntags:\n- c++\n- 数据结构\n- 排序算法\ncategories:\n- [笔记, 数据结构]\n---\n\n递归的归并排序是很占空间和时间的，而非递归算法就不一样了，额外空间复杂度最少为O(N)。\n陈越姥姥的慕课里就讲得很清楚~[戳这儿](https://www.icourse163.org/learn/ZJU-93001?tid=1459700443#/learn/content?type=detail&id=1235254071&cid=1254945270)\n这里就直接上代码+注释了\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\nconst int inf  = 0x3f3f3f;\nint N;\nll a[maxn];\nvoid swap(ll &a, ll &b){//交换a,b的值\n    int tmp = a;\n    a = b;\n    b = tmp;\n}\nvoid Merge(ll a[],ll tmp[], int s, int m, int e) {\n    //将数组a的局部a[s,m-1]和a[m,e]合并到数组tmp,并保证tmp有序\n    int pb = s;\n    int p1 = s, p2 = m;//p1指向前一半p2指向后一半\n    while (p1 <= m-1 && p2 <= e) {\n        if (a[p1] <= a[p2])\n            tmp[pb++] = a[p1++];\n        else \n            tmp[pb++] = a[p2++];\n    }\n    while(p1 <= m-1) \n        tmp[pb++] = a[p1++];\n    while(p2 <= e) \n        tmp[pb++] = a[p2++];\n    for (int i = 0; i < e-s+1; ++i)\n        a[s+i] = tmp[i];\n}\nvoid Merge_Pass(ll a[], ll b[], int N, int len) {\n    //将a数组按len长度切分 归并到b\n    //len为当前有序子列的长度\n    int i;\n    for(i = 0; i <= N - 2*len; i += 2*len) \n        //找每一对要归并的子序列 直到倒数第二对\n        Merge(a, b, i, i+len, i+2*len-1); //将a\n    if(i+len < N) //最后有2个子列\n        Merge(a, b, i, i+len, N-1);\n    else  //最后只剩1个有序子列\n        for(int j = i; j < N; ++j) b[j] = a[j];\n}\nvoid Merge_Sort(ll a[], int N) {\n    int len = 1;//初始化有序子列的长度\n    ll *tmp;\n    tmp = new ll[N];\n    if(tmp != NULL) {\n        while(len < N) {\n            Merge_Pass(a, tmp, N, len);\n            len *= 2;\n            Merge_Pass(tmp, a, N, len);\n            len *= 2;\n        }\n        delete [] tmp;\n    } else printf(\"空间不足\");\n}\nint main(){\n    scanf(\"%d\", &N);\n    for(int i = 0; i < N; ++i) \n        scanf(\"%lld\", &a[i]);\n    Merge_Sort(a, N);\n    for(int i = 0; i < N; ++i) {\n        printf(\" %lld\"+!i, a[i]);\n    }\n    return 0;\n}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200827000243956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n","sources":["xlog"],"attributes":[{"value":"gui-bing-pai-xu-xun-huan-shi-xian--cun-yong-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/gui-bing-pai-xu-xun-huan-shi-xian--cun-yong-md"],"date_published":"2020-08-27T00:03:47.000Z"}}}