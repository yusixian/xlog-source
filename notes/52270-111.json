{"characterId":52270,"noteId":111,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreia7rd7n5u2trg7qgyvoj3rl3uzvowexvwyoiqdabmtmyihjf55q3u","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-10-23T13:34:43.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":14,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":14,"metadata":{"uri":"ipfs://bafkreia7rd7n5u2trg7qgyvoj3rl3uzvowexvwyoiqdabmtmyihjf55q3u","type":"NOTE","content":{"tags":["post","c++","二分图匹配","链式前向星"],"type":"note","title":"链式前向星存图、二分图匹配之匈牙利算法 模板&分析（存用）","content":"---\ntitle: 链式前向星存图、二分图匹配之匈牙利算法 模板&分析（存用）\nlink: 链式前向星存图、二分图匹配之匈牙利算法 模板&分析（存用）\ncatalog: true\nlang: cn\ndate: 2020-10-23 13:34:43 \nsubtitle: 暑假的专题训练8是二分图匹配，由于之前一直没有试过链式前向星存图，所学这次算法的前还学习了链式前向星存图（虽然二分图算法一般不用这样存图）\ntags:\n- c++\n- 二分图匹配\n- 链式前向星\ncategories:\n- [笔记, 数据结构]\n---\n参考博客：[链式前向星--最通俗易懂的讲解](https://blog.csdn.net/sugarbliss/article/details/86495945)、[算法讲解：二分图匹配【图论】](https://blog.csdn.net/qq_41730082/article/details/81162561)、[趣写算法系列之--匈牙利算法](https://blog.csdn.net/dark_scope/article/details/8880547)、[匈牙利算法与增广路径](https://blog.csdn.net/reid_zhang1993/article/details/44080167)\n\n暑假整的忘了发2333\n\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n\n@[TOC](目录)\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n\n# 一、链式前向星\n## 1.是什么\n\n> 如果说邻接表是不好写但效率好，邻接矩阵是好写但效率低的话，前向星就是一个相对中庸的数据结构。前向星固然好些，但效率并不高。而在优化为链式前向星后，效率也得到了较大的提升。虽然说，世界上对链式前向星的使用并不是很广泛，但在不愿意写复杂的邻接表的情况下，链式前向星也是一个很优秀的数据结构。\n>  <p align=\"right\">——摘自百度百科</p>\n\n链式前向星其实就是**静态建立的邻接表**，一种特殊边集数组，其时间效率为O（m），空间效率也为O（m）。遍历效率也为O（m），它能很方便的找出所有结点的邻接边 \n## 2.如何存图\n我们需要以下数组的含义：\n 1. head[i]数组，表示以i为起点的第一条边的编号，一般初始化为-1，说明没有以这个边为起点的边了。\n 2. edge[i]结构数组，其中edge[i].to表示第i条边的终点,edge[i].Next表示与第i条边同起点的下一条边的存储位置,edge[i].w为边权值\n### 定义及初始化\n```cpp\nconst int maxn = 10000;//最大顶点数\nint N,M,mcnt;//顶点数、边数\nint head[maxn];//以i为起点的第一条边在edge数组的下标\nstruct Edge {\n    int to, w, Next;//终点、边权、同起点的下一条边的编号\n} edge[maxn];\nvoid init() {\n    memset(head, -1, sizeof(head));\n    mcnt = 0;\n}\n```\n### 加边\n```cpp\nvoid add_edge(int u, int v, int w) {\n    edge[mcnt].to = v;\n    edge[mcnt].w = w;\n    edge[mcnt].Next = head[u];//将下一条边的编号赋给Next\n    head[u] = mcnt++;//更新head数组\n}\n```\n### 遍历\n```cpp\nfor(int i = 1; i <= N; ++i) {\n    for(int j = head[i]; j != -1; j = edge[j].Next) {   //遍历以i为起点的边\n        //其他操作\n    }\n}\n```\n\n# 二、二分图匹配 \n## 1.二分图\n百度百科解释如下：\n> 二分图又称作二部图，是图论中的一种特殊模型。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。\n\n简单来说，就是一个图被分两部分，只有不同部分之间的点存在边，相同部分之间的点是不存在边的\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200818153904790.png#pic_center)\n## 2.匹配\n\n - 给定一个二分图G，在G的一个子图M中，**M的边集{E}中的任意两条边都不依附于同一个顶点**，则称M是一个**匹配**。\n - **极大匹配(Maximal Matching)**   是指在当前已完成的匹配下,无法再通过增加未完成匹配的边的方式来增加匹配的边数。\n - **最大匹配(maximum matching)**  是所有极大匹配当中边数最大的一个匹配。选择这样的边数最大的子集称为图的最大匹配问题。\n - 如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为**完全匹配**，也称作**完备匹配**。\n - **若P是图G中一条联通两个未匹配顶点的路径，且属于M的边和不属于M的边在P上交替出现，则称P为相对于M的一条增广路径**。 \n## 3.匈牙利算法\n匈牙利算法，除了二分图多重匹配外在二分图匹配中都可以使用。几乎是二分图匹配的核心算法，除了二分图多重匹配外均可使用，实际上就是一种网络流的思想，其核心就是寻找增广路。具体操作就是嗯。。拉郎配\n具体思想可以看这篇博客[趣写算法系列之--匈牙利算法](https://blog.csdn.net/dark_scope/article/details/8880547)\n这里放一个总结：**有机会上，没机会创造机会也要上**\n### 核心代码\n递归找妹子【不是】\n```cpp\nbool find(int x){\n\tint i,j;\n\tfor (j=1;j<=m;j++){    //扫描每个妹子\n\t\tif (line[x][j]==true && used[j]==false)      \n\t\t//如果有暧昧并且还没有标记过(这里标记的意思是这次查找曾试图改变过该妹子的归属问题，但是没有成功，所以就不用瞎费工夫了）\n\t\t{\n\t\t\tused[j]=1;\n\t\t\tif (girl[j]==-1 || find(girl[j])) { \n\t\t\t\t//名花无主或者能腾出个位置来，这里使用递归\n\t\t\t\tgirl[j]=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n```\n\n \n主程序中扫描每个汉子，注意used清零操作\n```cpp\nfor (i=1;i<=n;i++)\n{\n\tmemset(used,0,sizeof(used));    //这个在每一步中清空\n\tif find(i) all+=1;\n}\n```\n\n### 几道例题\n#### [A - Fire Net](https://vjudge.net/contest/389800#problem/A)\n##### 题目大意及思路\n大意：\n&emsp;&emsp;N*N的城市地图，“.”代表可以放置一个小型城堡向四个方向射击，“X”代表有墙可以挡住射击，在一个城市中放置尽可能多的小型城堡，以使没有两个小型城堡能够相互摧毁。小型城堡的配置是合法的，当且仅当地图上没有两个小型城堡位于同一水平行或垂直列上，除非至少有一堵墙将它们隔开\n思路：\n&emsp;&emsp;先遍历每行，中间有墙的算不同列，作为二分图中的X区域，在遍历每列，中间有墙的算作不同行，作为Y区域，edge[i][j]表示X区域中点i与Y区域中点j是否有边，求该二分图的最大匹配（小型城堡放置于行列交点处，而交点唯一）这道题显然直接邻接矩阵存转换后的图方便快捷些…\n##### 代码\n注意这里col数组得初始化为-1\n```cpp\n// A - Fire Net\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define div 1000000007\nconst int maxn = 1005;\nconst int inf  = 0x3f3f3f;\nint N,M,rcnt,ccnt,ans;\nstring str;\nstruct Vertex {\n    char flag;\n    int r, c;//该点位于的真实行列\n}map[maxn][maxn],now;\nint edge[maxn][maxn];\nint col[maxn];\nbool used[maxn];\nvoid init() {\n    rcnt = ccnt = ans = 0;\n    memset(used, 0, sizeof(used));\n    memset(col, -1, sizeof(col));\n    memset(edge, 0, sizeof(edge));\n}\nbool find_x(int x) {\n    for(int j = 0; j < ccnt; ++j) {\n        if(edge[x][j] == 1 && !used[j]) {\n            used[j] = true;\n            if(col[j] == -1 || find_x(col[j])) {\n                col[j] = x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    while(cin >> N && N) {\n        init();\n        for(int i = 0; i < N; ++i) {\n            cin >> str;\n            for(int j = 0; j < N; ++j) {\n                map[i][j].flag = str[j];\n            }\n        }\n        for(int j = 0; j < N; ++j, ++ccnt) {//每列\n            for(int i = 0; i < N; ++i) {\n                if(map[i][j].flag == 'X' && i+1 < N && map[i+1][j].flag != 'X')\n                    ++ccnt;//每一列中不联通的视为不同列\n                map[i][j].c = ccnt;\n            }\n        }\n        for(int i = 0; i < N; ++i, ++rcnt) {//每行\n            for(int j = 0; j < N; ++j) {\n                if(map[i][j].flag == 'X' && j+1 < N && map[i][j+1].flag != 'X')\n                    ++rcnt;//每一行中不联通的视为不同行\n                map[i][j].r = rcnt;\n            }\n        }\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < N; ++j) {\n                if(map[i][j].flag == '.') {\n                    now = map[i][j];\n                    edge[now.r][now.c] = 1;\n                }\n            }\n        }\n        for(int i = 0; i < rcnt; ++i) {\n            memset(used, 0, sizeof(used));\n            if(find_x(i)) ans++;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n#### [B - The Accomodation of Students](https://vjudge.net/contest/389800#problem/B)\n##### 题目大意及思路\n大意：\n&emsp;&emsp;给出n个学生，告诉你m对学生互相认识。将学生分成两组，以便同一组中的任何两个学生都不认识。如果可以实现此目标，则将他们安排在双人间。请记住，只有出现在先前给定集合中的巴黎才能住在同一房间，这意味着只有已知的学生才能住在同一房间。计算可安排到这些双人间中的最大对数。\n思路：\n&emsp;&emsp;二分图判断和匹配，二分图的判断采用染色法，匹配采用匈牙利算法","sources":["xlog"],"attributes":[{"value":"lian-shi-qian-xiang-xing-cun-tu--er-fen-tu-pi-pei-zhi-xiong-ya-li-suan-fa-mo-ban--fen-xi--cun-yong-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/lian-shi-qian-xiang-xing-cun-tu--er-fen-tu-pi-pei-zhi-xiong-ya-li-suan-fa-mo-ban--fen-xi--cun-yong-md"],"date_published":"2020-10-23T13:34:43.000Z"}}}