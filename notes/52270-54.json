{"characterId":52270,"noteId":54,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreif7vv6rsq7fpe34dztejn4rcpjgpoknrtdpxchsgr7hktzsuran7i","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:39:52.000Z","updatedAt":"2023-04-05T06:39:52.000Z","deletedAt":null,"publishedAt":"2022-05-01T02:43:49.000Z","transactionHash":"0x16c8bbbc59b889d2e6569492006a2c6cfbcfe39cb15611ff19baebf93088d12d","blockNumber":30317697,"logIndex":1,"updatedTransactionHash":"0x16c8bbbc59b889d2e6569492006a2c6cfbcfe39cb15611ff19baebf93088d12d","updatedBlockNumber":30317697,"updatedLogIndex":1,"metadata":{"uri":"ipfs://bafkreif7vv6rsq7fpe34dztejn4rcpjgpoknrtdpxchsgr7hktzsuran7i","type":"NOTE","content":{"tags":["post","编译原理"],"type":"note","title":"编译原理 实验四 LR(1)分析法程序","content":"---\ntitle: 编译原理 实验四 LR(1)分析法程序\nlink: compile-learning-experiment_4\ncatalog: true\nlang: cn\ndate: 2022-05-01 02:43:49 \nsubtitle: 编译原理第四次实验~实验4 LR(1) 分析法\ntags:\n- 编译原理\ncategories:\n- [笔记, CS基础]\n---\n\n第三次实验因为逆波兰式比较简单所以略过x\n\n源代码仓库：[CompilePrincipleLearning/experiment_4 · yusixian/CompilePrincipleLearning (github.com)](https://github.com/yusixian/CompilePrincipleLearning/tree/master/experiment_4)\n\n在demo文件夹中~\n\n# 一.\t实验目的\n1. 掌握LR(1)分析法的基本原理\n2. 掌握LR(1)分析表的构造方法\n3. 掌握LR(1)驱动程序的构造方法\n\n# 二.\t实验内容及要求\n构造LR(1)分析程序，利用它进行语法分析，判断给出的符号串是否为该文法识别的句子，了解LR（K）分析方法是严格的从左向右扫描，和自底向上的语法分析方法。\n\n根据某一文法编制调试LR（1）分析程序，以便对任意输入的符号串进行分析。本次实验的目的主要是加深对LR（1）分析法的理解。\n\n**对下列文法，用LR（1）分析法对任意输入的符号串进行分析**：\n```txt\n（0）S’->E\n\n（1）E->E+T\n\n（2）E->T\n\n（3）T->T*F\n\n（4）T->F\n\n（5）F->(E)\n\n（6）F->i\n```\n\n输出的格式如下：\n\n(1)LR（1）分析程序，编制人：姓名，学号，班级\n\n(2)输入一以#结束的符号串(包括+-*/（）i#)：在此位置输入符号串\n\n(3)输出过程如下：\n\n| **步骤** | **状态栈** | **符号栈****** | **剩余输入串** | **动作** |\n| ------ | ------- | ----------- | --------- | ------ |\n| 1      | 0       | #          | i+i*i#   | 移进     |\n\n(4)输入符号串为非法符号串或合法符号串\n\n注意：\n\n1.表达式中允许使用运算符（+|*）、分割符（括号）、字符i，结束符#；\n\n2.如果遇到错误的表达式，应输出错误提示信息（该信息越详细越好）；\n\n3.对学有余力的同学，测试用的表达式事先放在文本文件中，一行存放一个表达式，同时以分号分割。同时将预期的输出结果写在另一个文本文件中，以便和输出进行对照；\n\n4．可采用的其它的文法，但是必须是LR1分析方法。\n\n# 三.\t实验过程\n\n## 1、构造识别LR（1）文法活前缀的DFA\n如图：新标签页打开，不糊的。\n\n![LR1_DFA.drawio.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b812acc3e4e4ea9929eef56cebea020~tplv-k3u1fbpfcp-watermark.image?)\n\naction表和goto表如下：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dbe68ae771f4a89a6dca82976915452~tplv-k3u1fbpfcp-watermark.image?)\n\n## 2、采用的数据结构\n\n```cpp\n// ACTION表\n// + * ( ) i #\nstring action[12][6];\n// goto表\n// a b #\nint _goto[12][3];\nstring vt = \"+*()i#\";      // 终结符表\nstring vn = \"ETF\";        // 非终结符表\nstring LR[6] = { \"E->E+T\", \"E->T\", \"T->T*F\", \"T->F\", \"F->(E)\", \"F->i\" };   // 存放产生式\nstack<char> chars;  // 符号栈\nstack<int> state;   // 状态栈\n```\n## 3、头文件声明和全局变量定义\n如下。\n```cpp\n#include <iostream>\n#include <string>\n#include <fstream>\n#include <stack>\n#include <vector>\nusing namespace std;\nconst string ExpFileName = \"./exp.txt\";\nconst string GotoFileName = \"./goto.txt\";\nconst string ActionFileName = \"./action.txt\";\nconst int Null = -1;\n// ACTION表\n// + * ( ) i #\nstring action[12][6];\n// goto表\n// a b #\nint _goto[12][3];\nstring vt = \"+*()i#\";      // 终结符表\nstring vn = \"ETF\";        // 非终结符表\nstring LR[6] = { \"E->E+T\", \"E->T\", \"T->T*F\", \"T->F\", \"F->(E)\", \"F->i\" };   // 存放产生式\n```\n## 4、函数汇总\n\n### （1）函数汇总表\n| 函数名称                      | 功能简述                           |\n| ------------------------- | ------------------------------ |\n| `readFile`                  | 读取文件函数，返回一个string动态数组，以行数分割    |\n| `init`                      | 初始化函数，在该函数中进行goto表和action表的初始化 |\n| `printActions / printGotos` | 输出goto表与action表                |\n| `isTerminator`              | 判断当前字符c是否是终结符                  |\n| `findTerminator`            | 返回终结符所处下标                      |\n| `findNonTerminator`         | 返回非终结符所处下标                     |\n| `s2string`                  | 将栈转换为字符串返回，方便输出步骤              |\n| `analyzeLR1`                | 利用LR1分析法分析字符串exp，输出其分析步骤       |\n| `main `                     | 主程序入口，调用读取文件函数开始分析            |\n\n\n### （2）函数的调用关系\n\n![function4.drawio.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b99924fde594015aac1b75d324243c7~tplv-k3u1fbpfcp-watermark.image?)\n### （3）流程图\n\n![main.drawio.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbd377b4720c450894253ad587ca8c3f~tplv-k3u1fbpfcp-watermark.image?)\n\n## 5、实验结果\n### 输入\naction.txt文件\n```txt\nN\tN\ts4\tN\ts5\tN\ns6\tN\tN\tN\tN\tacc\nr2\ts7\tN\tr2\tN\tr2\nr4\tr4\tN\tr4\tN\tr4\nN\tN\ts4\tN\ts5\tN\nr6\tr6\tN\tr6\tN\tr6\nN\tN\ts4\tN\ts5\tN\nN\tN\ts4\tN\ts5\tN\ns6\tN\tN\ts11\tN\tN\nr1\ts7\tN\tr1\tN\tr1\nr3\tr3\tN\tr3\tN\tr3\nr5\tr5\tN\tr5\tN\tr5\n```\n\ngoto.txt文件\n```txt\n1\t2\t3\nN\tN\tN\nN\tN\tN\nN\tN\tN\n8\t2\t3\nN\tN\tN\nN\t9\t3\nN\tN\t10\nN\tN\tN\nN\tN\tN\nN\tN\tN\nN\tN\tN\n```\n\nexp.txt文件\n```txt\ni+(i*i)*(i+i)#\ni*i+i*i#\ni+i*i+i*(i+i*i)#\ni+*(i)+i(i+i*i)#\ni+i(i)#\n```\n### 输出\n\n![image1.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00706fefb691427592dcf885bd5729a7~tplv-k3u1fbpfcp-watermark.image?)\n\n![image2.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca94078bbded4bf5802757568e8221b4~tplv-k3u1fbpfcp-watermark.image?)\n\n![image3.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26196777c3a241799dcd13ea1a30debc~tplv-k3u1fbpfcp-watermark.image?)\n\n# 完整代码\n\n```cpp\n/*\n * @Author: cos\n * @Date: 2022-04-30 14:20:51\n * @LastEditTime: 2022-05-01 02:34:12\n * @LastEditors: cos\n * @Description: 实验4 LR(1) 分析法\n * @FilePath: \\CompileTheory\\experiment_4\\demo\\main.cpp\n */\n#include <iostream>\n#include <string>\n#include <fstream>\n#include <stack>\n#include <vector>\nusing namespace std;\nconst string ExpFileName = \"./exp.txt\";\nconst string GotoFileName = \"./goto.txt\";\nconst string ActionFileName = \"./action.txt\";\nconst int Null = -1;\n// ACTION表\n// + * ( ) i #\nstring action[12][6];\n// goto表\n// a b #\nint _goto[12][3];\nstring vt = \"+*()i#\";      // 终结符表\nstring vn = \"ETF\";        // 非终结符表\nstring LR[6] = { \"E->E+T\", \"E->T\", \"T->T*F\", \"T->F\", \"F->(E)\", \"F->i\" };   // 存放产生式\n// 读文件\nvector<string> readFile(string fileName) {\n    vector<string> res;\n    try {\n        ifstream fin;\n        fin.open(fileName);\n        string temp;\n        while (getline(fin, temp))\n            res.push_back(temp);\n        return res;\n    }\n    catch (const exception& e) {\n        cerr << e.what() << '\\n';\n        return res;\n    }\n}\nvoid printActions() {\n    cout << \"-----------------ACTION表------------------\" << endl;\n    cout << \"+\\t*\\t(\\t)\\ti\\t$\" << endl;\n    for (int i = 0; i < 12; ++i) {\n        for (int j = 0; j < 6; ++j)\n            cout << action[i][j] << \"\\t\";\n        cout << endl;\n    }\n}\nvoid printGotos() {\n    cout << \"-----------------GOTO表------------------\" << endl;\n    cout << \"E\\tT\\tF\" << endl;\n    for (int i = 0; i < 12; ++i) {\n        for (int j = 0; j < 3; ++j)\n            cout << _goto[i][j] << \"\\t\";\n        cout << endl;\n    }\n}\nvoid init() {\n    vector<string> actions = readFile(ActionFileName);\n    for (int i = 0; i < 12; ++i) {\n        int cnt = 0;\n        string row = actions[i];\n        int len = actions[i].length();\n        for (int j = 0; j < len; ++j) {\n            string temp = \"\";\n            while (j < len && row[j] != ' ' && row[j] != '\\t') {\n                temp += row[j];\n                ++j;\n            }\n            while (j < len && (row[j] == ' ' || row[j] == '\\t'))\n                ++j;\n            --j;\n            action[i][cnt++] = temp;\n        }\n\n    }\n    printActions();\n    vector<string> gotos = readFile(GotoFileName);\n    for (int i = 0; i < 12; ++i) {\n        int cnt = 0;\n        string row = gotos[i];\n        int len = row.length();\n        for (int j = 0; j < len; ++j) {\n            string temp = \"\";\n            while (j < len && row[j] != ' ' && row[j] != '\\t') {\n                temp += row[j];\n                ++j;\n            }\n            while (j < len && (row[j] == ' ' || row[j] == '\\t'))\n                ++j;\n            --j;\n            _goto[i][cnt++] = (temp == \"N\") ? Null : stoi(temp);\n        }\n    }\n    printGotos();\n}\nbool isTerminator(char c) {\n    return vt.find(c) != string::npos;\n}\nint findTerminator(char c) { // 返回终结符所处下标\n    return vt.find(c);\n}\nint findNonTerminator(char c) { // 返回非终结符的下标\n    return vn.find(c);\n}\n// 将栈转换为字符串返回\nstring s2string(stack<int> s) {\n    string str = \"\";\n    while(!s.empty()) {\n        str += to_string(s.top()) + \" \";\n        s.pop();\n    }\n    return str;\n}\n// 输出剩余输入串\nvoid printRestInput(string exp, int start, int len) {\n    for(int i = start; i < len; ++i) \n        cout << exp[i];\n    cout << '\\t';\n}\nvoid analyzeLR1(string exp) {  // 分析一个表达式\n    int len = exp.length();\n    stack<char> chars;  // 符号栈\n    stack<int> state;   // 状态栈\n    state.push(0);  // 初始状态为0\n    chars.push('#');  // 初始符号为#\n    string charsStr = \"#\";\n    stack<int> copyState;\n    copyState.push(0);\n    int cnt = 0;    // 序号\n    int idx = 0;  // 当前输入指针\n    cout << \"序号\\t\\t状态栈\\t\\t符号栈\\t\\t输入串\\t\\t描述\" << endl;\n    cout << cnt++ << '\\t' << s2string(copyState) << '\\t' << charsStr << '\\t' << exp << '\\t' << \" 初始状态 \" << endl;\n    while(1) {\n        int nowState = state.top();\n        char nowChar = exp[idx];    // 当前输入字符\n        int isT = findTerminator(nowChar);\n        if(isT == Null) {   // 非终结符\n            cout << \"Error!\" << \"出现非法字符，程序错误退出\" <<endl;\n            return;\n        }\n        string actionStr = action[nowState][isT];\n        if(actionStr == \"acc\") {\n            cout << cnt++ << '\\t' << s2string(copyState) << '\\t' << charsStr << '\\t' << exp << '\\t' << \" accept 接受！ \" << endl;\n            return;\n        } else if(actionStr == \"N\") {\n            cout << cnt++ << '\\t' << s2string(copyState) << '\\t' << charsStr << '\\t' << exp << '\\t' << \"Error! 程序异常退出\" << endl;\n            return;\n        } else if(actionStr[0] == 'r') {   // 归约\n            int num = stoi(actionStr.substr(1));    // 选用第几个产生式归约\n            int len = LR[num-1].length()-3;\n            while(len--) {\n                chars.pop();        // 出栈，归约\n                state.pop();\n                charsStr = charsStr.substr(0, charsStr.length()-1);\n                copyState.pop();   // 便于输出\n            }\n            chars.push(LR[num-1][0]);   // 产生式左部入符号栈\n            charsStr += LR[num-1][0];\n\n            int nowState = state.top();\n            int gidx = findNonTerminator(LR[num-1][0]);\n            int newState = _goto[nowState][gidx];\n            state.push(newState);\n            copyState.push(newState);\n\n            cout << cnt++ << '\\t' << s2string(copyState) << '\\t' << charsStr  << '\\t';\n            printRestInput(exp, idx, len);\n            cout << '\\t' << \" 归约 \" << LR[num-1] << endl;\n        } else if(actionStr[0] == 's') {    // 移进\n            int newState =  stoi(actionStr.substr(1));\n            state.push(newState);\n            copyState.push(newState);\n\n            chars.push(nowChar);\n            charsStr += nowChar;\n            ++idx;  // 输入指针后移\n\n            cout << cnt++ << '\\t' << s2string(copyState) << '\\t' << charsStr << '\\t';\n            printRestInput(exp, idx, len);\n            cout << '\\t' << actionStr << \" 移进 \" << endl;\n        } else {\n            cout << \"Error!\" << \"程序异常退出\" <<endl;\n            return;\n        }\n    }\n}\nint main() {\n    cout << \"LR（1）分析程序，编制人：xxx xxxxxxxx xxxx班\" << endl;\n    cout << \"提示:本程序只能对由'i','+','*','/','(',')'构成的以'#'结束的表达式进行分析，每行读入一个表达式\" << endl;\n    cout << \"读取的文件名为：\" << ExpFileName << endl; \n    init();\n    vector<string> exps = readFile(ExpFileName);\n    int len = exps.size();\n    for (int i = 0; i < len; i++) {\n        string exp = exps[i];\n        cout << \"\\n------------------待分析表达式\" << i+1 << \"：\"<< exp << \"--------------------\" << endl;\n        bool flag = true;\n        for (int j = 0; j < exp.length(); j++) {\n            if (!isTerminator(exp[j])) {\n                cout << \"第 \"<<   i+1 << \"行输入的字符串不合法，请重新输入\" << endl;\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            cout << \"表达式\"  << i+1 << \"：\" << exp << \"分析开始\" << endl;\n            analyzeLR1(exp);\n        }\n    }\n    return 0;\n}\n```\n","sources":["xlog"],"attributes":[{"value":"bian-yi-yuan-li-shi-yan-si-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/bian-yi-yuan-li-shi-yan-si-md"],"date_published":"2022-05-01T02:43:49.000Z"}}}