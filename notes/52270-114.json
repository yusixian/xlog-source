{"characterId":52270,"noteId":114,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreic5whmp7c4gqexsh6lissitgvxnwq747lsselxzkmavmckgknlhja","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-02-27T01:07:00.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":17,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":17,"metadata":{"uri":"ipfs://bafkreic5whmp7c4gqexsh6lissitgvxnwq747lsselxzkmavmckgknlhja","type":"NOTE","content":{"tags":["post","c++","数据结构"],"type":"note","title":"数据结构学习笔记＜1＞ 线性表","content":"---\ntitle: 数据结构学习笔记＜1＞ 线性表\nlink: 数据结构学习笔记＜1＞ 线性表\ncatalog: true\nlang: cn\ndate:  2020-02-27 01:07:00 \nsubtitle: MOOC浙江大学的数据结构慕课学习记录——线性表\ntags:\n- c++\n- 数据结构\ncategories:\n- [笔记, 数据结构]\n---\n\n## 一、线性表的抽象数据类型描述\n类型名：线性表（List）\n数据对象集：线性表示n(>=0)个元素构成的有序序列(a1,a2,……,an)\n操作集：线性表L∈List, 整数i表示位置,元素X∈ElementType\n## 二、顺序表\n### 1.定义\n```cpp\nstruct LNode {\n    ElementType Data[MAXSIZE];//存了一个数组，其最多能存MAXSIZE个元素\n    int Last;//最后一个元素的下标！\n};\ntypedef struct LNode *List;\n```\n访问下标为i的元素:L.Data[i]或PtrL->Data[i]\n线性表的长度: L.Last+1 或 PtrL->Last+1;\n\n### 2.操作\n其基本操作有\n\n> **1.List MakeEmpty();//初始化一个空线性表\n> 2.ElementType FindKth(int K, List Ptrl);//返回下标为K的相应元素\n> 3.int Find(ElementType X, List Ptrl);//在线性表L中查找X的第一次出现位置\n> 4.void Insert(ElementType X, int i, List Ptrl);//在位序i前插入一个新元素X\n> 5.void Delete(int i, List Ptrl);//删除指定位序i的元素\n> 6.int Length(List Ptrl);//返回线性表的长度n****\n> \n下面我们来一一过一遍\n#### (1)创建空表\n```cpp\nList MakeEmpty() {\n    List PtrL;\n    PtrL = (List)malloc(sizeof(struct LNode));\n    PtrL -> Last = -1;\n    return PtrL;\n}\n```\n#### (2)查找下标为K的元素\n返回下标K的相应元素。\n```cpp\nElementType FindKth(int K, List Ptrl) {\n    return Ptrl->Data[K];\n}\n```\n#### (3)查找元素X\n返回下标，未找到返回-1。\n```cpp\nint Find(ElementType X, List Ptrl) {\n    int i = 0;\n    while(i <= PtrL->Last && PtrL->Data[i] != X)\n        i++;\n    if(i > PtrL->Last) return -1;//如果没找到返回-1\n    else return i;//找到后返回的是存储位置 即下标\n}\n```\n#### (4)插入\n在第i(1 ≤ i ≤ n+1)个位置上插入一个值为X的新元素\n```cpp\nvoid Insert(ElementType X, int i, List Ptrl) {\n    int j;\n    if(Ptrl->Last == MAXSIZE-1) {//表空间已满，则不能插入\n        printf(\"表满\");\n        return;\n    }\n    if(i < 1 || i > Ptrl->Last+2) {//检查输入是否合法\n        printf(\"位置不合法\");\n        return;\n    }\n    for(j = Ptrl->Last; j >= i-1; j--) //注意这里顺序不能从前往后\n        Ptrl->Data[j+1] = Ptrl->Data[j];\n    Ptrl->Data[i-1] = X;\n    Ptrl->Last++;//last仍指向最后元素！\n    return;\n}\n```\n#### (5)删除\n删除第i个元素（下标为i-1）\n```cpp\nvoid Delete(int i, List Ptrl) {\n    int j;\n    if(i < 1 || i > Ptrl->Last+1) {//检查输入是否合法\n        printf(\"不存在第%d个元素\",i);\n        return;\n    }\n    for (j = i; j <= Ptrl->Last; j++) //删除操作就必须从前往后了\n        Ptrl->Data[j-1] = Ptrl->Data[j];\n    Ptrl->Last--;\n    return;\n}\n```\n#### (6)返回线性表的长度n\n删除第i个元素（下标为i-1）\n```cpp\nint Length(List Ptrl){\n    return Ptrl->Last + 1;\n}\n```\n### 3.完整代码演示\n```cpp\n//顺序表\n#include <iostream>\nusing namespace std;\ntypedef int ElementType;\nconst int MAXSIZE = 1000;\n// 1.定义部分\nstruct LNode {\n\tElementType Data[MAXSIZE];  //存了一个数组，其最多能存MAXSIZE个元素\n\tint Last;\t\t\t\t\t//最后一个元素的下标！\n};\ntypedef LNode *List;\n// 2.操作函数\n//(1) 建立空线性表\nList MakeEmpty() {\n\tList Ptrl;\t\t\t\t\t\t\t\t\t//建立\n\tPtrl = new struct LNode;  //为其分配第一个结点的空间\n\tPtrl->Last = -1;  //还未存数据，下边设为-1\n\treturn Ptrl;\t  //返回该指针\n}\n//(2) 查找下标为K的元素 返回下标K的相应元素\nElementType FindKth(int K, List Ptrl) {\n    return Ptrl->Data[K];\n}\n//(3) 查找元素X 返回下标 未找到返回-1\nint Find(ElementType X, List Ptrl) {\n\tint i = 0;\n\twhile (i <= Ptrl->Last && Ptrl->Data[i] != X) {\n\t\ti++;\n\t}\n\tif (i > Ptrl->Last)\n\t\treturn -1;\n\telse\n\t\treturn i;\n}\n//(4) 插入元素X 在第i(1 ≤ i ≤ n+1)个位置上插入一个值为X的新元素\nvoid Insert(ElementType X, int i, List Ptrl) {\n\tif (Ptrl->Last == MAXSIZE - 1) {  //表空间已满，则不能插入\n\t\tprintf(\"表满\");\n\t\treturn;\n\t}\n\tif (i < 1 || i > Ptrl->Last + 2) {  //检查输入是否合法\n\t\tprintf(\"位置不合法\");\n\t\treturn;\n\t}\n\tint j;\n\tfor (j = Ptrl->Last; j >= i - 1; j--)  //注意这里顺序不能从前往后\n\t\tPtrl->Data[j + 1] = Ptrl->Data[j];\n\tPtrl->Data[i - 1] = X;\n\tPtrl->Last++;  // last仍指向最后元素！\n\treturn;\n}\n//(5) 删除 删除第i个元素（下标为i-1）\nvoid Delete(int i, List Ptrl) {\n\tint j;\n\tif (i < 1 || i > Ptrl->Last + 1) {  //检查输入是否合法\n\t\tprintf(\"不存在第%d个元素\", i);\n\t\treturn;\n\t}\n\tfor (j = i; j <= Ptrl->Last; j++)  //删除操作就必须从前往后了\n\t\tPtrl->Data[j - 1] = Ptrl->Data[j];\n\tPtrl->Last--;\n\treturn;\n}\n//(6) 返回线性表的长度n\nint Length(List Ptrl){\n    return Ptrl->Last + 1;\n}\nint main() {\n    List P;\n    P = MakeEmpty();\n    for(int i = 0; i < 10; i++){\n        Insert(i,i+1,P);\n    }\n    cout << \"该顺序表长度为：\" << Length(P) << endl;\n    cout << \"第5个元素为：\" << FindKth(4,P) << endl;\n    cout << \"--删除第4个元素--\" << endl;\n    Delete(4,P);\n    cout << \"删除后第5个元素为：\" << FindKth(4,P) << endl;\n    cout << \"表中是否有元素3(有则显示其下标无则显示-1)：\" << Find(3,P) << endl;\n    cout << \"表中是否有元素5(有则显示其下标无则显示-1)：\" << Find(5,P) << endl;\n    delete [] P;\n    return 0;\n}\n```\n输出结果为：\n> 该顺序表长度为：10\n第5个元素为：4\n--删除第4个元素--\n删除后第5个元素为：5\n表中是否有元素3(有则显示其下标无则显示-1)：-1\n表中是否有元素5(有则显示其下标无则显示-1)：4\n\n## 三、线性表的链式存储\n重要！！链表即不要求逻辑上相邻的两个元素物理上也相邻，通过\"链\"建立起数据元素之间的逻辑关系。\n其插入和删除不需要移动数据元素，只需要修改链。\n### 1.定义\n```cpp\ntypedef struct LNode *List;\nstruct LNode {\n    ElementType Data;\n    List Next;//存放指向下一个结点的指针\n}L;\nList PtrL;\n```\n### 2.操作\n其基本操作有\n\n> **1.List Insert(ElementType X, int i, List PtrL) ;//插入(在第i-1(1<=i<=n+1)个结点后插入一个值为X的新结点)\n> 2.List FindKth(int K, List PtrL) ;//按序号查找查找 查找链表中第K个元素\n> List Find(ElementType X, List PtrL) ; //按值查找: 查找元素K\n> 3.List Delete(int i, List PtrL);//删除操作(删除链表第i个位置上的结点)\n> 4.int Length(List PtrL)//求表长**\n> \n#### (1)插入操作\n在第i-1(1 ≤ i ≤ n+1)个结点后插入一个值为X的新结点\n(1)先构造一个新结点，用s指向 //malloc分配空间 将s的数据Data赋值为X\n(2)再找到链表的第i-1个结点，用p指向\n(3)然后修改指针，插入结点(p之后插入新结点是s) \n// 先将p原先的指向next给s的next指针，再将p的next指针指向s\n```cpp\nList Insert(ElementType X, int i, List PtrL) {\n    List p, s;\n    if(i == 1) {//新节点插入到表头\n        s = (List)malloc(sizeof(struct LNode));//申请、填装节点\n        s->Data = X;\n        s->Next = PtrL;\n        return s;       //返回新表头指针\n    }\n    p = Find(i-1,PtrL);         //查找第i-1个结点\n    if(p == NULL) {             //第i-1个不存在 无法插入\n        printf(\"参数i错\");\n        return NULL;\n    } else {\n        s = (List)malloc(sizeof(struct LNode)); //申请、填装结点\n        s->Data = X;\n        s->Next = p->Next;          //新节点插入在第i-1个节点的后面\n        p->Next = s;\n        return PtrL;\n    }\n}\n```\n\n#### (2)查找\n找到则返回指向该结点的指针，找不到返回NULL\n##### 1.按值查找:Find\n按值查找: 查找元素K\n```cpp\nList Find(ElementType X, List PtrL) {\n    List p = PtrL;\n    while(p != NULL && p->Data != X) \n        p = p->Next;\n    if(p == NULL) {          \n        cout << \"找不到该元素\" << endl;\n        return NULL;\n    } else  return p;\n}\n```\n##### 2.按序号查找：FindKth\n按序号查找查找 查找链表中第K个元素\n```cpp\nList FindKth(int K, List PtrL) {\n    List p = PtrL;\n    int i = 1;\n    while (p != NULL && i < K) {\n        p = p->Next;\n        i++;\n    }\n    if(i == K) return p;//找到第K个返回指针\n    else {              //否则返回空指针\n        cout << \"找不到该元素\" << endl;\n        return NULL;\n    }\n}\n```\n#### (3)删除操作\n删除链表第i个位置上的结点\n(1)先找到链表的第i-1个结点，用p指向;//Find(i-1,PtrL);\n(2)再用指针s指向要被删除的结点(p的下一个结点)//s = p->Next;\n(3)然后修改指针，删除s所指向的结点//p->Next = s->Next;\n(4)最后释放s所指结点的空间！    //free(s)\n\n```cpp\nList Delete(int i, List PtrL) {\n    List p, s;\n    if( i == 1) {   //若要删除的是表的第一个结点\n        s = PtrL;           //s指向第1个结点\n        if (PtrL != NULL)   PtrL = PtrL->Next;  //从链表中删除\n        else return NULL;\n        free(s);                            //释放被删除结点\n        return PtrL;\n    }\n    p = FindKth(i-1, PtrL);     //查找第i-1个结点\n    if (p == NULL) {\n        printf(\"第%d个结点不存在\", i-1);\n        return NULL;\n    } else if (p->Next == NULL) {\n        printf(\"第%d个结点不存在\",i);\n        return NULL;\n    } else {\n        s = p->Next;            //s指向第i个结点\n        p->Next = s->Next;      //从链表中删除\n        free(s);                //释放被删除结点的空间\n        return PtrL;\n    }\n}\n```\n\n#### (4)求表长\n```cpp\nint Length(List PtrL) {\n    List p = PtrL;//p指向表的第一个节点\n    int j = 0;\n    while(p) {\n        p = p->Next;\n        j++;\n    }\n    return j;\n}\n```\n### 3.完整代码演示\n```cpp\n//链表\n#include <iostream>\nusing namespace std;\ntypedef int ElementType;\nconst int MAXSIZE = 1000;\n// 1.定义部分\nstruct LNode;\ntypedef LNode *List;\nstruct LNode {\n\tElementType Data;\n\tList Next;  //存放指向下一个结点的指针\n};\nList Insert(ElementType X,int i,List PtrL);  \n//插入(在第i-1(1<=i<=n+1)个结点后插入一个值为X的新结点)\nList FindKth(int K, List PtrL);  //按序号查找查找 查找链表中第K个元素\nList Find(ElementType X, List PtrL);  //按值查找: 查找元素K\nList Delete(int i, List PtrL);  //删除操作(删除链表第i个位置上的结点)\nint Length(List PtrL);\t\t\t//求表长\n// 2.操作函数\n//(1) 插入操作 在第i-1(1 ≤ i ≤ n+1)个结点后插入一个值为X的新结点\nList Insert(ElementType X, int i, List PtrL) {\n\tList p, s;\n\tif (i == 1) {\t\t\t   //新节点插入到表头\n\t\ts = new struct LNode;  //申请、填装节点\n\t\ts->Data = X;\n\t\ts->Next = PtrL;\n\t\treturn s;  //返回新表头指针\n\t}\n\tp = Find(i - 1, PtrL);  //查找第i-1个结点\n\tif (p == NULL) {\t\t//第i-1个不存在 无法插入\n\t\tprintf(\"参数i错\");\n\t\treturn NULL;\n\t} else {\n\t\ts = new struct LNode;  //申请、填装结点\n\t\ts->Data = X;\n\t\ts->Next = p->Next;  //新节点插入在第i-1个节点的后面\n\t\tp->Next = s;\n\t\treturn PtrL;\n\t}\n}\n//(2) 查找 找到则返回指向该结点的指针，找不到返回NULL\nList Find(ElementType X, List PtrL) {//按值查找 查找元素X\n    List p = PtrL;\n    while(p != NULL && p->Data != X) \n        p = p->Next;\n    if(p == NULL) {          \n        cout << \"找不到该元素\" << endl;\n        return NULL;\n    } else  return p;\n}\nList FindKth(int K, List PtrL) {//按序号查找 查找第K个元素\n    List p = PtrL;\n    int i = 1;\n    while (p != NULL && i < K) {\n        p = p->Next;\n        i++;\n    }\n    if(i == K) return p;//找到第K个返回指针\n    else {              //否则返回空指针\n        cout << \"找不到该元素\" << endl;\n        return NULL;\n    }\n}\n//(3) 删除 删除链表第i个位置上的结点\nList Delete(int i, List PtrL) {\n    List p, s;\n    if( i == 1) {   //若要删除的是表的第一个结点\n        s = PtrL;           //s指向第1个结点\n        if (PtrL != NULL)   PtrL = PtrL->Next;  //从链表中删除\n        else return NULL;\n        delete [] s;                           //释放被删除结点\n        return PtrL;\n    }\n    p = FindKth(i-1, PtrL);     //查找第i-1个结点\n    if (p == NULL) {\n        printf(\"第%d个结点不存在\", i-1);\n        return NULL;\n    } else if (p->Next == NULL) {\n        printf(\"第%d个结点不存在\",i);\n        return NULL;\n    } else {\n        s = p->Next;            //s指向第i个结点\n        p->Next = s->Next;      //从链表中删除\n        delete [] s;                //释放被删除结点的空间\n        return PtrL;\n    }\n}\n//(4) 求表长\nint Length(List PtrL) {\n    List p = PtrL;//p指向表的第一个节点\n    int j = 0;\n    while(p) {\n        p = p->Next;\n        j++;\n    }\n    return j;\n}\nint main() {\n\tList P = NULL;\n\tfor (int i = 0; i < 10; i++) {\n\t\tP = Insert(i, 1, P);// 头插法 插入元素在表头\n\t}\n    List s;\n\tcout << \"该链表长度为：\" << Length(P) << endl;\n\tcout << \"第4个元素为：\";\n    s = FindKth(4, P);\n    if(s) cout << s->Data << endl;\n\tcout << \"--删除第4个元素--\" << endl;\n\tDelete(4, P);\n\tcout << \"删除后第4个元素为：\" ;\n    s = FindKth(4, P);\n    if (s) cout << s->Data << endl;\n\tcout << \"表中是否有元素6：\";\n    s = Find(6, P);\n    if (s) cout << s->Data << endl;\n\tcout << \"表中是否有元素5：\";\n    s = Find(5, P);\n    if (s) cout << s->Data << endl;\n\tdelete[] P;\n\treturn 0;\n}\n```\n输出结果为：\n> 该链表长度为：10\n第4个元素为：6\n--删除第4个元素--\n删除后第4个元素为：5\n表中是否有元素6：找不到该元素\n表中是否有元素5：5\n","sources":["xlog"],"attributes":[{"value":"shu-ju-jie-gou-xue-xi-bi-ji-1-xian-xing-biao-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/shu-ju-jie-gou-xue-xi-bi-ji-1-xian-xing-biao-md"],"date_published":"2020-02-27T01:07:00.000Z"}}}