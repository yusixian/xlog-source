{"characterId":52270,"noteId":120,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreielrykyfxmf62ez3azp7rn447gzdsey6fw52bnrwibeamt54ngr2q","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-04-13T00:53:49.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":23,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":23,"metadata":{"uri":"ipfs://bafkreielrykyfxmf62ez3azp7rn447gzdsey6fw52bnrwibeamt54ngr2q","type":"NOTE","content":{"tags":["post","c++","数据结构","图"],"type":"note","title":"数据结构学习笔记＜7＞ 图","content":"---\ntitle: 数据结构学习笔记＜7＞ 图\nlink: 数据结构学习笔记＜7＞ 图\ncatalog: true\nlang: cn\ndate: 2020-04-13 00:53:49\nsubtitle: MOOC浙江大学的数据结构慕课学习记录——图\ntags:\n- c++\n- 数据结构\n- 图\ncategories:\n- [笔记, 数据结构]\n---\n\n# 一、图\n## 1.什么是图\n表示“多对多”的关系，包含了：\n - 一组顶点：通常用V(Vertex)表示顶点集合\n - 一组边：通常用E(Edge)表示边的集合\n - 无向边是顶点对：(v，w) ∈ E，其中v，w∈V\n - 有向边<v,w>表示从v指向w的边(单行线)\n - 不考虑重边和自回路\n### 抽象数据类型定义\n类型名称：图(Graph)\n数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成。\n操作集：对于任意图G ∈ Graph,以及 v ∈ V，e ∈ E\n - Graph Create():建立并返回空图；\n - Graph InsertVertex(Graph G, Vertex v)：将v顶点插入图G\n - Graph InsertEdge(Graph G, Edge e):将边e插入图G\n - void DFS(Graph G, Vertex v):从顶点v出发深度优先遍历图G；\n - void BFS(Graph G, Vertex v):从顶点v出发广度优先遍历图G；\n - void ShortestPath(Graph G, Vertex v, int Dist[]):计算图G中顶点v到其他任意顶点的最短距离；\n - void MST(Graph G):计算图G的最小生成树\n常用术语：\n无向图、有向图、网络等……\n### 怎样在程序中表示图\n#### 邻接矩阵\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412203724426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412204200990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n邻接矩阵的好处\n - 直观、简单、好理解\n - 方便检查任意一对顶点间是否存在边\n - 方便找任一顶点的所有“**邻接点”(有边直接相连的顶点)**\n - 方便计算任一顶点的“**度”(从该点发出的边数为“出度”，指向该点的边数为“入度”)**\n\t - **无向图**为对应行(或列)非0元素的个数\n\t - **有向图**：对应**行非0元素**的个数是**出度**，对应**列非0元素**的个数是**入度**\n### 邻接表\n指针数组+链表，点很稀疏的时候很合算\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412210300947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n 邻接表的好处：\n - 方便找任一顶点的所有“邻接点”(有边直接相连的顶点)\n - 节约稀疏图的空间\n\t - 需要N个头指针 + 2E个结点（每个结点至少2个域）\n - 方便计算无向图任一顶点的“度”，但对有向图只能计算出度。\n\n## 2.图的遍历\n### DFS深度优先搜索\n深度优先搜索(Depth First Search,DFS),对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次.\n伪代码描述：\n```cpp\nvoid DFS(Vertex V) {\n\tvisited[V] = true;\n\tfor(v的每个邻接点W)\n\t\tif (!visited[W])\n\t\t\tDFS(W);\n}\n```\n### BFS广度优先搜索\n广度优先搜索(Breadth First Search,BFS),借助队列(先进先出)来实现\n伪代码描述：\n```cpp\nvoid BFS(Vertex V) {\n\tvisited[V] = true;\n\tEnqueue(V, Q);//将该顶点放入队列中\n\twhile(!IsEmpty(Q)) {//当队列为空时结束搜索\n\t\tV = Dequeue(Q);//V为队首元素\n\t\tfor(V的每个邻接点W) {\n\t\t\tif ( !visited[W] ) {\n\t\t\t\tvisited[W] = true;//标记该点已访问\n\t\t\t\tEnqueue(W, Q);//将该点压入队列中\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 图不连通怎么办？\n - **路径**：V到W的路径是一些列顶点{V，V1，V2，……，Vn，W}的集合，其中任一对相邻的顶点间都有图中的边。**路径的长度**是路径中的边数(若带权，则是所有边的权重和)。若V到W之间的所有顶点都不同，则称为**简单路径**\n - **连通**：若V到W存在一条(无向)**路径**，则称V和W是连通的 \n - **回路**：起点等于终点的路径\n - **连通图**：图中任意两顶点均连通\n - **连通分量**：无向图的**极大连通子图**\n\t - 极大顶点数：再加1个顶点就不连通了\n\t - 极大边数：包含子图中所有顶点相连的所有边\n\t ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412213157989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n - **强连通**：有向图中顶点V和W之间存在双向路径，则称V和W是强连通的\n - **强连通图**：有向图中任意两顶点均强连通\n - **强连通分量**：有向图的极大强连通子图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412213422118.png)\n\n**每调用一次DFS，其实就是把V所在的连通分量遍历了一遍。BFS也一样。**\n```cpp\nvoid ListComponents ( Graph G ) {//遍历连通分量\n\tfor (each V in G)\n\t\tif ( !visited[V] ) {\n\t\t\tDFS( V );\n\t\t}\n}\n```\n## 3.如何建立图\n### (1) 邻接矩阵表示的图的建立\n#### 定义\n```cpp\nconst int MaxVertexNum = 100;\ntypedef int DataType;\ntypedef bool WeightType;\ntypedef struct GNode *PtrToGNode;\nstruct GNode {\n    int Nv;//顶点数\n    int Ne;//边数\n    WeightType G[MaxVertexNum][MaxVertexNum];\n    DataType Data[MaxVertexNum];//存顶点的数据\n};\ntypedef PtrToGNode MGraph;//以邻接矩阵存储的图类型\n```\n#### 初始化\n初始化一个有VertexNum个顶点但没有边的图\n```cpp\ntypedef int Vertex;\nMGraph CreateGraph(int VertexNum) {\n    Vertex V, W;\n    MGraph Graph;\n    Graph = (MGraph) malloc(sizeof(struct GNode));\n    Graph->Nv = VertexNum;\n    Graph->Ne = 0;\n    //顶点编号从0开始，到Graph->Nv-1\n    for (V = 0; V < Graph->Nv; V++) {\n        for(W = 0; W < Graph->Nv; W++) {\n            Graph->G[V][W] = 0; //有向图中可改0为INF等\n        }\n    }\n    return Graph;\n} \n```\n#### 向图中插入边\n边的定义\n```cpp\ntypedef struct ENode *PtrToENode;\nstruct ENode {\n    Vertex V1, V2;//有向边<V1,V2>\n    WeightType Weight;//权重\n};\ntypedef PtrToENode Edge;\n```\n插入操作\n```cpp\nvoid InsertEdge(MGraph Graph, Edge E) {\n    //插入边<V1,V2>\n    Graph->G[E->V1][E->V2] = E->Weight;\n    //若为无向图，则还要插入边<V2,V1>\n    Graph->G[E->V2][E->V1] = E->Weight;\n}\n```\n#### 完整的建立一个MGraph\n输入格式\n\n> Nv Ne\n> V1 V2 Weight\n> ……\n\n```cpp\nMGraph BuildGraph() {\n    MGraph Graph;\n    Edge E;\n    Vertex V;\n    int Nv;\n    cin >> Nv;\n    Graph = CreateGraph(Nv);//建立有Nv个顶点的图\n    cin >> Graph->Ne;//边数Ne\n    if(Graph->Ne != 0) {\n        E = (Edge)malloc(sizeof(struct ENode));\n        for (int i = 0; i < Graph->Ne; i++) {\n            cin >> E->V1 >> E->V2 >> E->Weight;\n            InsertEdge(Graph, E);\n        }\n    }\n    //如果顶点有数据的话，读入数据\n    for(V = 0; V < Graph->Nv; V++) {\n        cin >> Graph->Data[V];\n    }\n    return Graph;\n}\n```\n### (2) 邻接表表示的图的建立\n可在邻接矩阵的基础上进行修改\n#### 定义\n```cpp\nconst int MaxVertexNum = 100;\ntypedef int DataType;\ntypedef int Vertex;\ntypedef bool WeightType;\n//邻接表定义\ntypedef struct AdjVNode *PtrToAdjVNode;\nstruct AdjVNode {\n    Vertex AdjV;//邻接点下标\n    WeightType Weight;//边权重\n    PtrToAdjVNode Next;\n};\n\ntypedef struct VNode {\n    PtrToAdjVNode FirstEdge;\n    DataType Data;//存顶点的数据\n}AdjList;\n\ntypedef struct GNode *PtrToGNode;\nstruct GNode {\n    int Nv;//顶点数\n    int Ne;//边数\n    AdjList G;//邻接表\n};\ntypedef PtrToGNode LGraph;//以邻接表存储的图类型\n```\n#### LGraph初始化\n```cpp\nLGraph CreateGraph(int VertexNum) {\n    Vertex V, W;\n    LGraph Graph;\n    Graph = (LGraph) malloc(sizeof(struct GNode));\n    Graph->Nv = VertexNum;\n    Graph->Ne = 0;\n    //顶点编号从0开始，到Graph->Nv-1\n    for (V = 0; V < Graph->Nv; V++) {\n        Graph->G[V].FirstEdge = NULL;\n    return Graph;\n}\n```\n#### 向LGraph中插入边\n```cpp\ntypedef struct ENode *PtrToENode;\nstruct ENode {\n    Vertex V1, V2;//有向边<V1,V2>\n    WeightType Weight;//权重\n};\ntypedef PtrToENode Edge;\nvoid InsertEdge(LGraph Graph, Edge E){\n    PtrToAdjVNode NewNode;\n    //插入边<V1,V2>\n    //为V2建立新的邻接点\n    NewNode = (PtrToAdjVNode) malloc(sizeof(struct AdjVNode));\n    NewNode->AdjV = E->V2;\n    NewNode->Weight = E->Weight;\n    //将V2邻接点插入V1的表头\n    NewNode->Next = Graph->G[E->V1].FirstEdge;\n    Graph->G[E->V1].FirstEdge = NewNode;\n    \n    //若为无向图 则还要插入边<V2,V1>\n    //为V2建立新的邻接点\n    NewNode = (PtrToAdjVNode) malloc(sizeof(struct AdjVNode));\n    NewNode->AdjV = E->V1;\n    NewNode->Weight = E->Weight;\n    //将V2邻接点插入V1的表头\n    NewNode->Next = Graph->G[E->V2].FirstEdge;\n    Graph->G[E->V1].FirstEdge = NewNode;\n}\n```\n#### 完整的建立一个LGraph\n仅需将MGraph换成LGraph，将存Data是稍作更改即可\n```cpp\nLGraph BuildGraph() {\n    LGraph Graph;\n    Edge E;\n    Vertex V;\n    int Nv;\n    cin >> Nv;\n    Graph = CreateGraph(Nv);//建立有Nv个顶点的图\n    cin >> Graph->Ne;//边数Ne\n    if(Graph->Ne != 0) {\n        E = (Edge)malloc(sizeof(struct ENode));\n        for (int i = 0; i < Graph->Ne; i++) {\n            cin >> E->V1 >> E->V2 >> E->Weight;\n            InsertEdge(Graph, E);\n        }\n    }\n    //如果顶点有数据的话，读入数据\n    for(V = 0; V < Graph->Nv; V++) {\n        cin >> Graph->G[V].Data;\n    }\n    return Graph;\n}\n```\n# 二、最短路径问题\n## 1.概念简介\n - 在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径\n\t - 这条路径就是两点之间的**最短路径(Shortest Path)**\n\t - 第一个顶点叫**源点(Source)**\n\t - 最后一个顶点叫**终点(Destination)**\n## 2.问题分类\n - **单源**最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径\n\t - (有向)无权图\n\t - (有向)有权图\n - **多源**最短路径问题：求任意两顶点之间的最短路径\n## 2.无权图的单源最短路算法\n按照递增的顺序找出到各个顶点的最短路，与BFS思想很类似！\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412233441300.png)\n首先需要定义一个数组dist,**dist[W]存储S到W的最短距离**，S为起点，dist[S]=0，dist需要被初始化成一个-1(或无穷)，便于后来的判别是否被访问过。\n其次需要定义数组path,**path[W]存储S到W的路上经过的某顶点。**\ndist和path数组都需先被初始化为-1~然后将起点的dist[S]设为0，压入队列开始访问\n伪代码：\n```cpp\nvoid Unweighted(Vertex S) {\n\tEnqueue(S, Q);\n\twhile(!IsEmpty(Q)) {\n\t\tV = Dequeue(Q);\n\t\tfor (V的每个邻接点W)\n\t\t\tif(dist[W] == -1) {\n\t\t\t\tdist[W] = dist[V]+1;\n\t\t\t\tpath[W] = V;\n\t\t\t\tEnqueue(W, Q);\n\t\t\t}\n\t}\n}\n```\n## 3.有权图的单源最短路算法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412235213755.png)\n### Dijkstra算法！\n - 令s={源点s + 已经确定了最短路径的顶点v~i~ }\n - 对任一未收录的顶点v定义dist[v]为s到v的最短路径长度，但该路径**仅经过S中的顶点**，即路径{s→(v~i~∈S)→v}的最小长度\n - 若路径是按照**递增**的顺序生成的，则\n\t - 真正的最短路必须只经过S中的顶点(反证法可证)\n\t - 每次从未收录的顶点中选一个dist最小的收录(贪心)\n\t - 增加一个v进入S,可能会影响另外一个w的dist值！(所以要检查v的所有邻接点w！)\n\t\t - dist[w] = min{ dist[w]，dist[v] + <v,w>的权重}\ndist初始化：S的所有邻接点W的dist都可初始化为s与w的权重，其他则定义为正无穷。\n\n伪代码描述：\n\n```cpp\nvoid Dijkstra(Vertex s) {\n\twhile (1){\n\t\tV = 未收录顶点中dist最小者;\n\t\tif (这样的V不存在)\n\t\t\tbreak;\n\t\tcollected[V] = true;\n\t\tfor (V的每个邻接点W)\n\t\t\tif(collected[W] == false)\n\t\t\t\tif(dist[V] + E<v,w> < dist[W]) {\n\t\t\t\t\tdist[W] = dist[V]+E<v,w>;\n\t\t\t\t\tpath[W] = V;\n\t\t\t\t}\n\t}\n}//不能解决有负边的情况\n```\n伪代码中dist[W]=dist[V]+E~<V,W>~；并不是简单的赋值，而是如果有了更短的距离，需要将其更新成为更短的距离\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200413003639736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n#### Dijkstra核心代码\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int maxn = 1005;\nconst int inf  = 0x3f3f3f;\nint T,N,x,y,z;\nint edge[maxn][maxn];\nint dist[maxn];\nbool vis[maxn];\nvoid init() {\n    for(int i = 1; i <= N; ++i) {\n        for(int j = 1; j <= N; ++j) {\n            edge[i][j] = inf;\n        }\n        edge[i][i] = 0;\n    }\n}\nvoid Dijstra(int u) {\n    for(int i = 1; i <= N; ++i) {\n        vis[i] = false;\n        dist[i] = edge[u][i];\n    }\n    vis[u] = true;\n    for(int i = 1; i <= N; ++i) {\n        int t, mindis = inf;\n        for(int j = 1; j <= N; ++j) {\n            if(!vis[j] && dist[j] < mindis) {\n                mindis = dist[j];\n                t = j;\n            }\n        }\n        vis[t] = true;\n        for(int j = 1; j <= N; ++j) \n            if(!vis[j] && dist[j] > edge[t][j] + dist[t]) \n                dist[j] = edge[t][j] + dist[t];\n    }\n}\n```\n\n# 三、最小生成树\n## 1.什么是最小生成树(Minimum Spanning Tree)\n - 是一棵**树**\n\t - 无回路\n\t - |V|个顶点一定有|V|-1条边 \n - 是**生成**树\n\t - 包含全部顶点\n\t - |V|-1条边都在图里![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412231605205.png)\n\t - 向生成树中任加一条边都一定构成回路\n - 边的权重和**最小**\n\n最小生成树与图连通等价\n#### 2.解决最小生成树问题\n通常离不开贪心算法：\n\n - “贪”：每一步都要最好的\n - “好”：权重最小的边\n - 需要约束：\n\t - 只能用图里有的边\n\t - 只能正好用掉|V|-1条边\n\t - 不能有回路\n\n放到了另一篇博客里。\n[图论——解决最小生成树问题(Kruskal算法&Prim算法)](https://blog.csdn.net/qq_45890533/article/details/105684653)","sources":["xlog"],"attributes":[{"value":"shu-ju-jie-gou-xue-xi-bi-ji-7-tu-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/shu-ju-jie-gou-xue-xi-bi-ji-7-tu-md"],"date_published":"2020-04-13T00:53:49.000Z"}}}