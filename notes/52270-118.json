{"characterId":52270,"noteId":118,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreiarwrcytptsxhapiiwugiqxeuwqgijp5myh4alvuhthdqbmcstzkm","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-03-30T01:53:11.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":21,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":21,"metadata":{"uri":"ipfs://bafkreiarwrcytptsxhapiiwugiqxeuwqgijp5myh4alvuhthdqbmcstzkm","type":"NOTE","content":{"tags":["post","c++","数据结构","二叉树"],"type":"note","title":"数据结构学习笔记＜5＞ 二叉搜索树与平衡二叉树","content":"---\ntitle: 数据结构学习笔记＜5＞ 二叉搜索树与平衡二叉树\nlink: 数据结构学习笔记＜5＞ 二叉搜索树与平衡二叉树\ncatalog: true\nlang: cn\ndate: 2020-03-30 01:53:11 \nsubtitle: MOOC浙江大学的数据结构慕课学习记录——二叉搜索树与平衡二叉树\ntags:\n- c++\n- 数据结构\n- 二叉树\ncategories:\n- [笔记, 数据结构]\n---\n\n# 一、二叉搜索树\n## 1.二叉搜索树是什么\n二叉搜索树（**BST**，Binary Search Tree),又称**二叉排序树或二叉查找树**，是一棵二叉树，可以为空，当不为空时满足以下性质：\n\n - 非空**左子树**的所有**键值小于其根结点**的键值\n - 非空**右子树**的所有**键值大于其根结点**的键值\n - **左、右子树都为二叉搜索树**\n![图源百度百科](https://img-blog.csdnimg.cn/20200329233632371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n## 2.二叉搜索树的操作函数\n### (1)二叉搜索树的查找操作Find\n要查找的值为X\n - 从根结点开始查找，若树为空，则返回NULL \n - 若搜索树非空，则将**X与根节点的键值进行比较**并进行以下处理\n    1. 若**X小于根结点键值**，则在**左子树**中搜索\n    2. 若**X大于根结点键值**，则在**右子树**中搜索\n    3. 若X与根结点键值**相等**，则搜索完成，**返回**指向该结点的**指针**\n#### 尾递归实现\n```cpp\nPosition Find(ElementType X, BinTree BST) {\n\tif( !BST ) return NULL;//查找失败\n\tif( X > BST->Data )\n\t\treturn Find(X, BST->Right);//操作1\n\telse if (X < BST->Data) \n\t\treturn Find(X, BST->Left); //操作2\n\telse \n\t\treturn BST; //操作3 查找成功\n}\n```\n#### 迭代函数实现\n```cpp\nPosition Find(ElementType X, BinTree BST) {\n\twhile(BST) {\n\t\tif (X > BST->Data)\n\t\t\tBST = BST->Right;//操作1\n\t\telse if (X < BST->Data)\n\t\t\tBST = BST->Left;//操作2\n\t\telse \n\t\t\treturn BST;//操作3 查找成功\n\t}\n\treturn NULL;//查找失败\n}\n```\n### (2)查找最大元素和最小元素\n - **最大元素**一定是在树的**最右分支的端结点**上\n - **最小元素**一定是在树的**最左分支的端结点**上\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200329234956549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n#### 查找最大元素\n递归函数\n```cpp\nPosition FindMin(BinTree BST) {\n\tif (!BST ) return NULL;//空树，返回NULL\n\telse if ( !BST->Left )\n\t\treturn BST;\t//找到了最左叶结点\n\telse \n\t\treturn FindMin(BST->Left);//沿左分支继续查找\n}\n```\n迭代函数\n```cpp\nPosition FindMin(BinTree BST) {\t\n\tif (BST) {\n\t\twhile (BST->Left)\tBST = BST->Left;\n\t}\n\treturn BST;\n}\n```\n#### 查找最小元素\n递归函数\n```cpp\nPosition FindMax(BinTree BST) {\n\tif (!BST ) return NULL;//空树，返回NULL\n\telse if ( !BST->Right )\n\t\treturn BST;\t//找到了最左叶结点\n\telse \n\t\treturn FindMin(BST->Right);//沿右分支继续查找\n}\n```\n迭代函数\n```cpp\nPosition FindMax(BinTree BST) {\t\n\tif (BST) {\n\t\twhile (BST->Right)\tBST = BST->Right;\n\t}\n\treturn BST;\n}\n```\n### (3)二叉搜索树的插入\n要保证插入后还为二叉搜索树，关键时要找到元素应该插入的位置。\n\n```cpp\nBinTree Insert(ElementType X, BinTree BST) {\n\tif(!BST) {\t//原树为空，生成并返回一个结点的二叉搜索树\n\t\tBST = malloc(sizeof(struct TreeNode));\n\t\tBST->Data = X;\n\t\tBST->Left = BST->Right = NULL;\n\t} else {\t//开始寻找待插入元素的位置\n\t\tif (X < BST->Data)\n\t\t\tBST->Left = Insert(X, BST->Left);\n\t\telse if (X > BST->Data)\n\t\t\tBST->Right = Insert(X, BST->Right);\n\t\telse printf(\"该值已存在\"); \n\t}\n\treturn BST;\n}\n```\n### (4)二叉搜索树的删除\n考虑三种情况\n\n - 要删除的是**叶结点**：直接删除，并修改其父结点的指针\n - 要删除的结点**只有一个孩子**结点：将其父节点的指针指向要删除结点的孩子结点![在这里插入图片描述](https://img-blog.csdnimg.cn/20200330000838317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n - 要删除的结点**有左、右两棵子树**:要用另一个结点替代被删除的结点（右子树的最小元素或左子树的最大元素）\n\n```cpp\nBinTree Delete(ElementType X, BinTree BST) {\n\tPosition Tmp;\n\tif(!BST) printf(\"要删除的元素未找到\");\n\telse if (X < BST->Data) \n\t\tBST->Left = Delete(X,BST->Left);\n\telse if (X > BST->Data) \n\t\tBST->Right = Delete(X,BST->Right);\n\telse {\t//找到了要删除的结点\n\t\tif (BST->Left && BST->Right) {\t//待删除结点有左右两个孩子\n\t\t\tTmp = FindMin(BST->Right);\t//在右子树中找最小的元素填充删除节点\n\t\t\tBST->Data = Tmp->Data;\n\t\t\tBST->Right = Delete(BST->Data,BST->Right);//填充完后，在右子树中删除该最小元素\n\t\t}\n\t\telse {\t//待删除结点有1个或无子结点\n\t\t\tTmp = BST;\n\t\t\tif (!BST->Left) //有有孩子或无子节点\n\t\t\t\tBST = BST->Right;\n\t\t\telse if (!BST->Right)\n\t\t\t\tBST = BST->Left;\n\t\t\tfree(Tmp);\n\t\t}\n\t}\n\treturn BST;\n}\n```\n\n# 二、平衡二叉树\n## 1.平衡二叉树是什么\n**平衡二叉树**（**AVL树**，Banlanced Binary Tree ),可以为空，当不为空时满足以下性质：\n - 任一结点**左、右子树高度差的绝对值不超过1**\n - 给定**结点数为n**的AVL树的**最大高度为O(log~2~n)**!\n \n**平衡因子**（**BF**,Banlanced Factor）:BF(T) = h~L~-h~R~,h~L~和h~R~分别为T的左、右子树高度\n## 2.平衡二叉树的调整\n### RR插入——RR旋转【右单旋】\n破坏结点（麻烦结点）位于被破坏结点（发现者）的右子树的右子树上\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200329223352879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n\n### LL插入——LL旋转【左单旋】\n\n破坏结点（麻烦结点）位于被破坏结点（发现者）的左子树的左子树上\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200329223302778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n### LR插入——LR旋转\n破坏结点（麻烦结点）位于被破坏结点（发现者）的左子树的右子树上\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200329223831795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n### RL插入——RL旋转\n破坏结点（麻烦结点）位于被破坏结点（发现者）的右子树的左子树上\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200329224042588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n#### ps：有时候插入元素即便不需要调整结构，也可能需要重新计算一些平衡因子\n## 3.平衡二叉树实现\n### 定义部分\n```cpp\ntypedef struct AVLNode *Position;\ntypedef Position AVLTree;\nstruct AVLNode {\n\tElementType Data;\n\tAVLTree Left, Right;\n\tint Height;\n};\nint Max(int a, int b) {\n\treturn a>b?a:b;\n}\n```\n### 左单旋\nps:A必须要有一个左子节点B，将A与B进行左单旋，并更新A与B的高度返回新的根结点B\n```cpp\nAVLTree SingleLeftRotation(AVLTree A) {\n\tAVLTree B = A->Left;\n\tA->Left = B->Right;\n\tB->Right = A;\n\tA->Height = Max( GetHeight(A->Left),GetHeight(A->Right) ) + 1;\n\tB->Height = Max( GetHeight(B->Left),A->Height ) + 1;\n\treturn B;\n}\n```\n### 右单旋\nps:A必须要有一个右子节点B，将A与B进行右单旋，并更新A与B的高度返回新的根结点B\n```cpp\nAVLTree SingleRightRotation(AVLTree A) {\n\tAVLTree B = A->Right;\n\tA->Right = B->Left;\n\tB->Left = A;\n\tA->Height = Max( GetHeight(A->Left),GetHeight(A->Right) ) + 1;\n\tB->Height = Max( A->Height, GetHeight(B->Right) ) + 1;\n\treturn B;\n}\n```\n### LR旋转\nps:A必须要有一个左子节点B，且B必须有一个右子节点C\n先将B与C做右单旋，返回C\n再将A与C做左单旋，返回C\n```cpp\nAVLTree DoubleLeftRightRotation(AVLTree A) {\n\tA->Left = SingleRightRotation(A->Left);\n\treturn SingleLeftRotation(A);\n}\n```\n### RL旋转\nps:A必须要有一个右子节点B，且B必须有一个左子节点C\n先将B与C做左单旋，返回C\n再将A与C做右单旋，返回C\n```cpp\nAVLTree DoubleRightLeftRotation(AVLTree A) {\n\tA->Right = SingleLeftRotation(A->Right);\n\treturn SingleRightRotation(A);\n}\n```\n### 插入\n将X插入AVL树T中，并返回调整后的AVL树\n```cpp\nAVLTree Insert(AVLTree T,ElementType X) {\n\tif (!T) {\t//若要插入的树是空树，则新建一个包含结点X的树\n\t\tT = (AVLTree) malloc(sizeof(struct AVLNode));\n\t\tT->Data = X;\n\t\tT->Height = 0;\n\t\tT->Left = T->Right = NULL;\n\t} else if( X < T->Data) {\n\t\tT->Left = Insert(T->Left, X);\n\t\tif (GetHeight(T->Left)-GetHeight(T->Right) == 2) {//需要左旋\n\t\t\tif (X < T->Left->Data)\n\t\t\t\tT = SingleLeftRotation(T);\t//需要左单旋\n\t\t\telse \n\t\t\t\tT = DoubleLeftRightRotation(T);//左-右双旋\n\t\t}\n\t} else if (X > T->Data) {\n\t\tT->Right = Insert(T->Right, X);\n\t\tif (GetHeight(T->Left)-GetHeight(T->Right) == -2) {//需要右旋\n\t\t\tif (X > T->Right->Data)\n\t\t\t\tT = SingleRightRotation(T);\t//需要右单旋\n\t\t\telse \n\t\t\t\tT = DoubleRightLeftRotation(T);//右-左双旋\n\t\t}\n\t}\n\t//更新树高\n\tT->Height =  Max( GetHeight(T->Left),GetHeight(T->Right) ) + 1;\n\treturn T;\n}\n```\n### 完整代码演示\n\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\ntypedef int ElementType;\ntypedef struct AVLNode *Position;\ntypedef Position AVLTree;\nstruct AVLNode {\n\tElementType Data;\n\tAVLTree Left, Right;\n\tint Height;\n};\nint Max(int a, int b) {\n\treturn a>b?a:b;\n}\nint GetHeight(AVLTree A) {\n    if (A)\n        return A->Height;\n    else \n        return 0;\n}\nAVLTree SingleLeftRotation(AVLTree A) {//左单旋\n\tAVLTree B = A->Left;\n\tA->Left = B->Right;\n\tB->Right = A;\n\tA->Height = Max( GetHeight(A->Left),GetHeight(A->Right) ) + 1;\n\tB->Height = Max( GetHeight(B->Left),A->Height )+ 1;\n\treturn B;\n}\nAVLTree SingleRightRotation(AVLTree A) {//右单旋\n\tAVLTree B = A->Right;\n\tA->Right = B->Left;\n\tB->Left = A;\n\tA->Height = Max( GetHeight(A->Left),GetHeight(A->Right) ) + 1;\n\tB->Height = Max( A->Height, GetHeight(B->Right) ) + 1;\n\treturn B;\n}\nAVLTree DoubleLeftRightRotation(AVLTree A) {//左-右双旋\n\tA->Left = SingleRightRotation(A->Left);\n\treturn SingleLeftRotation(A);\n}\nAVLTree DoubleRightLeftRotation(AVLTree A) {//右-左双旋\n\tA->Right = SingleLeftRotation(A->Right);\n\treturn SingleRightRotation(A);\n}\nAVLTree Insert(AVLTree T,ElementType X) {//将X插入AVL树T中\n\t\n\tif (!T) {\t//若要插入的树是空树，则新建一个包含结点X的树\n\t\tT = (AVLTree) malloc(sizeof(struct AVLNode));\n\t\tT->Data = X;\n\t\tT->Height = 0;\n\t\tT->Left = T->Right = NULL;\n        \n\t} else if( X < T->Data) {\n\t\tT->Left = Insert(T->Left, X);\n\t\tif (GetHeight(T->Left)-GetHeight(T->Right) == 2) {//需要左旋\n\t\t\tif (X < T->Left->Data)\n\t\t\t\tT = SingleLeftRotation(T);\t//需要左单旋\n\t\t\telse \n\t\t\t\tT = DoubleLeftRightRotation(T);//左-右双旋\n\t\t}\n\t} else if (X > T->Data) {\n\t\tT->Right = Insert(T->Right, X);\n\t\tif (GetHeight(T->Left)-GetHeight(T->Right) == -2) {//需要右旋\n\t\t\tif (X > T->Right->Data)\n\t\t\t\tT = SingleRightRotation(T);\t//需要右单旋\n\t\t\telse \n\t\t\t\tT = DoubleRightLeftRotation(T);//右-左双旋\n\t\t}\n\t}\n\t//更新树高\n\tT->Height =  Max( GetHeight(T->Left),GetHeight(T->Right) ) + 1;\n    return T;\n}\nvoid PreOrderTraversal(AVLTree T) {\n\tif(T) {\n\t\tprintf(\"%d\", T->Data);\n\t\tPreOrderTraversal( T->Left);\n\t\tPreOrderTraversal( T->Right);\n\t}\n}\nvoid InOrderTraversal(AVLTree T) {\n\tif(T) {\n\t\tInOrderTraversal( T->Left);\n\t\tprintf(\"%d\", T->Data);\n\t\tInOrderTraversal( T->Right);\n\t}\n}\nint main() {\n    AVLTree T = NULL;\n    int i;\n    for (i = 1; i < 10; i++) {\n        T = Insert(T,i);\n    }\n    PreOrderTraversal(T);//前序遍历\n    printf(\"\\n\");\n    InOrderTraversal(T);//中序遍历\n    return 0;\n}\n```\n输出结果：\n\n> 421365879\n123456789\n\n根据前序遍历与中序遍历易还原得到这样一个平衡二叉树\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200330015103371.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n# 三、判断是否同一棵二叉搜索树\n题意：给定一个插入序列确定唯一一棵二叉搜索树，对于输入的各种插入序列，判断它们是否能生成一样的二叉搜索树\n\n如何判断两个序列是否对应相同搜索树呢\n**建一棵树，再判别其他序列是否与该树一致！**\n如输入3 1 4 2确定一颗二叉搜索树，判断3 4 1 2和 3 2 4 1是否对应同一棵树\n\n## 1.搜索树表示\n```cpp\ntypedef struct TreeNode *Tree;\nstruct TreeNode {\n\tint v;\n\tTree Left,Right;\n\tint flag;\t//用来标记该结点是否已经被搜索过 为1则搜索过\n};\n```\n\n## 2.建搜索树T\n```cpp\nTree MakeTree(int N) {\n\tTree T;\n\tint i, V;\n\tscanf(\"%d\", &V);\n\tT = NewNode(V);\n\tfor(i = 1; i < N; i++) {\n\t\tscanf(\"%d\",&V);\n\t\tT = Insert(T,V);//将剩余结点插入二叉树\n\t}\n\treturn T;\n}\n```\n\n```cpp\nTree NewNode(int V) {\n\tTree T = (Tree)malloc(sizeof(struct TreeNode));\n\tT->v = V;\n\tT->Left = T->Right = NULL;\n\tT->flag = 0;\n\treturn T;\n}\n```\n\n```cpp\nTree Insert(Tree T, int V) {\n\tif(!T) T = NewNode(V);\n\telse {\n\t\tif (V > T->v) \n\t\t\tT->Right = Insert(T->Right, V);\n\t\telse \n\t\t\tT->Left = Insert(T->Left,V);\n\t}\n\treturn T;\n}\n```\n\n## 3.判别一序列是否与搜索树T一致\n方法：在树T中按顺序搜索序列3 2 4 1中的每个数\n\n - **若每次搜索所经过的结点在前面均搜索过，则一致** \n - **否则（某次搜索中遇到了前面未出现的结点），则不一致**\n```cpp\nint check(Tree T,int V) {\n\tif(T->flag) {//这个点查找过了,则判断要在左子树还是右子树查找\n\t\tif(V < T->v) return check(T->Left,V);\n\t\telse if(V > T->v) return check(T->Right,V);\n\t\telse return 0;\n\t}\n\telse {\t//要查找的刚好是这个点，进行标记\n\t\tif(V == T->v) {\n\t\t\tT->flag = 1;\n\t\t\treturn 1;\n\t\t}\n\t\telse return 0; //碰到了以前没见过的点\n\t}\n}\n```\n判断长度为N的插入序列产生的树是否与搜索树一致\n```cpp\nint Judge(Tree T,int N) {\n\tint i, V, flag = 0;//flag=0代表当前还一致，为1则说明已经不一致了\n\tscanf(\"%d\",&V);\n\tif (V != T->v) flag = 1;\n\telse T->flag = 1;\n\tfor(i = 1; i < N; i++) {\n\t\tscanf(\"%d\", &V);\n\t\tif( (!flag) && (!check(T,V)) ) flag = 1;\n\t}\n\tif(flag) return 0;\n\telse return 1;\n}\n```\n清除T中个结点的flag标记使其为0\n```cpp \nvoid ResetT(Tree T) {\n\tif(T->Left) ResetT(T->Left);\n\tif(T->Right) ResetT(T->Right);\n\tT->flag = 0;\n}\n```\n释放T的空间\n```cpp\nvoid FreeTree(Tree T) {\n\tif(T->Left) FreeTree(T->Left);\n\tif(T->Right) FreeTree(T->Right);\n\tfree(T);\n}\n```\n","sources":["xlog"],"attributes":[{"value":"shu-ju-jie-gou-xue-xi-bi-ji-5-er-cha-sou-suo-shu-yu-ping-heng-er-cha-shu-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/shu-ju-jie-gou-xue-xi-bi-ji-5-er-cha-sou-suo-shu-yu-ping-heng-er-cha-shu-md"],"date_published":"2020-03-30T01:53:11.000Z"}}}