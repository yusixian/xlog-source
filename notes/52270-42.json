{"characterId":52270,"noteId":42,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreih5idqe6xgzxrldquxpcolr3qdb6z7e6yr2qd73q7afieqb2cn7fi","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:39:04.000Z","updatedAt":"2023-04-05T11:30:34.000Z","deletedAt":null,"publishedAt":"2022-01-17T14:30:17.000Z","transactionHash":"0xdc576b85b753d220cd2851aa2bc5e951b6f739ada0a82dfd613ec82afbd0296e","blockNumber":30317649,"logIndex":8,"updatedTransactionHash":"0xc46e6420647c182f93be2a8f6ff81b5a4ecb324593e04faf4495d3f27e6f4558","updatedBlockNumber":30335139,"updatedLogIndex":0,"metadata":{"uri":"ipfs://bafkreih5idqe6xgzxrldquxpcolr3qdb6z7e6yr2qd73q7afieqb2cn7fi","type":"NOTE","content":{"tags":["post","前端","JavaScript","纯函数","青训营"],"type":"note","title":"青训营 |「跟着月影学 JavaScript」笔记","content":"---\ntitle: 青训营 |「跟着月影学 JavaScript」笔记\nlink: note/front-end/bytedance-note/javascript-learing\ncatalog: true\ndate: 2022-01-17 14:30:17\nsubtitle: 面向对象的设计、高阶函数（节流、防抖、批处理、可迭代化）\nsticky: true\nlang: cn\ntags:\n- 前端\n- JavaScript\n- 纯函数\ncategories:\n- [笔记, 青训营笔记]\n---\n\n这节课是由月影老师讲的，干货满满，包括了面向对象的设计、组件封装、高阶函数（节流、防抖、批处理、可迭代化）\n\n# 本堂课重点内容\n\n## 写好js的原则\n\n### 各司其责\n\n举个栗子：写一段JS，控制一个网页，让他支持浅色/深色两种模式。你会怎么做呢？\n\n我的第一反应：写一个深色类，在切换按钮事件进行切换。这也是课件里讲的第二版。\n\n- 第一版 直接切换样式，不妥，但能用\n\n```js\nconst btn = document.getElementById('modeBtn');\nbtn.addEventListener('click', (e) => {\n  const body = document.body;\n  if(e.target.innerHTML === '☀️') {\n    body.style.backgroundColor = 'black';\n    body.style.color = 'white';\n    e.target.innerHTML = '🌙';\n  } else {\n    body.style.backgroundColor = 'white';\n    body.style.color = 'black';\n    e.target.innerHTML = '☀️';\n  }\n});\n```\n\n- 第二版 封装了深色类\n\n```js\nconst btn = document.getElementById('modeBtn');\nbtn.addEventListener('click', (e) => {\n  const body = document.body;\n  if(body.className !== 'night') {\n    body.className = 'nignt';\n  } else {\n    body.className = '';\n  }\n});\n```\n\n- 第三版 既然是**完全的展示行为**，那么可以完全由html和css实现\n\n  将切换作为一个type为 [`checkbox`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input/checkbox) 控件，id为 `modeCheckBox`，使用 `label` 标签的 [`for`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/label#attr-for) 控件，id为 `modeCheckBox`，使用 `label` 标签的 [`for`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/label#attr-for) 属性将其关联到这个控件，再把checkbox隐藏掉即可实现点击切换模式。![image-20220117144502775.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4575ccd15ded4293bc8e7dbf2c6e6bb0~tplv-k3u1fbpfcp-watermark.image?)\n\n  \"~~只要不写代码就不会有bug~~\" ，这也是各司其责的一种体现。\n\n总结：需要避免不必要的由js直接操作样式，可以用class来表示状态，而纯展示类的交互寻求零JS方案。版本2也是有其好处的，如适应性是不一定有版本3的好的。\n\n### 组件封装\n\n组件是指web页面上抽出来的一个个包含模板(HTML)、功能（JS）和样式（CSS）的单元，好的组件具备封装性、正确性、扩展性和复用性。虽然现在由于有很多优秀的组件存在，往往我们不需要去自己设计一个组件，但我们也要去试着了解他们的实现。\n\n举个栗子：用原生JS写一个电商网站的轮播图，应该怎么实现？\n\n- 结构：HTML中的无序列表（ `<ul>` ）\n  - 轮播图是典型的列表结构，可以用无序列表 `<ul>` 元素来实现，每个图放在一个li标签中。\n\n- 表现：CSS 绝对定位\n  - 使用CSS的绝对定位，将图片重叠在一个位置\n  - 切换状态使用修饰符（modifier） \n    - selected\n  - 轮播图切换动画使用CSS  [`transition`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition) 实现\n- 行为：JS\n  - API设计应保证原子操作，职责单一，满足灵活性\n    - ps：原子操作就是指 不可中断的一个或一系列操作，比如操作系统中的原语wait、read等。\n  - 封装一些事件：getSelectedItem()、getSelectedItemIndex()、slidTo()、slideNext()、slidePrevious()……\n  - 更进一步：控制流，使用自定义事件来进行解耦。\n\n总结：组件封装需要注意其结构设计、展现效果、行为设计（API、Event等）是否达标\n\n思考：如何来改进这个轮播图？\n\n#### **重构1：插件化，解耦**\n\n- 将控制元素抽取成一个个插件（左右小箭头、底下的四个小圆点）等等![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71de521e581e4c4e82d9f6a312d2c638~tplv-k3u1fbpfcp-watermark.image?)\n\n- 插件与组件之间通过依赖注入方式建立联系、\n\n  ![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d148965ec0654ec3914515d835445368~tplv-k3u1fbpfcp-watermark.image?)\n\n这样的好处？组件的构造器做的工作就只是将组件们一一注册了，日后复用的时候不需要的组件直接将构造器注释掉即，无需关注其他的。\n\n再进一步扩展？\n\n#### 重构2：模板化\n\n将html也模板化，做到只需一个 `<div class='slider‘></div>` 就能实现图片轮播，修改控制器的构造，传入图片列表。\n\n#### 重构3：抽象化\n\n将通用的组件模型，抽象出来一个组件类（Component），其他组件类通过继承该类并实现其render方法。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7805999b1dc4c5581483ac56a72e383~tplv-k3u1fbpfcp-watermark.image?)\n\n```js\nclass Component{\n    constructor(id, opts = {name, data: []}) {\n        this.container = document.getElementById(id);\n        this.options = opts;\n        this.container.innerHTML = this.render(opts.data);\n    }\n    registerPlugins(...plugins) { \n        plugins.forEach( plugin => {\n            const pluginContainer = document.createElement( 'div');\n            pluginContainer.className = `${name}__plugin`;\n            pluginContainer.innerHTML = plugin.render(this.options.data);\n            this.container.appendchild(pluginContainer);\n\n            plugin.action(this);\n        });\n    }\n    render(data) {\n        /* abstract */\n        return ''\n    }\n}\n```\n\n总结：\n\n- 组件设计的原则——封装性、正确性、拓展性和复用性\n- 实现步骤：结构设计、展现效果、行为设计\n- 三次重构\n  - 插件化\n  - 模板化\n  - 抽象化\n- 改进：CSS模板化、父子组件的状态同步和消息通信等等\n\n### 过程抽象\n\n- 处理局部细节控制的一些方法\n\n- 函数式编程思想的基础应用\n\n  ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/948dc7f6553a40c5b6fa717ce9fafaf4~tplv-k3u1fbpfcp-watermark.image?)\n\n#### 应用：操作次数限制\n\n  - 一些异步交互\n  - 一次性的HTTP请求\n\n有这样一段代码，在每次点击时延时2s后移除该节点，但如果用户在该节点还没完全移除的时候又点了几次则会报错。\n\n```js\nconst list = document.querySelector('ul');\nconst buttons = list.querySelectorAll('button');\nbuttons.forEach((button)=>{\n    button.addEventListener('click', (evt) => {\n        const target = evt.target;\n        target.parentNode.className = 'completed';\n        setTimeout(()=>{\n            list.removeChild(target.parentNode);\n        },2000);\n    })\n});\n```\n\n   而这个操作次数的限制，则可以抽象出来一个高级函数\n\n```js\nfunction once(fn) {\n    return function(...args) {\n        if(fn) {\n            const ret = fn.apply(this, args);\n            fn = null;\n            return ret;\n        }\n    }\n}\nconst list = document.querySelector('ul');\nconst buttons = list.querySelectorAll('button');\nbuttons.forEach((button)=>{\n    button.addEventListener('click', once((evt) => {\n        const target = evt.target;\n        target.parentNode.className = 'completed';\n        setTimeout(()=>{\n            list.removeChild(target.parentNode);\n        },2000);\n    }))\n});\n```\n\n如代码中显示的那样，这个函数once接受一个函数，返回的也是一个函数，判断接受的函数是否为null，若不为null则执行这个函数并返回其结果，若接受的函数为null则返回一个不进行任何操作的函数。click事件注册的实际上是once返回的函数，这样再怎么点击也不会报错了。\n\n> ps：好精彩的应用例子！\n\n为了让 ”只执行一次“ 这个需求覆盖不同的事件处理，将这个需求剥离出来，这个过程就称之为 **过程抽象**\n\n## 高阶函数\n\n- 以函数作为参数\n- 以函数作为返回值\n- 常用于作为 **函数装饰器**\n\n```js\nfuntion HOF(fn) {\n    return function(...args) {\n        return fn.apply(this, args);\n    }\n}\n```\n\n### 常用高阶函数\n\n#### Once 只执行一次\n\n前文讲过，这里不再阐述\n\n#### Throttle 节流\n\n为函数添加一个间隔time，每隔time事件调用一次函数，节省其需求，比如某个事件很容易持续的发生（如鼠标移上去就触发），那么他会一直速度特别快的调用这个事件函数，这个时候为其加一个节流函数则可以防止崩溃节约流量。\n\n```js\nfunction throttle(fn, time = 500) {\n    let timer;\n    return function(...args) {\n        if(!timer) {\n            fn.apply(this, args);\n            timer = setTimeout(() => {\n                timer = null;\n            }, time);\n        }\n    }\n}\nbtn.onclick = throttle(function(e){\n    /* 事件处理 */\n    circle.innerHTML = parseInt(circle.innerHTML)+1;\n    circle.className = 'fade';\n    setTimeout(() => circle.className = '', 250);\n});\n```\n\n对原始的函数进行包装，没有timer的话就注册一个timer，500ms后取消，因为在这500ms中这个timer都还存在，所以不会去执行函数（或者说执行空函数），500ms后timer取消了，函数就可以被调用执行了。\n\n#### Debounce 防抖\n\n在上面的节流中，timer存在期间是不会去执行函数，而防抖是在每次事件一开始的时候清空timer，然后设置timer为dur，当事件调用dur时间并且没有新的事件再次调用时（比如鼠标移动后悬停一段时间），函数就可以被调用执行了。\n\n```js\nfunction debounce(fn, dur) {\n    dur = dur || 100;   // dur若不存在则设置dur为100ms\n    var timer;\n    return function() {\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n            fn.apply(this, arguments);\n        }, dur);\n    }\n}\n```\n\n#### Consumer\n\n这是将一个函数变成类似setTimeout这样的异步操作的函数，如调用了很多次某事件，将这些事件丢到一个列表中，按设定好的时间隔一段时间并执行返回其结果。先来看代码：\n\n```js\nfunction consumer(fn, time) {\n    let tasks = [],\n        timer;\n    return function (...args) {\n        tasks.push(fn.bind(this, ...args));\n        if(timer == null) {\n            timer = setInterval(() => {\n                tasks.shift().call(this);\n                if(tasks.length <= 0) {\n                    clearInterval(timer);\n                    timer = null;\n                }\n            }, time);\n        }\n    }\n}\nbtn.onclick = consumer((evt) => {\n    /*\n     * 事件处理 如每次调用了很多次某事件，将这些事件丢到\n     * 一个列表中，按设定好的时间隔一段时间并执行返回其结果。 \n     */\n    let t = parseInt(count.innerHTML.slice(1)) + 1;\n    count.className = 'hit';\n    let r = t * 7 % 256,\n        g = t * 17  % 128,\n        b = t * 31  % 128;\n    count.style.color = `rgb(${r}, ${g}, ${b})`.trim();\n    setTimeout(() => {\n        count.className = 'hide';\n    }, 500);\n}, 800);\n```\n\n这里的事件处理实现了点击按钮时执行这个不断显示+count并在500ms后渐隐，而快速点击时，则将这个点击事件存储到是事件列表中每隔800ms执行（不然上一个+count还未消失）。\n\n要弄明白函数原理，得从其中的bind函数和shift函数和call说起：\n\n>  [`bind()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n\n> [`shift()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift) 方法从数组中删除**第一个**元素，并返回该元素的值。此方法更改数组的长度。与之相反的则是 [`unshift()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift) 插入第一个元素。\n>\n> 与之相似的一对方法还有，[`pop()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop) 和 [`push()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push) ，他们作用于数组最后一个元素\n\n> [`call()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call) 方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数。\n\n那么不难看出上面这个函数的用途，将每次准备调用的函数放入tasks列表中，若定时器为空则设置一个定时器执行内容 `定时执行tasks出队，若全部tasks已经清空（当前没有任务了）则将定时器清除` ，若定时器不为空则不做操作（但放到tasks列表中了）。\n\n#### Iterative\n\n将一个函数，变成可迭代使用的的，这通常用于一个函数要给一组对象执行批量操作的时候。如批量设置颜色，代码如下：\n\n```js\nconst isIterable = obj => obj != null && typeof obj[Symbol.iterator] === 'function';\nfunction iterative(fn) {\n    return function(subject, ...rest) {\n        if(isIterable(subject)) {\n            const ret = [];\n            for(let obj of subject) {\n                ret.push(fn.apply(this, [obj, ...rest]));\n            }\n            return ret;\n        }\n        return fn.apply(this, [subject, ...rest]);\n    }\n}\nconst setColor = iterative((el, color) => {\n    el.style.color = color;\n})\nconst els = document.querySelectorAll('li:nth-child(2n+1)');\nsetColor(els, 'red');\n```\n\n#### Toggle\n\n切换状态，也可以封装成一个高级函数，这样有多少种状态只要添加到里面就可以了。\n\n例子：\n\n```js\nfunction toggle(...actions) {\n    return function (...args) {\n        let action = actions.shift();\n        action.push(action);\n        return action.apply(this, args);\n    }\n}\n// 多少态都可以!\nswitcher.onclick = toggle(\n    evt => evt.target.className = 'off',\n    evt => evt.target.className = 'on'\n);\n```\n\n\n\n#### 思考\n\n为什么要使用高阶函数？\n\n了解一个概念：**纯函数，是指一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用**\n\n这也就意味着，纯函数是非常靠谱的，不会对外界产生影响。\n\n- 方便进行单元测试！\n- 减少系统中非纯函数的数量，从而使得系统可靠性增加\n\n#### 其他一些思考\n\n- 命令式与声明式，没有优劣之分\n- 过程抽象 / HOF / 装饰器\n- 命令式 / 声明式\n- 代码风格、效率、质量的权衡。\n  - 根据场景来权衡\n## 总结感想\n\n太牛了！！\n\n看完这节课，收获非常多，实现一个真正意义上的组件原来需要这么多步骤，原来js也能实现如此面向对象的设计，结合之前学过的c++/java的设计模式，发现都是有共通之处的，一个组件可以向下细分为许许多多的子组件。后面的高阶函数更是知识盲区，原来js还能实现这些方法\n\n> 本文引用的内容大部分来自月影老师的课以及MDN。\n","sources":["xlog"],"summary":"这节课是由月影老师讲的，干货满满，包括了面向对象的设计、组件封装、高阶函数（节流、防抖、批处理、可迭代化） 写好js的原则\n各司其责\n\n举个栗子：写一段JS，控制一个网页，让他支持浅色/深色两种模式。你会怎么做呢？\n\n我的第一反应：写一个深色类，在切换按钮事件进行切换…","attributes":[{"value":"javascript-learingmd","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/javascript-learingmd"],"date_published":"2022-01-17T14:30:17.000Z"}}}