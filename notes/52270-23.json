{"characterId":52270,"noteId":23,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreide64zajjrfvv3zrwxa2rmdbv73gwpoi67k2ixpbdqodbwftzcoca","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:36:12.000Z","updatedAt":"2023-04-05T06:36:12.000Z","deletedAt":null,"publishedAt":"2022-03-27T22:00:56.000Z","transactionHash":"0xb7216c8d5fe8021bfcdec160f48a3012b791b8beaff373f9040a0b29932022b2","blockNumber":30317477,"logIndex":3,"updatedTransactionHash":"0xb7216c8d5fe8021bfcdec160f48a3012b791b8beaff373f9040a0b29932022b2","updatedBlockNumber":30317477,"updatedLogIndex":3,"metadata":{"uri":"ipfs://bafkreide64zajjrfvv3zrwxa2rmdbv73gwpoi67k2ixpbdqodbwftzcoca","type":"NOTE","content":{"tags":["post","前端","笔试题"],"type":"note","title":"2022春网易互联网前端暑期实习笔试","content":"---\ntitle: 2022春网易互联网前端暑期实习笔试\nlink: 160-yanxuan-examination-2022-spring-frontend\ncatalog: true\nlang: cn\ndate: 2022-03-27 22:00:56 \nsubtitle: 编程题4道（20、25、25、30），问答题1道（10分附加分） \ncover: img/header_img/galaxy-ngc-3190-wallpaper-for-2880x1800-60-653.jpg\ntags:\n- 前端\n- 笔试题\ncategories:\n- [笔试面经, 笔试复盘]\n---\n\n笔试完第三天就收到约面邮件了，前端要求不高\n\n- 问答题1道（10分附加分） \n    - 问的设计模式，写两种结构型/行为型设计模式，包括原理、使用场景和个人理解\n- 编程题4道\n    - 打怪（AC 100%）\n    - 求字符串的最大分数 (25分，AC 37.5%)\n    - 构造完全二叉树 (25分，还没做, 0%)\n    - 走出地图的最短时间 (30分，AC 100%)\n# 打怪 (20分，AC 100%)\n两个怪兽，生命值分别是a和b\n你有两个技能\n- 一个是单体攻击，伤害是x\n- 另一个是群体攻击，伤害是y\n- 给定 `a`, `b`, `x`, `y` 求使用最少几个技能可以杀死两个怪兽。\n\n输入样例：5 3 3 2\n输出样例：3\n\n输入样例2：20 20 5 2\n输出样例2：8\n\n输入样例2：20 20 1 2\n输出样例2：10\n## 思路\nDFS剪剪枝就过了。另外也可以贪心（\n```cpp\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint a, b, x, y;\nint dfs(int a, int b, int cnt) {\n    if(a <= 0 && b <= 0) return cnt;\n    else if(a <= 0) a = 0;\n    else if(b <= 0) b = 0;\n    int higher = max(a, b);\n    if(y >= x) return higher%y == 0? higher/y: (higher/y)+1;\n    int minx;\n    if(a <= 0) minx = dfs(a, b-x, cnt+1);\n    else if(b <= 0) minx = dfs(a-x, b, cnt+1);\n    else minx = min(dfs(a-x, b, cnt+1), dfs(a, b-x, cnt+1));\n    int miny = dfs(a-y, b-y, cnt+1);\n    return min(minx, miny);\n}\nint main() {\n    cin >> a >> b >> x >> y;\n    cout << dfs(a, b, 0) << endl;\n    return 0;\n}\n\n```\n# 求字符串的最大分数 (25分，AC 37.5%)\n给定一个全是小写字母的字符串，如果字符串中相邻的两个字母相等或者在字母表中的位置相邻，那么他们两个可以贡献分数。其中'a'贡献1分，'b'贡献2分.....'z'贡献26分。每个字母只能使用一次。\n输入 \"aca\" 输出0 因为相邻的字母没有在字母表中相邻 也不相等\n输入 \"abb\" 输出4 因为ab分值是3，bb分值是4，但是每个字母只能使用一次，因此选择bb\n## 思路\n好，我的思路完全是错的就不放代码了，说大佬的思路：\n- `dp[0][i]`表示不标记第 `i` 个字母的最大分数\n- `dp[1][i]`表示标记第 `i` 个字母的最大分数。\n- 转移方程为\n    - `dp[0][i] = max(dp[0][i-1], dp[1][i-1])` 不标记则为上一个的最大分数\n    - `dp[1][i] = max(dp[1][i-1], (dp[0][i-1]+ s[i]-'a'+1 +s[i-1]-'a'+1)*(abs(s[i]-s[i-1]) <= 1))` 标记则为max(上一个被标记了的最大分数, 上一个未被标记的最大分数+当前标记这两个字母后的分数)\n# 构造完全二叉树 (25分，还没做)\n给你一个整数n，使用1，2，3...n这n个数构造完全二叉树，满足所有节点和父节点的乘积是偶数(根节点除外，因为他没有父节点)，输出构造的二叉树层序遍历的结果。答案不唯一。\n输入 4 输出 1 2 4 3\n## 思路\n看到有思路说就是个模拟，将奇数都放到叶子节点然后剩下的随便放就行。\n# 走出地图的最短时间 (30分，AC 100%)\n给你两个整数m,n，表示有m行n列组成的地图，地图中有0和1，其中0表示土地，1表示沼泽\n- 从土地移动到土地或从沼泽移动到沼泽耗时1单位\n- 从土地移动到沼泽或从沼泽移动到土地耗时为2单位\n- 也就是相同耗时为1，不同耗时为2\n- 每次只能向下，向左，向右移动，求从左上角移动到右下角需要的最少的时间\neg:\n输入\n```\n3 3\n1 0 0\n1 1 1\n0 0 1\n```\n输出\n```\n4\n```\n## 思路\n- 因为只能向下，向左，向右移动，且向左不会减少耗时也就是根本不用往左走，所以只需要dp，记录当前位置的上侧和左侧的最小耗时即可\n\n## 代码\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 510;\nint n, m;\nint map[maxn][maxn];\nint dp[maxn][maxn];\nint main() {\n    cin >> n >> m;\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j)\n            cin >> map[i][j];\n    }\n    for(int i = 1; i < n; ++i) \n        dp[i][0] = dp[i-1][0] + (map[i-1][0] == map[i][0] ? 1: 2);\n    for(int i = 1; i < m; ++i) \n        dp[0][i] = dp[0][i-1] + (map[0][i-1] == map[0][i] ? 1: 2);\n    for(int i = 1; i < n; ++i) {\n        for(int j = 1; j < m; ++j) {\n            int top = dp[i-1][j] + (map[i-1][j] == map[i][j] ? 1: 2);\n            int left = dp[i][j-1] + (map[i][j-1] == map[i][j] ? 1: 2);\n            dp[i][j] = min(top, left);\n        }\n    }\n    cout << dp[n-1][m-1] << endl;\n    return 0;\n}\n```\n","sources":["xlog"],"attributes":[{"value":"2022-chun-wang-yi-hu-lian-wang-qian-duan-shu-qi-shi-xi-bi-shi-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/2022-chun-wang-yi-hu-lian-wang-qian-duan-shu-qi-shi-xi-bi-shi-md"],"date_published":"2022-03-27T22:00:56.000Z"}}}