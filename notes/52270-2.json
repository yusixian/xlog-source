{"characterId":52270,"noteId":2,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreiheswqfgdcepxoujdezlkwtykat5qdgosgb3c7ak74lxbktlufvmy","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T04:31:33.000Z","updatedAt":"2023-04-05T04:31:33.000Z","deletedAt":null,"publishedAt":"2022-03-17T23:50:52.000Z","transactionHash":"0x66038958f2bfd47f8152f4dced47626ea72effca4e00aa07f8484d083d18a5c0","blockNumber":30309998,"logIndex":1,"updatedTransactionHash":"0x66038958f2bfd47f8152f4dced47626ea72effca4e00aa07f8484d083d18a5c0","updatedBlockNumber":30309998,"updatedLogIndex":1,"metadata":{"uri":"ipfs://bafkreiheswqfgdcepxoujdezlkwtykat5qdgosgb3c7ak74lxbktlufvmy","type":"NOTE","content":{"tags":["post","前端","JavaScript"],"type":"note","title":"深入JavaScript学习之路（二）JavaScript中的类","content":"---\ntitle: 深入JavaScript学习之路（二）JavaScript中的类\nlink: js-learning-2\ncatalog: true\nsubtitle: 红宝书读书笔记 第八章 p205\ndate: 2022-03-17 23:50:52\ncover: img/header_img/galaxy-ngc-3190-wallpaper-for-2880x1800-60-653.jpg\ntags:\n- 前端\n- JavaScript\ncategories:\n- [笔记, 前端, JavaScript]\n---\n\n上一节都是基于ES5的特性来模拟实现类似于类class的行为，不难看出这些方法各有各自的问题，实现继承的代码也显得非常冗长和混乱。因此，`ES6` 中新引入的 `class` 关键字具备了正式定义类的能力，它实际上是一个**语法糖**，背后使用的仍然是原型和构造函数的概念。\n# 类定义\n类声明与类表达式两种定义方法，都使用 `class` 关键字\n```js\n// 类声明\nclass Person {} \t\n\n// 类表达式\nconst Animal = class {}\n```\n与函数表达式类似，**类表达式在它们被求值前也不能引用**。\n但不同之处在于\n- **函数声明可以提升，而类定义不能提升**\n- 函数受 **函数作用域** 限制，类受 **块作用域** 限制\n```js\n// 函数声明可以提升，而类定义不能提升*\nconsole.log(FunctionExpression); // undefined \nvar FunctionExpression = function() {}; \nconsole.log(FunctionExpression); // function() {}\n\nconsole.log(ClassExpression); // undefined \nvar ClassExpression = class {}; \nconsole.log(ClassExpression); // class {} \n// 函数受函数作用域限制，类受块作用域限制\n{ \n    function FunctionDeclaration() {} \n    class ClassDeclaration {} \n} \nconsole.log(FunctionDeclaration); // FunctionDeclaration() {} \nconsole.log(ClassDeclaration); // ReferenceError: ClassDeclaration is not defined\n```\n## 类构成\n类可以包括以下方法，但都不是必须的，空的类定义仍然有效。\n- 构造函数（constructor）\n- 获取函数及设置函数（get和set）\n- 静态类方法（static）\n- 其他实例方法\n\n默认情况下，类定义中的代码都在 **严格模式** 下执行。\n首字母大写这个就不必多说了，可以用于区分通过他创建的实例\n\n**类表达式**的**名称**是**可选**的。在把类表达式赋值给变量后，可以通过 `name` 属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。\n```js\nlet Person = class PersonName { \n    identify() { \n        console.log(Person.name, PersonName.name); \n    } \n} \nlet p = new Person(); \np.identify(); // PersonName PersonName \nconsole.log(Person.name); // PersonName \nconsole.log(PersonName); // ReferenceError: PersonName is not defined \n```\n# 类构造函数\n`constructor` 关键字用于在类定义块内部**创建类的构造函数**。\n-  `constructor` 会告诉解释器：使用 `new` 操作符创建类的新实例时，应该**调用这个函数。**\n- 构造函数的定义**不是必需**的，**不定义构造函数**相当于将构造函数**定义为空函数**。\n## 1、实例化\nconstructor函数实际上也是个语法糖，他让 JS 解释器知道使用 `new` 来定义类的一个实例时应使用 `constructor` 函数进行实例化。\n\n让我们复习一下使用 `new` 调用构造函数所执行的操作：\n\n- 在内存中创建一个新对象 ` let obj = new Object()`\n- 将新对象内部的 `[[Prototype]]` 赋值为构造函数的 `prototype`  ` obj.__proto__ = constructor.prototype;`\n- 构造函数内部的 `this` 指向这个新对象 \n- 执行这个构造函数内部代码\n\t- 上述两步 相当于 `let res = contructor.apply(obj,  args)`\n- 若构造函数返回 **非空对象**， 则**返回该对象** `res`；否则，返回刚创建的新对象 `obj`\n\t- `return typeof  res === 'object' ? res: obj;`\n\n\n\n类实例化时传入的参数会作为**构造函数的参数**，若不需要参数，则类名后面的括号也是可选的 可以直接 `new Person`\n\n类构造函数会在执行之后返回一个对象，这个对象会被用作实例化的对象。\n注意：若构造函数返回的这个对象 `res` 是一个非空对象，且这个对象与new中第一步新建的对象`obj`无关系，则新建的对象会被回收哦，而且通过 `instanceof` 检测是无法检测出跟该类有关联，因为并没有修改原型指针。\n\n## 2、类的本质？\n```js\nclass Person {} \nconsole.log(Person); // class Person {} \nconsole.log(typeof Person); // function\n```\n是函数！前面也说到了，它本质上就是一个语法糖，所以它具有跟函数一样的行为。\n可以向其他对象或函数引用一样将其当作参数传递，也可以立即实例化（类似函数表达式的立即执行）\n```js\n// 类可以像函数一样在任何地方定义，比如在数组中\nlet classList = [ \n\tclass { \n\t\tconstructor(id) { \n\t\t\tthis.id_ = id; \n\t\t\tconsole.log(`instance ${this.id_}`); \n\t\t} \n\t} \n]; \nfunction createInstance(classDefinition, id) { \n\treturn new classDefinition(id); \n} \nlet foo = createInstance(classList[0], 3141); // instance 3141 \n\n// 立即执行\nlet p = new class Foo { \n\tconstructor(x) { \n\t\tconsole.log(x); \n\t} \n}('bar'); // bar \nconsole.log(p); // Foo {} \n```\n# 实例、原型和类成员\n类可以非常方便的定义以下三种成员，跟其它语言相似。\n\n- 实例上的成员\n- 原型上的成员\n- 类本身的成员（静态类成员）\n## 实例成员\n在`constructor` 中可以通过this为新创建的实例添加自有属性，每个实例是不会共享这里的属性的。\n- ps：在类块中直接写的成员也会成为实例属性\n```js\nclass Person { \n\tsex = '女'\n\tage = 21\n\tconstructor() { \n\t\t// 这个例子先使用对象包装类型定义一个字符串\n\t\t// 为的是在下面测试两个对象的相等性\n\t\tthis.name = new String('Jack'); \n\t\tthis.sayName = () => console.log(this.name); \n\t\tthis.nicknames = ['Jake', 'J-Dog'] \n\t} \n} \nlet p1 = new Person(), \n p2 = new Person(); \np1.sayName(); // Jack \np2.sayName(); // Jack \nconsole.log(p1.name === p2.name); // false \nconsole.log(p1.sayName === p2.sayName); // false \nconsole.log(p1.nicknames === p2.nicknames); // false \nconsole.log(p1.sex, p1.age) // 女 21\n```\n## 原型成员\n将在类块中定义的方法作为原型方法（在所有实例中共享）\n```js\nclass Person { \n    constructor() { \n        // 添加到 this 的所有内容都会存在于不同的实例上\n        this.locate = () => console.log('instance'); \n    } \n    // 在类块中定义的所有内容都会定义在类的原型上\n    locate() { \n        console.log('prototype'); \n    } \n} \nlet p = new Person(); \np.locate(); // instance \nPerson.prototype.locate(); // prototype \n```\n类定义也支持获取和设置访问器。语法与行为跟普通对象一样：\n```js\nclass Person { \n\tsex = '女'\n\tage = 21\n\tconstructor() { \n\t\tthis.sayName = () => console.log(this.name); \n\t\tthis.nicknames = ['Jake', 'J-Dog'] \n\t}\n    set name(newName) { \n        this.name_ = newName; \n    } \n    get name() { \n        return this.name_; \n    } \n} \nlet p = new Person(); \np.name = 'cosine'; \nconsole.log(p.name); // cosine \n```\n\n## 静态类方法\n静态类成员在类定义中使用 `static` 关键字作为前缀。在静态成员中，`this` 引用类自身。可以通过类名.方法名直接访问\n## 非函数原型和类成员\n虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加：\n```js\n// 在类上定义数据成员\nPerson.greeting = 'My name is'; \n// 在原型上定义数据成员\nPerson.prototype.name = 'Jake';\n```\n- 但是不建议这么做，在原型和类上添加可变数据成员是一种反模式。一般来说，对象实例应该独自拥有通过 `this` 引用的数据\n\n## 迭代器与生成器方法\n类定义语法支持在原型和类本身上定义生成器方法：\n```js\nclass Person { \n\t// 在原型上定义生成器方法\n\t*createNicknameIterator() { \n\t\tyield 'cosine1'; \n\t\tyield 'cosine2'; \n\t\tyield 'cosine3'; \n\t} \n\t// 在类上定义生成器方法\n\tstatic *createJobIterator() { \n\t\tyield 'bytedance'; \n\t\tyield 'mydream'; \n\t\tyield 'bytedance mydream!'; \n\t} \n} \nlet jobIter = Person.createJobIterator(); \nconsole.log(jobIter.next().value); // bytedance \nconsole.log(jobIter.next().value); // mydream \nconsole.log(jobIter.next().value); // bytedance mydream!\nlet p = new Person(); \nlet nicknameIter = p.createNicknameIterator(); \nconsole.log(nicknameIter.next().value); // cosine1 \nconsole.log(nicknameIter.next().value); // cosine2 \nconsole.log(nicknameIter.next().value); // cosine3\n```\n因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象\n```js\nclass People { \n    constructor() { \n        this.nicknames = ['cosine1', 'cosine2', 'cosine3']; \n    } \n    *[Symbol.iterator]() { \n        yield *this.nicknames.entries(); \n    } \n} \nlet workers = new People(); \nfor (let [idx, nickname] of workers) { \n    console.log(idx, nickname); \n}\n// 0 cosine1\n// 1 cosine2\n// 2 cosine3\n```\n# 继承\nES 6最出色的一点就是原生支持了类继承机制，是之前原型链的一个语法糖\n## 继承基础\nES6 类支持**单继承**，使用 `extends` 关键字，可以继承一个类，也可以继承普通的构造函数（保持向后兼容）\n- 派生类可以通过原型链访问到类和原型上定义的方法\n- `this` 的值会反映调用相应方法的实例或者类。\n- `extends` 关键字也可以在类表达式中使用\n\n##  构造函数、HomeObject 和 super()\n- 派生类的方法可以通过 `super` 关键字引用它们的原型\n\t- 只能在派生类中使用\n\t- 仅限于**类构造函数**、**实例方法**和**静态方法**内部\n\t- 在类构造函数中使用 `super` 可以调用父类构造函数。\n-  `[[HomeObject]]`\n\t- ES6 给**类构造函数**和**静态方法**添加了内部特性 `[[HomeObject]]`\n\t- 指向**定义该方法的对象**的指针，这个指针是自动赋值的，而且只能在 JavaScript 引擎内部访问。\n- `super` 始终会定义为 `[[HomeObject]]` 的原型。\n\n在使用 super 时要注意几个问题\n- `super` 只能在 **派生类的构造函数和静态方法**中使用\n- 不能单独引用 `super` 关键字，要么用它调用构造函数，要么用它引用静态方法\n- 调用 `super()` 会调用父类构造函数，并将**返回的实例**赋值给 `this`，所以不能在调用 `super()` 之前引用 `this`\n- 需要给父类构造函数传参，则需要手动将其传入`super`\n- 如果**没有定义类构造函数**，在实例化派生类时会调用 `super()`，而且会**传入所有传给派生类的参数**\n- 如果在派生类中显式定义了构造函数，则要么必须在其中调用 `super()`，要么必须显式的返回一个对象。\n## 抽象基类\n抽象基类也就是一种**可供其他类继承**，但**本身不会被实例化**的类。在其他语言中也有这种概念。虽然 ECMAScript 没有专门支持这种类的语法 ，但通过 `new.target` 也很容易实现\n- `new.target` 保存通过 `new` 关键字调用的类或函数\n- 通过在实例化时检测 `new.target` 是不是抽象基类，可以**阻止对抽象基类的实例化**\n\n```js\n// 抽象基类 \nclass Vehicle { \n    constructor() { \n        console.log(new.target); \n        if (new.target === Vehicle) { \n            throw new Error('Vehicle cannot be directly instantiated'); \n        } \n    } \n} \n// 派生类\nclass Bus extends Vehicle {} \nnew Bus(); // class Bus {} \nnew Vehicle(); // class Vehicle {} \n// Error: Vehicle cannot be directly instantiated\n```\n通过在抽象基类的构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用原型类的构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法是否定义\n```js\n// 抽象基类\nclass Vehicle { \n    constructor() { \n        if (new.target === Vehicle) \n            throw new Error('Vehicle cannot be directly instantiated'); \n        if (!this.foo)\n            throw new Error('Inheriting class must define foo()'); \n        console.log('success!'); \n    } \n} \n// 派生类\nclass Bus extends Vehicle { foo() {} } \n// 派生类\nclass Van extends Vehicle {} \nnew Bus(); // success! \nnew Van(); // Error: Inheriting class must define foo() \n```\n## 继承内置类型\nES6 类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型，如下，向Array添加了一个洗牌算法的方法\n```js\nclass SuperArray extends Array { \n    shuffle() { \n        // 加一个洗牌算法\n        for (let i = this.length - 1; i > 0; i--) { \n            const j = Math.floor(Math.random() * (i + 1)); //生成[0, i+1)的随机数\n            [this[i], this[j]] = [this[j], this[i]];    // 交换两张牌\n        } \n    } \n} \nlet a = new SuperArray(1, 2, 3, 4, 5); \nconsole.log(a instanceof Array); // true \nconsole.log(a instanceof SuperArray); // true\nconsole.log(a); // [1, 2, 3, 4, 5] \na.shuffle(); \nconsole.log(a); // 随机的新数组\na.shuffle(); \nconsole.log(a); // 随机的新数组\n```\n有些内置类型的方法会返回新实例。默认情况下，返回实例的类型与原始实例的类型是一致的，但如果想覆盖这个默认行为，则**可以覆盖** `Symbol.species` 访问器，这个访问器**决定在创建返回的实例时使用的类**\n```js\nclass SuperArray extends Array { \n    static get [Symbol.species]() { \n        return Array; \n    } \n} \nlet a1 = new SuperArray(1, 2, 3, 4, 5); \nlet a2 = a1.filter(x => !!(x%2)) \nconsole.log(a1); // [1, 2, 3, 4, 5] \nconsole.log(a2); // [1, 3, 5] \nconsole.log(a1 instanceof SuperArray, a1 instanceof Array); // true true\nconsole.log(a2 instanceof SuperArray, a2 instanceof Array); // false true\n```\n\n## 类混入（多继承的模拟实现）\n将不同类的行为集中到一个类是一种常见的 JavaScript 模式。虽然 ES6 **没有显式支持多类继承**，但通过现有特性可以轻松地模拟这种行为。\n\n首先要注意以下两点：\n- 如果只是需要**混入多个对象的属性**，那么使用 `Object.assign()` 就可以了。\n\t- `Object.assign()` 方法是为了专门为了混入对象行为而设计的。只有在需要**混入类的行为**时才有必要**自己实现混入表达式**。\n- 很多 JavaScript 框架（特别是 React）已经**抛弃混入模式**，转向了组合模式\n\t- 组合即是把方法提取到独立的类和辅助对象中，然后把它们组合起来，不使用继承。\n\t- 众所周知的软件设计原则：**“组合胜过继承（composition over inheritance）。”**\n\n`extends` 关键字后面可以是一个 **JavaScript 表达式**。任何可以解析为一个类或一个构造函数的表达式都是**有效**的。这个表达式会在**求值类定义时被求值**，这就是类混入的原理\n\n如 Person 类需要组合类A、B、C，则需要某种机制实现 B 继承 A，C 继承 B，而 Person再继承C从而实现将A、B、C组合至这个超类中：\n```js\nclass Vehicle {} \nlet AMixin = (Superclass) => class extends Superclass { \n    afunc() { console.log('A Mixin'); } \n}; \nlet BMixin = (Superclass) => class extends Superclass { \n    bfunc() { console.log('B Mixin'); } \n}; \nlet CMixin = (Superclass) => class extends Superclass { \n    cfunc() { console.log('C Mixin'); } \n}; \nfunction mixin(BaseClass, ...Mixins) { \n    return Mixins.reduce((accumulator, current) => current(accumulator), BaseClass); \n} \nclass Bus extends mixin(Vehicle, AMixin, BMixin, CMixin) {} \nlet b = new Bus(); \nb.afunc(); // A Mixin \nb.bfunc(); // B Mixin \nb.cfunc(); // C Mixin \n```\n# 小结\n- ECMAScript 6 新增的类很大程度上是基于既有原型机制的语法糖\n- 类的语法让开发者可以优雅地定义向后兼容的类\n- 类既可以继承内置类型，也可以继承自定义类型\n- 类有效地跨越了**对象实例**、**对象原型**和**对象类**之间的鸿沟\n- 通过 **类混入** 可以巧妙地实现类似多继承的效果，但不建议这么做，因为“组合胜过继承”\n\n","sources":["xlog"],"attributes":[{"value":"shen-ru-JavaScript-xue-xi-zhi-lu--er-JavaScript-zhong-de-lei-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/shen-ru-JavaScript-xue-xi-zhi-lu--er-JavaScript-zhong-de-lei-md"],"date_published":"2022-03-17T23:50:52.000Z"}}}