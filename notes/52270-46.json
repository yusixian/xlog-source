{"characterId":52270,"noteId":46,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreic2rjrtkgeugwmj3vj2ymyy3hbpu665x2gyboaiyoklyfetpjjqry","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:39:04.000Z","updatedAt":"2023-04-05T11:29:19.000Z","deletedAt":null,"publishedAt":"2022-01-21T14:30:17.000Z","transactionHash":"0xdc576b85b753d220cd2851aa2bc5e951b6f739ada0a82dfd613ec82afbd0296e","blockNumber":30317649,"logIndex":12,"updatedTransactionHash":"0xa77957bd98a880860cfd3a54080e5d7010f4cf06752163897c84629d21c8c7a4","updatedBlockNumber":30335064,"updatedLogIndex":0,"metadata":{"uri":"ipfs://bafkreic2rjrtkgeugwmj3vj2ymyy3hbpu665x2gyboaiyoklyfetpjjqry","type":"NOTE","content":{"tags":["post","前端","响应式","React","Hook","青训营"],"type":"note","title":"青训营 |「响应式系统与 React」","content":"---\ntitle: 青训营 |「响应式系统与 React」\nlink: note/front-end/bytedance-note/responsive-system-and-react\ncatalog: true\ndate: 2022-01-21 14:30:17\nsubtitle: 本节课大致介绍了响应式编程、React及其原理，介绍了组件化、一些应用级框架\nlang: cn\ntags:\n- 前端\n- 响应式\n- React\n- Hook\ncategories:\n- [笔记, 青训营笔记]\n---\n## React的历史与应用\n\n**应用**\n\n- 前端应用开发，如 Facebook，Instagram，Netflix网页版。\n- 移动原生应用开发，如Instagram，Discord，Oculus。\n- 结合Electron，进行桌面应用开发。\n\n**历史**\n\n- 2010年 Facebook 在其php生态中，引入了xhp框架，首次引入了组合式组件的思想，启发了后来的React的设计。\n- 2011年Jordan Walke创造了FaxJS，也就是后来的React原型:\n  - 既可以在客户端渲染也可以在服务端渲染\n  - 响应式，当状态变更时，UI会自动更新。\n  - 性能好，快速渲染\n  - 高度封装组件，函数式声明，\n- 2013年React 正式开源，在2013 JSConf 上 Jordan Walke介绍了这款全新的框架：React\n- 2014年 - 今天 生态大爆发，各种围绕React的新工具/新框架开始涌现\n\n## React设计思路\n\n### UI编程痛点\n\n1. 当状态更新时，UI不会自动更新，需要**手动地调用DOM**进行更新。\n2. 欠缺基本的代码层面的**封装**和**隔离**，代码层面没有**组件化**。\n3. UI之间的数据依赖关系，需要手动维护，如果依赖链路长．则会遇到“Callback Hell”（回调地狱）。\n\n### 响应式与转换式\n\n转换式系统：给定**输入**求解**输出**，如编译器、数值计算\n\n响应式系统：监听事件，消息驱动，如监控系统、UI界面\n\n事件 -> 执行既定的回调 ->  状态变更 -> UI更新\n\n### 响应式编程和组件化\n\n那么我们就希望解决以上痛点：\n\n-  状态更新，UI自动更新。\n- 前端代码组件化,可复用，可封装。\n- 状态之间的互相依赖关系，只需声明即可。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0fb3eaa27394eb4a07ec92c11e62d3b~tplv-k3u1fbpfcp-watermark.image?)\n\n**组件化**\n\n1. 组件一个是 原子组件/或组件的组合\n2. 组件内部拥有状态，外部不可见\n3. 父组件可将状态传入组件内部，来控制子组件的运转。\n\n### 状态归属问题\n\n**当前价格** 属于Root结点！因为要向下传递，这其实不合理，在下面的状态管理库里会讲到这个的解决方法。\n\n状态应该归属于两个节点（或多个）向上寻找到的**最近共同祖先**。\n\n思考：\n\n1. React是单向数据流,还是双向数据流?\n\n答：单向的，永远是只有父组件给子组件传东西，但这并不代表子组件不能改变父组件的状态。\n\n2. 如何解决状态不合理上升的问题?\n\n答：通过状态管理库，接下来也会讲到。\n\n3. 组件的状态改变后，如何更新DOM?\n\n答：讲解React实现中会提到。\n\n组件设计：\n\n- 组件声明了状态和UI的映射\n- 组件有Props（外部）/State（内部）两种属性\n  - Props接受父组件传入的状态\n  - State是内部的属性。\n- 可被其他组件组成\n\n> ps：学过小程序的同学应该知道，小程序中的属性的双向绑定实际上应该也有用到了这个思想。\n\n### 生命周期\n\n挂载 -> 状态更新 -> 卸载\n\n## React（hooks）的写法\n\n关于React Hook可以参看官方文档，以下内容大部分摘自：[Hook 简介 – React (reactjs.org)](https://zh-hans.reactjs.org/docs/hooks-intro.html)\n\n> *Hook* 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。\n\n###  State Hook\n\n```react\nimport React, {useState} from 'react';\nfunction Example() {\n\t// 声明一个叫 “count” 的 state 变量。\n\tconst [count, setCount] = useState(0);\n    return (\n        <div>\n       \t\t<p>You clicked {count} times</p>\n\t\t\t<button onClick={() => setCount(count + 1)}>\n        \t\tClick me\n            </button>\n        </div>\n    );\n}\n```\n\n上面这段函数用来显示一个计数器，当点击按钮时，计数器的值就会自动增加\n\n> 在这里，`useState` 就是一个 *Hook* 。通过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这个 state。`useState` 会返回一对值：**当前状态**和**其更新函数**，你可以在事件处理函数中或其他一些地方调用这个函数。\n\n> `useState` 唯一的参数就是初始 state。在上面的例子中，我们的计数器是从零开始的，所以初始 state 就是 `0`。值得注意的是，不同于 `this.state`，这里的 state 不一定要是一个对象 —— 如果你有需要，它也可以是。这个初始 state 参数只有在第一次渲染时会被用到。\n\n> Hook 是一些可以让你在函数组件里 **“钩入”** React state 及生命周期等特性的函数。\n\n可以在一个组件中多次使用 State Hook:\n\n```react\nfunction ExampleWithManyStates() {\n  // 声明多个 state 变量！\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState('banana');\n  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n  // ...\n}\n```\n\n###  Effect Hook\n\n**函数副作用**是指当调用函数时，除了**返回值**之外，还会**对主调用函数产生其他附加的影响**。例如修改全局变量（函数外的变量）或修改参数。纯函数就是指没有函数副作用的函数，这在js那一节里都有讲过。\n\n> 例如，下面这个组件在 React 更新 DOM 后会设置一个页面标题：\n\n```react\nimport React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // 相当于 componentDidMount 和 componentDidUpdate:\n  useEffect(() => {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\n> 当你调用 `useEffect` 时，就是在告诉 React 在 **完成对 DOM 的更改后运行你的“副作用”函数** 。由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state。\n\n### Hook的使用法则\n\nHook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：\n\n- 只能在**函数最外层**调用 Hook。**不要**在**循环、条件判断或者子函数**中调用。\n- 只能在 **React 的函数组件**中调用 Hook。**不要**在**其他 JavaScript 函数**中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中）\n\n> 同时，我们提供了 [linter 插件](https://www.npmjs.com/package/eslint-plugin-react-hooks)来自动执行这些规则。这些规则乍看起来会有一些限制和令人困惑，但是要让 Hook 正常工作，它们至关重要。\n\n以上是React官方文档的说法\n\n## React的实现\n\n三个问题：\n\n1. [JSX](https://zh-hans.reactjs.org/docs/introducing-jsx.html#gatsby-focus-wrapper) 是不符合JS标准的语法\n2. 返回的JSX改变时，如何更新DOM?\n3. State/Props更新时， 要重新触发render函数\n\n### Problem1\n\n解决办法也很简单，就是将JSX转换为符合JS语法的\n\n```react\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n// 等价于 \nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\n\n### Problem2\n\n返回的JSX本身是类似DOM的一种东西，但不是DOM，DOM操作本身是十分耗费性能的。所以需要将返回的JSX与原来的DOM结构计算一个diff（差别）？但是这个diff算法本身不能太耗时，尽可能小，尽可能短。\n\n#### Virtual DOM （虚拟DOM）\n\n[Virtual DOM](https://zh-hans.reactjs.org/docs/faq-internals.html#gatsby-focus-wrapper) 是一种用于与真实DOM同步，而在JS内存中维护的一个**对象**，它具有和DOM类似的树状结构并可以和DOM建立一一对应的关系。\n\n>这种方式赋予了 React 声明式的 API：您告诉 React 希望让 UI 是什么状态，React 就确保 DOM 匹配该状态。这使您可以从属性操作、事件处理和手动 DOM 更新这些在构建应用程序时必要的操作中解放出来。\n\n状态更新 -> diff 比对Virtual DOM和真实DOM - > Re-render Virtual DOM 改变我们的真实DOM\n\n#### How to Diff??\n\n更新次数少 <- 权衡 -> 计算速度快\n\n完美的最小Diff算法，需要 O(n^3) 的复杂度\n\n而牺牲理论最小Diff，换取时间，得到了 O(n)  复杂度的算法，他是局部最优的。Heuristic O(n) Algorithm （启发式算法）\n\n- 不同类型的元素 -> 替换\n\n- 同类型的DOM元素 -> 更新\n\n- 同类型的组件元素 -> 递归\n\n这个算法只遍历了一遍，就可以算出diff。\n\n而这也是React一个弊病，一个组件发生改变时，其子组件全部会重新渲染。要解决这个问题，就要看接下来的React的状态管理库。\n\n## React的状态管理库\n\n### 核心思想\n\n**将状态抽离到UI外部进行统一管理**，但是这是会降低组件的复用性，所以这一般出现在业务代码中。以下几种框架，用哪个都行\n\n- [Redux中文文档](https://www.redux.org.cn/)\n- [XState - JavaScript State Machines and Statecharts](https://xstate.js.org/)\n- [MobX 介绍 · MobX 中文文档](https://cn.mobx.js.org/)\n- [Recoil 中文文档 | Recoil 中文网 (recoiljs.cn)](https://www.recoiljs.cn/)\n\n### 状态机\n\n收到外部事件后根据当前状态，迁移到下一个状态。\n\n哪些状态适合放到状态管理库？\n\n- 可能会被很多层级的组件用到的状态\n\n## 应用级框架科普\n\nReact本身是没有提供足够多的工程能力，如路由、页面配置等等。\n\n- [Next.js - React 应用开发框架](https://www.nextjs.cn/) 硅谷明星创业公司Vercel的 React开发框架,稳定,开发体验好，支持Unbundled Dev,sWC等,其同样有Serverless一键部署平台帮助开发者快速完成部署。口号是\"Let's Make Web Faster\"\n-  [Modern.js - 现代 Web 工程体系 (modernjs.dev)](https://modernjs.dev/) 字节跳动Web Infra团队研发的全栈开发框架,内瓷了很多开箱即用的能力与最佳实践，可以减少很多调研选择工具的时间。\n- [Get Started with Blitz (blitzjs.com)](https://blitzjs.com/docs/get-started)无API思想的全栈开发框架,开发过程中无需写API 调用与CRUD逻辑,适合前后端紧密小团队项目。\n\n## 课后作业\n\n1. React组件的render函数，在哪些时机下，会被重新执行?\n2. React这种函数式编程,和vue这种基于模版语法的前端框架，各有什么优点和缺点?\n3. React推荐使用组合来进行组件的复用,而不是继承，背后有什么样的考虑?\n\n个人理解\n\n## 总结感想\n\n本节课大致介绍了React及其原理，介绍了组件化、一些应用级框架\n\n> 本文引用的内容大部分来自牛岱老师的课，以及React官方文档\n\n","sources":["xlog"],"summary":"React的历史与应用 应用\n\n前端应用开发，如 Facebook，Instagram，Netflix网页版。 移动原生应用开发，如Instagram，Discord，Oculus。 结合Electron，进行桌面应用开发。\n\n历史\n\n2010年 Facebook…","attributes":[{"value":"reactive-systems-and-reactmd","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/reactive-systems-and-reactmd"],"date_published":"2022-01-21T14:30:17.000Z"}}}