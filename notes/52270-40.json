{"characterId":52270,"noteId":40,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreibz5k2ei74s3czpr4n36r42d5abwoerjg5gn5gaygsm7vdjavye4y","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:39:04.000Z","updatedAt":"2023-04-05T07:42:31.000Z","deletedAt":null,"publishedAt":"2022-05-12T20:44:01.000Z","transactionHash":"0xdc576b85b753d220cd2851aa2bc5e951b6f739ada0a82dfd613ec82afbd0296e","blockNumber":30317649,"logIndex":6,"updatedTransactionHash":"0xae4247db22f01255a6562654b88ffc510ea24ef2a6bf3172ab69d09c5acdad1f","updatedBlockNumber":30321456,"updatedLogIndex":0,"metadata":{"uri":"ipfs://bafkreibz5k2ei74s3czpr4n36r42d5abwoerjg5gn5gaygsm7vdjavye4y","type":"NOTE","content":{"tags":["post","后端","Go","青训营"],"type":"note","title":"Go语言初上手（三）编码规范与性能优化 | 青训营","content":"---\ntitle: Go语言初上手（三）编码规范与性能优化 | 青训营\nlink: back-end/go_learning_3\ncatalog: true\nlang: cn\ndate: 2022-05-12 20:44:01\nsubtitle: Go语言工程实践\nquiz: true\ntags:\n- 后端\n- Go\ncategories:\n- [笔记, 青训营笔记]\n---\n本节课讲了如何写出更简洁清晰的代码，每种语言都有自己的特性，也有自己独特的代码规范，对于 Go 来说，有哪些性能优化的手段、趁手的工具，也都进行了介绍。\n\n高质量代码需要具备正确可靠、简洁清晰的特性\n- 正确性：各种边界条件是否考虑完备、错误的调用能否被处理\n- 可靠性：异常情况或错误处理明确，依赖的服务异常能够及时处理\n- 简洁：逻辑是否简单、后续新增功能是否能够快速支持\n- 清晰可读：其他人阅读理解代码时是否能清楚明白、重构时是否不会担心出现无法预料的情况\n而这就需要编码规范。\n\n# 编码规范\n\n## 格式化工具\n\n提到编码规范就不得不提到代码格式化工具，推荐使用Go官方提供的格式化工具 `gofmt`，Goland中内置了其功能，常见的IDE也都能方便的配置\n\n-   另一个工具是 `goimports`，相当于 `gofmt` 加上依赖包的管理，自动增删依赖的包。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07f5cc789bcc4526a35da211cf843a89~tplv-k3u1fbpfcp-zoom-1.image)\n\n> js中也有类似的格式化工具 `Prettier`，可以配合ESLint进行代码格式化。 \n\n## 注释规范\n\n好的注释需要\n\n-   解释代码作用\n\n-   解释复杂、不明显的逻辑\n\n-   解释代码实现的原因（这些因素脱离上下文后很难理解）\n\n-   解释代码什么情况会出错（解释一些限制条件）\n\n-   解释公共符号的注释（包中声明的每个公共的符号:变量、常量、函数以及结构等）\n\n    -   例外：不需要注释实现接口的方法\n\n> Google Style 指南中有两条规则：\n>\n> -   任何既不明显也不简短的 **公共功能** 必须予以注释。\n> -   无论长度或复杂程度如何，对 **库** 中的任何函数都必须进行注释\n\n而需要避免的情况如下:\n\n-   对可见名知义的函数进行啰嗦的注释\n-   对显而易见的流程进行直接翻译\n\n总而言之，**代码是最好的注释**\n\n-   注释应该提供 **代码未表达出的上下文信息**\n-   简洁清晰的代码**对流程注释没有要求**，但是对于为什么这么做，代码的相关背景等可以通过注释补充，提供有效信息。\n\n## 命名规范\n\n### 变量名\n\n-   简洁胜于冗长\n\n    -   `i` 和 `index` 的作用范围，不需要 `index` 的额外冗长\n\n```go\n// Bad\nfor index := 0; index < len(s) ; index++ {\n    // do something\n}\n// Good\nfor i := 0; i < len(s); i++ {\n    // do something\n}\n```\n\n-   **缩略词全大写**，但当其 **位于变量开头且不需要导出** 时，**使用全小写**\n\n    -   如使用 `ServeHTTP` 而不是 `ServeHttp`\n    -   使用 `XMLHTTPRequest` 或 `xmlHTTPRequest`\n\n-   变量名距离其被使用的地方越远，则越需要携带越多的上下文信息。\n\n    -   如全局变量，在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义\n\n```go\n// Bad\nfunc ( c *Client ) send( req *Request, t time.Time )\n\n// Good\nfunc ( c *Client ) send( req *Request, deadline time.Time )\n```\n\n### 函数命名\n\n-   函数名 **不携带包名的上下文信息**，因为包名和函数名总是成对出现的\n\n    -   如http包中创建服务的函数， `Serve` > `ServeHTTP`，因为调用时总是`http.Serve`\n\n-   函数名 **尽量简短**\n\n-   当名为 `foo` 的包某个函数返回类型 `T` 时(`T`并不是 `Foo` )，可以在函数名中加入返回的类型信息\n\n    -   返回`Foo`类型时，可以省略而不导致歧义\n\n### 包名\n\n-   只由**小写字母**组成。不包含大写字母和下划线等字符\n-   简短并包含一定的上下文信息。例如`schema`、 `task`等\n-   不要与标准库同名。例如不要使用 `sync` 或者 `strings` 以下规则尽量满足，以标准库包名为例：\n-   不使用**常用变量名**作为包名。例如使用 `bufio` 而不是 `buf`\n-   使用单数而不是复数。例如使用 `encoding` 而不是 `encodings``\n-   谨慎地使用缩写。例如使用 `fmt` 在不破坏上下文的情况下比 `format` 更加简短\n\n总的来说，好的命名降低阅读理解代码的成本，可以能让人把关注点留在主流程上，清晰地理解程序的功能，而不是频繁切换到分支细节，并且必须解释它。\n\n## 控制流程\n\n-   避免嵌套，保持正常流程清晰可读\n\n    -   优先处理错误情况/特殊情况，尽早返回或继续循环来减少嵌套\n\n```go\n // Bad\n if foo {\n    return x\n } else {\n    return nil\n }\n ​\n // Good\n if foo {\n    return x\n }\n return nil\n```\n\n-   尽量保持正常代码路径为最小缩进，减少嵌套\n\n```go\n // Bad\n func OneFunc() error {\n    err := doSomething()\n    if err == nil {\n       err := doAnotherThing()\n       if err == nil {\n          return nil // normal case\n       }\n       return err\n    }\n    return err\n }\n ​\n // Good\n func OneFunc() error {\n    if err := doSomething(); err != nil {\n       return err\n    }\n    if err := doSomething(); err != nil {\n       return err\n    }\n    return nil // normal case\n }\n```\n\n总而言之，程序中流程这一块处理逻辑尽量走直线，避免复杂的嵌套分支，使正常流程代码沿着屏幕向下移动。提升代码可维护性和可读性，因为故障问题大多出现在复杂的条件语句和循环语句中\n\n## 错误处理\n\n-   简单错误\n\n    -   简单的错误指 **仅出现一次** 的错误，且在其他地方 **不需要捕获** 该错误\n    -   优先使用 `errors.New` 来创建匿名变量来**直接表示**简单错误\n    -   如果有格式化的需求，使用 `fmt.Errorf`\n\n```go\n func defaultCheckRedirect(req *Request, via []*Request) error {\n    if len(via) >= 10 {\n       return errors.New(\"stopped after 10 redirects\")\n    }\n    return nil\n }\n```\n\n-   复杂错误：使用错误的 `Wrap` 和 `Unwrap`\n\n    -   错误的 `Wrap` 实际上是提供了一个 `error` 嵌套另一个 `error` 的能力，从而生成一个 `error` 的跟踪链\n    -   在 `fmt.Errorf` 中使用 `%w` 关键字来将一个错误关联至错误链中\n    -   使用 `errors.Is` 判定错误是否为某特定错误，可判定错误链上的所有错误（[go/wrap_test.go · golang/go](https://github.com/golang/go/blob/master/src/errors/wrap_test.go#L255)）\n    -   使用 `errors.As` 在错误链上获取特定种类的错误，并将错误赋值给定义好的变量。（[go/wrap_test.go · golang/go](https://github.com/golang/go/blob/master/src/errors/wrap_test.go#L255)）\n\n在Go中，比错误更严重的就是 `panic`，它的出现表示**程序无法正常工作**了\n\n-   不建议在业务代码中使用panic\n\n    -   `panic` 发生后，会向上传播至调用栈顶\n    -   调用函数全都不包含 `recover` 会造成**整个程序崩溃**。\n    -   若问题可以被屏蔽或解决，建议使用 `error` 代替 `panic`\n\n-   当程序**启动阶段**发生**不可逆转**的错误时，可以在 `init` 或 `main` 函数中使用 `panic`（[sarama/main.go · Shopify/sarama](https://github.com/Shopify/sarama/blob/main/examples/consumergroup/main.go#L94)）\n\n有`painc`，自然就会提到 `recover`，如果是引入其它库的`bug`导致`panic`，影响到自身的逻辑时，就需要recover\n\n-   `recover` 只能在被 `defer`的函数中使用，嵌套无法生效，只在当前goroutine 生效（[github.com/golang/go/b…](https://github.com/golang/go/blob/master/src/fmt/scan.go#L247)）\n-   defer的语句是**后进先出**的。\n-   如果需要更多的上下文信息，可以 recover 后在 log 中记录当前的调用栈（[github.com/golang/webs…](https://github.com/golang/website/blob/master/internal/gitfs/fs.go#L228)）\n\n### 小结\n\n-   `error` 要尽可能提供简明的上下文信息链，方便定位问题\n-   `panic` 用于真正异常的情况\n-   `recover` 生效范围，在当前 goroutine 的被 `defer` 的函数中生效\n\n# 性能优化建议\n\n-   **前提**：满足正确可靠、简洁清晰等质量因素的前提下，尽可能提高程序的效率\n-   **折衷**：有时候时间效率和空间效率可能对立，需要分析重要程度进行适当折衷。\n\n针对 Go 语言特性，课上介绍了很多 Go 相关的性能优化建议：\n\n## 预分配内存\n\n使用make() 初始化切片时尽可能提供容量信息\n\n```go\n func PreAlloc(size int) {\n    data := make([]int, 0, size)\n    for k := 0; k < size; k++ {\n       data = append(data, k)\n    }\n }\n```\n\n这是由于切片本质是一个数组片段的描述，包括数组指针、片段的长度、片段的容量(不改变内存分配情况下的最大长度)，\n\n-   切片操作并不复制切片指向的元素\n-   创建一个新的切片会复用原来切片的底层数组 所以预先设置容量的值能够避免额外的内存分配，获得更好的性能\n\n## 字符串处理优化\n\n使用 `strings.Builder` 常见的字符串拼接方式\n\n-   `+` 进行连接 （最慢）\n\n-   `strings.Builder` （最快）\n\n-   `bytes.Buffer` 原理：字符串在 Go 语言中是**不可变类型**，占用内存大小是固定的\n\n-   使用 + 拼接时，生成一个新的字符串，开辟一段新空间，新空间的大小是原来两个字符串的大小之和\n\n-   `strings.Builder`，`bytes.Buffer` 的内存是以**倍数**申请的\n\n-   `strings.Builder` 和 `bytes.Buffer` 底层都是 `[]byte` 数组\n\n    -   `bytes.Buffer` 转化为字符串时重新申请了一块空间存放生成的字符串变量\n    -   `strings.Builder` 直接将底层的 `[]byte` 转换成了字符串类型返回\n\n```go\n func PreStrBuilder(n int, str string) string {\n    var builder strings.Builder\n    builder.Grow(n * len(str))\n    for i := 0; i < n; i++ {\n       builder.WriteString(str)\n    }\n    return builder.String()\n }\n```\n\n## 空结构体\n\n-   空结构体 `struct` 实例**不占据任何的内存空间**\n\n-   可作为各种场景下的占位符使用\n\n    -   节省内存空间\n    -   空结构体本身具备很强的语义，即这里不需要任何值，仅作为占位符\n\n-   如实现Set时，利用map的键，而将值设为空结构体。([golang-set/threadunsafe...](https://github.com/deckarep/golang-set/blob/main/threadunsafe.go))\n\n# 相关链接\n\n-   [《golang pprof 实战》](https://blog.wolfogre.com/posts/go-ppof-practice/)代码实验用例： [github.com/wolfogre/go…](https://github.com/wolfogre/go-pprof-practice)\n-   尝试使用 test 命令，编写并运行简单测试 [go.dev/doc/tutoria…](https://go.dev/doc/tutorial/add-a-test)\n-   尝试使用 -bench 参数，对编写的函数进行性能测试，[pkg.go.dev/testing#hdr…](https://pkg.go.dev/testing#hdr-Benchmarks)\n-   Go 代码 Review 建议 [github.com/golang/go/w…](https://github.com/golang/go/wiki/CodeReviewComments)\n-   Uber 的 Go 编码规范，[github.com/uber-go/gui…](https://github.com/uber-go/guide)\n\n# 总结及心得\n\n本节课介绍了Go乃至其他语言中常见的代码规范，提出了Go语言中相关的性能优化建议。后续还进行了性能优化的实战练习，使用pprof工具进行。\n\n> 笔记内容来源于第三届青训营张雷老师的课程《高质量编程与性能调优实战》\\\n> 课程资料：[【Go 语言原理与实践学习资料（上）】第三届字节跳动青训营-后端专场](https://juejin.cn/post/7093721879462019102/#heading-16)","sources":["xlog"],"summary":"本节课讲了如何写出更简洁清晰的代码，每种语言都有自己的特性，也有自己独特的代码规范，对于 Go 来说，有哪些性能优化的手段、趁手的工具，也都进行了介绍。 高质量代码需要具备正确可靠、简洁清晰的特性\n\n正确性：各种边界条件是否考虑完备、错误的调用能否被处理 可靠性…","attributes":[{"value":"go_learning_3md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/go_learning_3md"],"date_published":"2022-05-12T20:44:01.000Z"}}}