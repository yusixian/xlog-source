{"characterId":52270,"noteId":117,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreianqgzk54fkm3sd3hrlkuxulv4lrjc4mrsyijujalvoynadsv3aqy","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-03-15T00:38:18.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":20,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":20,"metadata":{"uri":"ipfs://bafkreianqgzk54fkm3sd3hrlkuxulv4lrjc4mrsyijujalvoynadsv3aqy","type":"NOTE","content":{"tags":["post","c++","数据结构","二叉树"],"type":"note","title":"数据结构学习笔记＜4＞ 二叉树","content":"---\ntitle: 数据结构学习笔记＜4＞ 二叉树\nlink: 数据结构学习笔记＜4＞ 二叉树\ncatalog: true\nlang: cn\ndate: 2020-03-15 00:38:18 \nsubtitle: MOOC浙江大学的数据结构慕课学习记录——二叉树\ntags:\n- c++\n- 数据结构\n- 二叉树\ncategories:\n- [笔记, 数据结构]\n---\n\n##  一、什么是树\n### 1.树的定义\n树（Tree）：n（n≥0）个结点构成的有限集合。\n当n=0时，称为**空树**；\n对于任一棵**非空树**（n>0）,它具备以下性质：\n\n 1. 树中有一个称为“**根（Root）**”的特殊结点，**用r表示**。\n 2. 其余结点可分为m（m>0）个**互不相交**的有限集T1，T2，……，Tm,其中每个集合本身又是一棵树，称为原来树的“**子树（SubTree）**”。\n 3. 子树是**不相交**的\n 4. 除了根结点外，**每个结点有且仅有一个父结点；**\n 5. 一个**N个结点**的树有**N-1条边**。\n\n### 2.树的一些基本术语\n **1. 结点的度（Degree）**： 结点拥有**子结点的数量**\n **2. 树的度**： **最大的结点的度**称为树的度\n **3. 叶结点（Leaf）**： **度为0的结点**\n **4. 父结点（Parent）**： **如果有上一个结点，则称这个上一结点是它的父结点，如果没有上一结点，则这个属性则无父结点。**\n **5. 子结点（Child）**： 若A结点是B结点的父结点，则称B结点是A结点的子结点；子节点也称**孩子结点**\n **6. 兄弟结点（Sibling）**： 具有**同一父结点**的各结点彼此是兄弟结点。\n **7. 路径和路径长度**： 从结点n1到nk的路径为一个节点序列n1，n2，……，nk，ni是ni+1的父结点。**路径所包含边的个数为路径的长度**\n **8. 祖先结点（Ancestor）**： 沿**树根到某一结点路径上**的所有节点都是这个结点的祖先结点\n **9. 子孙结点（Descendant）**： 某一结点的**子树中所有结点**是这个结点的子孙\n **10. 结点的层次（Level）**： 规定**根结点在1层**，其它任一结点的层数是其父结点的层数加1。\n **11. 树的深度（Depth）**： 树中所有结点的**最大层次**是这棵树的深度。\n **12. 森林**： m棵不相交的树的集合\n## 二、树的表示\n### 1.儿子-兄弟表示法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314233156300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314233357493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n## 三、二叉树\n### 1.定义\n**二叉树T:** 一个有穷的结点集合。\n这个结点**可以为空**\n若不为空，则它是由**根结点**和称为其**左子树TL**和**右子树TR**的两个不相交的二叉树组成\n二叉树具体五种基本形态 a空树 b只有一个结点 c有一个结点和左子树 d有一个结点和左子树 e有一个结点和左右子树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020031423393910.png)\n**PS：二叉树的子树有左右顺序之分**\n\n几种特殊二叉树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314234316257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n**二叉树的抽象数据类型定义**\n类型名称：二叉树\n数据对象集：一个有穷的结点集合。\n若不为空，则由根结点和其左、右二叉子树组成。\n操作集：BT∈BinTree，Item∈ElementType，重要操作有：\n\n 1. Boolean IsEmpty(BinTree BT);  //判别BT是否为空\n 2. void Traversal(BinTree BT);  //遍历，按某顺序访问某个结点；\n 3. BinTree CreatBinTree();\t //创建一个二叉树\n\n**常用的遍历方法有：**\n - void PreOrderTraversal(BinTree BT); //**先序**---根、左子树、右子树\n - void InOrderTraversal(BinTree BT);  //**中序**---左子树、根、右子树\n - void PostOrderTraversal(BinTree BT);  //**后序**---左子树、右子树、根\n - void LevelOrderTraversal(BinTree BT);  //**层次遍历**，从上到下、从左到右\n\n### 2.二叉树的几个重要性质\n - 一个二叉树**第i层的最大节点数**为 **2^i-1^**，i≥1。\n - **深度为k**的二叉树有**最大结点总数**为 **2^k^-1**，k≥1。\n - 对任何非空二叉树T，若n0表示叶结点的个数、n2是度为2的非叶结点个数，那么两者满足关系n0=n2+1。\n - 具有**n个结点的完全二叉树**的**深度k**必为**log~2~n+1**\n### 3.二叉树的存储结构\n#### 1、顺序存储结构\n**完全二叉树**：按从上至下、从左到右顺序存储**n**个结点的完全二叉树的**结点父子关系**\n - 非根结点（序号i > 1）的**父结点**的序号是 **[i / 2] ;**(向下取整)\n -  结点（序号为i）的**左孩子**的序号是 **2i**(2i ≤ n，否则没有左孩子)\n - 结点（序号为i）的**右孩子**的序号是 **2i+1**(2i + 1 ≤ n，否则没有右孩子)\n\n  **一般二叉树也可采用这种顺序存储结构，但是会造成空间浪费**\n  \n  **满二叉树**：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树，区别于完全二叉树![在这里插入图片描述](https://img-blog.csdnimg.cn/20201019091648890.png#pic_center)\n\n#### 2、链式存储\n##### (1)定义\n```cpp\ntypedef struct TreeNode *BinTree;\ntypedef BinTree Position;\nstruct TreeNode {\n\t\tElementType Data;\n\t\tBinTree Left;\n\t\tBinTree Right;\n}\n```\n##### (2)遍历（递归实现）\n\n###### 先序遍历：\n1.先访问根结点；\n2.先序遍历其左子树；\n3.先序遍历其右子树。\n\n```cpp\nvoid PreOrderTraversal(BinTree BT) {\n\tif(BT) {\n\t\tprintf(\"%d\", BT->Data);\n\t\tPreOrderTraversal( BT->Left);\n\t\tPreOrderTraversal( BT->Right);\n\t}\n}\n```\n\n###### 中序遍历：\n1.中序遍历其左子树\n2.访问根结点\n3.中序遍历其右子树。\n```cpp\nvoid InOrderTraversal(BinTree BT) {\n\tif(BT) {\n\t\tInOrderTraversal( BT->Left);\n\t\tprintf(\"%d\", BT->Data);\n\t\tInOrderTraversal( BT->Right);\n\t}\n}\n```\n###### 后序遍历：\n1.后序遍历其左子树\n2.后序遍历其右子树。\n3.访问根结点\n```cpp\nvoid PostOrderTraversal(BinTree BT) {\n\tif(BT) {\n\t\tPostOrderTraversal( BT->Left);\n\t\tPostOrderTraversal( BT->Right);\n\t\tprintf(\"%d\", BT->Data);\n\t}\n}\n```\n##### (2)遍历（非递归实现）\n基本思路：使用堆栈或队列\n###### 中序遍历非递归遍历算法\n - 遇到一个结点，就把它**压栈**，并去遍历它的**左子树**；\n - 当**左子树遍历结束**后，从栈顶弹出这个结点并**访问它**；\n - 然后按其右指针再去**中序遍历该结点的右子树**。\n\n```cpp\nvoid InOrderTraversal(BinTree BT) {\n\tBinTree T = BT;\n\tStack S = CreatStack(MaxSize);//创建并初始化堆栈S\n\twhile( T || !IsEmpty(S) ) {\n\t\twhile(T) {//一直向左并将沿途结点压入堆栈\n\t\t\tPush(S, T);\n\t\t\tT = T->Left;\n\t\t}\n\t\tif( !IsEmpty(S) ) {\n\t\t\tT = Pop(S);\t//结点弹出堆栈\n\t\t\tprintf(\"%5d\", T->Data);//访问结点\n\t\t\tT = T->Right;//转向右子树\n\t\t}\n\t}\n}\n```\n\n###### 层序遍历\n\n - 需要一个存储结构保存暂时不访问的结点（堆栈、队列）\n队列实现：遍历从根节点开始，首先**将根节点入队**，然后开始执行循环：**结点出队、访问该节点、其左右儿子入队**\n1.根结点入队；\n2.从队列中**取出**一个元素；\n3.**访问**该元素所指结点；\n4.若该元素所指结点的左、右孩子结点非空，将其**左、右孩子的指针顺序入队**。\n\n```cpp\nvoid LevelOrderTraversal(BinTree BT) {\n\tQueue Q;  BinTreee T;\n\tif ( !BT ) return;\t//若是空树直接返回\n\tQ = CreateQueue(MaxSize);//创建并初始化队列Q\n\tAddQ(Q, BT);\n\twhile( !IsEmpty(Q) ) {\n\t\tT = DeleteQ(Q);\n\t\tprintf(\"%d\\n\", T->Data);//访问结点\n\t\tif(T->Left) AddQ(Q, T->Left);//将左孩子放入队列\n\t\tif(T->Right) AddQ(Q, T->Right);//将右孩子放入队列\n\t}\n}\n```\n> **补充知识**\n> **数据管理的基本操作之查找**：根据某个给定关键字K，从集合R中找出关键字与K相同的记录，分为静态查找与动态查找\n> **静态查找**：集合中记录是固定的，没有插入和删除操作，只有查找。 \n> 法1：顺序查找 （哨兵概念：在数组的边界上设一个值，碰到哨兵循环就可以结束了，可以少一个分支判断）复杂度O(n); \n> 法2：二分查找 （前提：数组连续且有序）\n> **动态查找**：集合中记录时动态变化的，除查找外还可能发生插入和删除\n\n","sources":["xlog"],"attributes":[{"value":"shu-ju-jie-gou-xue-xi-bi-ji-4-er-cha-shu-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/shu-ju-jie-gou-xue-xi-bi-ji-4-er-cha-shu-md"],"date_published":"2020-03-15T00:38:18.000Z"}}}