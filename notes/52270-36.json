{"characterId":52270,"noteId":36,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreibb6fy3qsgzkevnbh262pfwuyl25qu5wsaxhy64ius3wwbtfvkbau","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:39:04.000Z","updatedAt":"2023-04-05T11:26:40.000Z","deletedAt":null,"publishedAt":"2022-02-09T20:30:11.000Z","transactionHash":"0xdc576b85b753d220cd2851aa2bc5e951b6f739ada0a82dfd613ec82afbd0296e","blockNumber":30317649,"logIndex":2,"updatedTransactionHash":"0x7a51e6ce0782b374b06df989193398714fb933e547b9cc3c8e60e10feeda9ff0","updatedBlockNumber":30334905,"updatedLogIndex":0,"metadata":{"uri":"ipfs://bafkreibb6fy3qsgzkevnbh262pfwuyl25qu5wsaxhy64ius3wwbtfvkbau","type":"NOTE","content":{"tags":["post","前端","JavaScript","设计模式","青训营"],"type":"note","title":"青训营 |「前端设计模式应用」笔记","content":"---\ntitle: 青训营 |「前端设计模式应用」笔记\nlink: note/front-end/bytedance-note/design-pattern\ncatalog: true\ndate: 2022-02-09 20:30:11\nsubtitle: 浏览器和js中常用的设计模式，包括单例模式、观察者模式、原型模式、代理模式、迭代器模式等\nlang: cn\ntags:\n- 前端\n- JavaScript\n- 设计模式\ncategories:\n- [笔记, 青训营笔记]\n---\n# 什么是设计模式\n\n设计模式是软件设计中常见问题的解决方案模型，是历史经验的总结，与特定语言无关\n\n设计模式大致分为23种设计模式\n\n- 创建型——如何高效灵活的创建一个对象\n- 结构型——如何灵活的将对象组装成较大的结构\n- 行为型——负责对象间的高效通信和职责划分\n\n# 浏览器中的设计模式\n\n## 单例模式\n\n单例模式——存在一个全局访问对象，在任意地方访问和修改都会反映在这个对象上\n\n最常用的其实就是浏览器中的window对象，提供了对浏览器的操作的封装，常用于缓存与全局状态管理等\n\n### 单例模式实现请求缓存\n\n用单例模式实现请求缓存：相同的url请求，希望第二次发送请求的时候可以复用之前的一些值\n\n首先创建Request类，该类包含一个创建单例对象的静态方法getinstance，然后真正请求的操作为request方法，向url发送请求，若缓存中存在该url则直接返回，反之则缓存到该单例对象中。可以看到如下是上节课讲过的语法~\n\n```ts\nimport {api} from './utils';\nexport class Request {\n    static instance: Request;\n    private cache: Record<string, string>;\n    constructor() {\n        this.cache = {};\n    }\n    static getinstance() {\n        if(this.instance) {\n            return this.instance;\n        }\n        this.instance = new Request();  // 之前还未有过请求，初始化该单例\n        return this.instance;\n    }\n    public async request(url:string) {\n        if(this.cache[url]) {\n            return this.cache[url];\n        }\n        const response = await api(url);\n        this.cache[url] = response;\n\n        return response;\n    }\n}\n```\n\n实际中使用如下：利用getInstance静态方法创建该单例对象，并测试起执行时间进行对比。\n\n> ps: 这里的测试是使用[Jest ](https://www.jestjs.cn/)进行的，其中用到了部分[expect](https://www.jestjs.cn/docs/expect)的api，可以通过文档了解其用途\n\n```ts\n// 不预先进行请求，测试其时间。\ntest('should response more than 500ms with class', async() => {\n    const request = Request.getinstance();  //获取/创建一个单例对象（若之前未创建过则创建）\n    const startTime = Date.now();\n    await request.request('/user/1');\n    const endTime = Date.now();\n\n    const costTime = endTime-startTime;\n    expect(costTime).toBeGreaterThanOrEqual(500);\n});\n// 先进行一次请求，在测试第二次请求的时间\ntest('should response quickly second time with class', async() => {\n    const request1 = Request.getinstance();\n    await request1.request('/user/1');\n\n    const startTime = Date.now();   // 测试这一部分的时间\n    const request2 = Request.getinstance();\n    await request2.request('/user/1');\n    const endTime = Date.now();\t\t//\n\n    const costTime = endTime-startTime;\n    expect(costTime).toBeLessThan(50);\n});\n```\n\n而在js中，我们也可以不用class写，这是因为传统的语言中无法export出来一个独立的方法等，只能export出来一个类\n\n```ts\n// 不用class？可以更简洁\nimport {api} from './utils';\nconst cache: Record<string,string> = {};\nexport const request = async (url:string) => {\n    if(cache[url]) {    // 与class中一致\n        return cache[url];\n    }\n    const response = await api(url);\n\n    cache[url] = response;\n    return response;\n};\n// 使用，可以看出来该方法也符合单例模式，但更加简洁。\ntest('should response quickly second time', async() => {\n    await request('/user/1');\n    const startTime = Date.now();   // 测试这一部分的时间\n    await request('/user/1');\n    const endTime = Date.now();\n\n    const costTime = endTime-startTime;\n    expect(costTime).toBeLessThan(50);\n});\n```\n\n## 发布订阅模式（观察者模式）\n\n应用非常广泛的一种模式，在被订阅对象发生变化时通知订阅者，常见场景很多，从系统架构之间的解耦到业务中的一些实现模式、邮件订阅等等。类似于添加事件\n\n### 发布订阅模式实现用户上线订阅\n\n举个实际应用的例子：通过该模式，我们可以实现用户的相互订阅，在该用户上线时调用相应的通知函数。\n\n如图创建了一个User类， 构造器中初始状态置为离线，其拥有一个followers对象数组，包括了该用户订阅的所有{用户，调用函数}，每次在该用户上线时，遍历其followers进行通知\n\n```ts\ntype Notify = (user: User) => void;\nexport class User {\n    name: string;\n    status: \"offline\" | \"online\";// 状态 离线/在线\n    followers: { user:User; notify: Notify }[]; // 订阅他人的数组，包括用户及其上线时的通知函数\n    constructor(name: string) {\n        this.name = name;\n        this.status = \"offline\";\n        this.followers = [];\n    }\n    subscribe(user:User, notify: Notify) {\n        user.followers.push({user, notify});\n    }\n    online() { // 该用户上线 调用其订阅函数\n        this.status = \"online\";\n        this.followers.forEach( ({notify}) => {\n            notify(this);\n        });\n    }\n}\n```\n\n测试函数：还是用jest，创建假的订阅函数进行测试（\n\n```ts\ntest(\"should notify followers when user is online for multiple users\", () => {\n   const user1 = new User(\"user1\");\n   const user2 = new User(\"user2\"); \n   const user3 = new User(\"user3\"); \n   const mockNotifyUser1 = jest.fn();   // 通知user1的函数\n   const mockNotifyUser2 = jest.fn();   // 通知user2的函数\n   user1.subscribe(user3, mockNotifyUser1); // 1订阅了3\n   user2.subscribe(user3, mockNotifyUser2); // 2订阅了3\n   user3.online();  // 3上线，调用mockNotifyUser1和mockNotifyUser2\n   expect(mockNotifyUser1).toBeCalledWith(user3);\n   expect(mockNotifyUser2).toBeCalledWith(user3);\n});\n```\n\n# JavaScript中的设计模式\n\n## 原型模式\n\n可以想到javascript中的常见语言特性：原型链，原型模式指的其实就是复制一个已有的对象来创建新的对象，这在对象十分庞大的时候会有比较好的性能（相比起直接创建）。常用于js中对象的创建\n\n### 原型模式创建上线订阅中的用户\n\n首先，创建一个原型，可以看到这个原型相比起之前的来说没有定义构造器。\n\n```ts\n// 原型模式，当然要有原型啦\nconst baseUser:User = { \n    name: \"\",\n    status: \"offline\",\n    followers: [],\n    subscribe(user, notify) {\n        user.followers.push({user, notify});\n    },\n    online() { // 该用户上线 调用其订阅函数\n        this.status = \"online\";\n        this.followers.forEach( ({notify}) => {\n            notify(this);\n        });\n    }\n}\n```\n\n导出在该原型之上创建对象的函数，该函数接受一个name参数，利用[Object.create()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create) 使用原型来创建一个新对象，并在其基础上进行增加或修改\n\n```ts\n// 然后导出在该原型之上创建对象的函数\nexport const createUser = (name:string) => {\n    const user:User = Object.create(baseUser);\n    user.name = name;\n    user.followers = [];\n    return user;\n};\n```\n\n实际使用：可以看到将new User变成了createUser\n\n```ts\ntest(\"should notify followers when user is online for user prototypes\", () => {\n    const user1 = createUser(\"user1\");\n    const user2 = createUser(\"user2\");\n    const user3 = createUser(\"user3\");\n    const mockNotifyUser1 = jest.fn();   // 通知user1的函数\n    const mockNotifyUser2 = jest.fn();   // 通知user2的函数\n    user1.subscribe(user3, mockNotifyUser1); // 1订阅了3\n    user2.subscribe(user3, mockNotifyUser2); // 2订阅了3\n    user3.online();  // 3上线，调用mockNotifyUser1和mockNotifyUser2\n    expect(mockNotifyUser1).toBeCalledWith(user3);\n    expect(mockNotifyUser2).toBeCalledWith(user3);\n});\n```\n\n## 代理模式\n\n可自定义控制队员对象的访问方式，并且允许在更新前后做一些额外处理，常用于监控、代理工具、前端框架等等。JS中有自带的代理对象：[Proxy()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy) ，在红宝书中代理那章也有详细阐述。\n\n### 代理模式实现用户状态订阅\n\n还是上述观察者模式的例子，可以使用代理模式对其进行优化，让他的online函数只做一件事：更改状态为上线。\n\n```ts\ntype Notify = (user: User) => void;\nexport class User {\n    name: string;\n    status: \"offline\" | \"online\";// 状态 离线/在线\n    followers: { user:User; notify: Notify }[]; // 订阅他人的数组，包括用户及其上线时的通知函数\n    constructor(name: string) {\n        this.name = name;\n        this.status = \"offline\";\n        this.followers = [];\n    }\n    subscribe(user:User, notify: Notify) {\n        user.followers.push({user, notify});\n    }\n    online() { // 该用户上线 调用其订阅函数\n        this.status = \"online\";\n        // this.followers.forEach( ({notify}) => {\n        //     notify(this);\n        // });\n    }\n}\n```\n\n创建User的一个代理：ProxyUser\n\n> Proxy函数说明\n>\n> `target`\n>\n> 要使用 `Proxy` 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\n>\n> `handler`\n>\n> 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 `p` 的行为。\n\n```ts\n// 创建代理，监听其上线状态的变化\nexport const createProxyUser = (name:string) => {\n    const user = new User(name); //正常的user\n    // 代理的对象\n    const proxyUser = new Proxy(user, { \n        set: (target, prop: keyof User, value) => {\n            target[prop] = value;\n            if(prop === 'status') {\n                notifyStatusHandlers(target, value);\n            }\n            return true;\n        }\n    })\n    const notifyStatusHandlers = (user: User, status: \"online\" | \"offline\") => {\n        if(status === \"online\") {\n            user.followers.forEach(({notify}) => {\n                notify(user);\n            });\n        }\n    };\n    return proxyUser;\n}\n```\n\n\n\n## 迭代器模式\n\n在不暴露数据类型的情况下访问集合中的数据，常用于数据结构中拥有多种数据类型（列表、\n\n树等），提供通用的操作接口。\n\n### 用for of 迭代所有组件\n\n用到了 [Symbol.iterator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator)  该迭代器可以被 [`for...of`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of) 循环使用。\n\n定义一个list 队列，每次从队首取个节点出来，如果这个节点有孩子结点将其全部添加到队尾，每次调用next都返回一个结点~详见代码\n\n```ts\nclass MyDomElement {\n    tag: string;\n    children: MyDomElement[];\n    constructor(tag:string) {\n        this.tag = tag;\n        this.children = [];\n    }\n    addChildren(component: MyDomElement) {\n        this.children.push(component);\n    }\n    [Symbol.iterator]() {\n        const list = [...this.children];\n        let node;\n        return {\n            next: () => {\n                while((node = list.shift())) { // 每次从队首取个节点出来，如果有孩子结点将其添加到队尾\n                    node.children.length > 0 && list.push(...node.children);\n                    return { value: node, done: false };\n                }\n                return { value:null, done:true };\n            },\n        };\n    }\n}\n```\n\n使用场景如下：通过for of迭代body中的所有子元素\n\n```ts\ntest(\"can iterate root element\", () => {\n    const body = new MyDomElement(\"body\");\n    const header = new MyDomElement(\"header\");\n    const main = new MyDomElement(\"main\");\n    const banner = new MyDomElement(\"banner\");\n    const content = new MyDomElement(\"content\");\n    const footer = new MyDomElement(\"footer\");\n    \n    body.addChildren(header);\n    body.addChildren(main);\n    body.addChildren(footer);\n    \n    main.addChildren(banner);\n    main.addChildren(content);\n    \n    const expectTags: string[] = [];\n    for(const element of body) {\t// 迭代body的所有元素，需要包含main中的子元素\n        if(element) {\n            expectTags.push(element.tag);\n        }\n    }\n    \n    expect(expectTags.length).toBe(5);\n});\n```\n\n# 前端框架中的设计模式（React、Vue...）\n\n## 代理模式\n\n与之前讲的Proxy不太一样\n\n### Vue组件实现计数器\n\n```html\n<template>\n\t<button @click=\"count++\">count is:{{ count }}</button>\n</template>\n<script setup lang=\"ts\">\nimport {ref} from \"vue\";\nconst count = ref(0);\n</script>\n```\n\n上述代码，为什么count能随点击而变化？这就要说到前端框架中对DOM操作的代理了：\n\n更改DOM属性 -> 视图更新\n\n更改DOM属性 -> 更新虚拟DOM -Diff-> 视图更新\n\n如下就是前端框架对DOM的一个代理，通过其提供的钩子可以在更新前后进行操作：\n\n```html\n<template>\n\t<button @click=\"count++\">count is:{{ count }}</button>\n</template>\n<script setup lang=\"ts\">\nimport { ref, onBeforeUpdate, onUpdated } from \"vue\";\nconst count = ref(0);\nconst dom = ref<HTMLButtonElement>();\nonBeforeUpdate(() => {\n    console.log(\"Dom before update\", dom.value?.innerText);\n});\nonUpdated(() => {\n    console.log(\"Dom after update\", dom.value?.innerText);\n});\n</script>\n```\n\n\n\n## 组合模式\n\n可以多个对象组合使用，也可以单个对象独立使用，常应用于前端组件，最经典的就是React的组件结构：\n\n### React组件结构\n\n还是计数器的例子~\n\n```tsx\nexport const Count = () => {\n    const [count, setCount] = useState(0);\n    return (\n    \t<button onClick={() => setCount((count) => count+1)}>\n        \tcount is: {count}\n        </button>\n    );\n};\n```\n\n该Count，既可以独立渲染，也可以渲染在App中，后者就是一种组合\n\n```react\nfunction App() {\n    return (\n        <div className = \"App\">\n        \t<Header />\n            <Count />\n            <Footer />\n        </div>\n    );\n}\n```\n\n\n\n# 总结感想\n\n下面是老师的一些总结：\n\n> 设计模式不是银弹，总结出抽象的模式听起来比较简单，但是想要将抽象的模式套用到实际的场景中却非常困难，现代编程语言的多编程范式带来了更多的可能性，我们要在真正优秀的开源项目中学习设计模式并不断实践\n\n这节课讲了浏览器和js中常用的设计模式，包括单例模式、观察者模式、原型模式、代理模式、迭代器模式等，还讲了设计模式究竟有什么用~在我看来，从实际的项目中学习设计模式确实是一种比较好的方法。  \n\n> 本文引用的大部分内容来自吴立宁老师的课\n","sources":["xlog"],"summary":"设计模式是软件设计中常见问题的解决方案模型，是历史经验的总结，与特定语言无关 设计模式大致分为23种设计模式\n\n创建型——如何高效灵活的创建一个对象 结构型——如何灵活的将对象组装成较大的结构 行为型——负责对象间的高效通信和职责划分\n单例模式\n\n单例模式…","attributes":[{"value":"design-patternmd","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/design-patternmd"],"date_published":"2022-02-09T20:30:11.000Z"}}}