{"characterId":52270,"noteId":27,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreigl7kshkat5wgqs7jzgjt2yigu45aw45oklbgovwrrl24vupudztq","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:38:05.000Z","updatedAt":"2023-04-05T06:38:05.000Z","deletedAt":null,"publishedAt":"2020-08-05T22:30:01.000Z","transactionHash":"0xbfab47b82ecebba6e9fc656935da117e29078d33b8ae11d03dbc25062e62f2ae","blockNumber":30317590,"logIndex":2,"updatedTransactionHash":"0xbfab47b82ecebba6e9fc656935da117e29078d33b8ae11d03dbc25062e62f2ae","updatedBlockNumber":30317590,"updatedLogIndex":2,"metadata":{"uri":"ipfs://bafkreigl7kshkat5wgqs7jzgjt2yigu45aw45oklbgovwrrl24vupudztq","type":"NOTE","content":{"tags":["post","c++","博弈论"],"type":"note","title":"博弈论——模板&分析（存用）","content":"---\ntitle: 博弈论——模板&分析（存用）\nlink: 博弈论——模板&分析（存用）\ncatalog: true\nlang: cn\ndate: 2020-08-05 22:30:01 \nsubtitle: 主要学习了三大基本博弈论和SG函数，参考博客链接都在文内\ntags:\n- c++\n- 博弈论\ncategories:\n- [笔记, 算法]\n---\n\n# 一、Fibonacci博弈\n## 描述\n基本的斐波那契博弈（Fibonacci Game）描述如下：\n> 有一堆石子，两个顶尖聪明的人玩游戏，先取者可以取走任意多个，但不能全取完，之后**每次可以取的石子数至少为1，至多为对手刚取的石子数的2倍**。约定取走最后一个石子的人为赢家，求必败态。\n>\n## 结论\n**当且仅当总石子数为斐波那契数时，先手必败**。\n## 证明 \n证明如下，转自[大佬证明](https://blog.csdn.net/dgq8211/article/details/7602807)\n**用到了Zeckendorf定理（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。**\n# 二、Bash博弈\n## 描述\n基本的巴什博弈（Bash Game）描述如下：\n\n> 有一堆n个物品，两人轮流取走物品，**每次至少取一个，最多取m个**，最后取光者获胜。\n## 结论\n若n % (m+1) == 0，则先手必败\n```cpp\nbool FirstWin(int n, int m) { //先手必胜返回true\n\treturn n % (m+1) != 0;\n}\n```\n## 证明 \n博弈过程如下：[证明](https://blog.lordash.cf/posts/f0fbaf1d.html)\n这里简单说说\n**同余定理：若n%(m+1) = r, 若先取者拿走r个，后者无论拿走1~m任意个，先手都可以再拿走若干个凑够（m+1）个，则先手必赢。反之先手必败。当n<m时，先手可以一次取完，也是必胜**\n## 巴什博弈变形\n> 有一堆n个物品，两人轮流取走物品，每次至少取p个，最多取q个，剩余不足p个时一次取完，最后取光者胜利。\n\n**若n%(p+q) = r,则当r != 0 && r < p 时先手必胜，反之先手必败**\n# 三、Wythoff博弈\n## 描述\n基本的威佐夫博弈（Wythoff Game）描述如下：\n\n> 有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，每次至少取一个，多者不限，最后取光者得胜。\n## 结论\n设两堆物品各有a、b个，求出ab的差值后乘以黄金分割比，看结果是否等于ab中的最小值，若等于则先手必败\n```cpp\nbool FirstWin(int a, int b) { //先手必胜返回true\n\tdouble G = (sqrt(5.0)+1) / 2;\t//黄金分割比\n\tint t = abs(a-b) * G;\n\treturn d != min(a,b);\t\n}\n```\n\n## 证明 \n证明较复杂…暂存一下板子，这里看[证明](https://blog.lordash.cf/posts/8e3cecbf.html)\n# 四、Nim博弈\n## 描述\n基本的尼姆博弈（Nim Game）描述如下：\n\n> 有若干堆各若干个物品，两个人轮流从某一堆取任意多的物品，**每次至少取一个，多者不限**，最后取光者得胜。\n## 结论\n将N堆物品数量全部异或后，若结果为0则先手必败，否则先手必胜\n```cpp\nbool FirstWin(int a, int b) { //先手必胜返回true\n\tint ans = 0;\n\tfor(int i = 0; i < N; ++i) ans ^= a[i];//a[i]为物品数量\n\treturn ans != 0;\n}\n```\n\n## 证明 \n证明也很复杂…这里看[证明](https://blog.lordash.cf/posts/2aa44f65.html)\n后面会介绍SG函数，一般将最终局面的SG值设为0\nSG  定理：游戏的和的 SG 值是各个子游戏的 SG 值的异或。\n知道了以上结论，想到 Nim 游戏实际上可以分为 n 个 Bash 游戏，而 Bash 游戏若可以无限取子，则以当前局面剩余石子数为状态，SG(x)=x。所以这个题目的答案即为各个堆石子数的异或值，若值为 0，先手必败，否则先手总有方案使得下一局面异或值为 0，后手必败。\n\n## 变形\n参考博客[Nim博弈及其变形](https://blog.csdn.net/clover_hxy/article/details/53818624?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.channel_param)\n### 反Nim博弈\n反尼姆博弈顾名思义，\n\n> 有若干堆各若干个物品，两个人轮流从某一堆取任意多的物品，**每次至少取一个，多者不限**，最后取光者失败。\n>\n[例题 E - Misere Nim](https://vjudge.net/contest/387724#problem/E)\n先手只有两种情况必胜，1是所有堆石子数全为1，且异或和为0，2是有石子数不为1的堆，且异或和不为0\n# 五、SG函数\n参考博客：[SG函数](https://blog.lordash.cf/posts/266a09be.html)、[组合游戏 - SG函数和SG定理](https://blog.csdn.net/luomingjun12315/article/details/45555495)\n## 1.概念介绍\n### ICG博弈游戏（公平组合游戏）\n条件如下： 题目描述一般为A,B 两人做游戏\n 1. A、B交替进行操作\n 2. 每操作一次，选手可以在合法操作集合中任选一种操作。\n 3. 对于游戏的任何一种可能的局面，合法的操作集合只取决于这个局面本身，不取决于其它因素（跟选手，以前的所有操作无关）\n 4. 如果当前选手无法进行合法的操作，判负\n\n以上面所提的巴什博弈做背景，有一堆n个物品，两人轮流取走物品，**每次至少取一个，最多取m个**，最后取光者获胜。\n一个公平游戏可以抽象地用一个有向无环图来表示，这个图中每个点都对应一个状态，每条有向边代表从一个状态到另一个状态的合法操作。\n\n### 必胜态与必败态\n - 必败态（P-position）：上一个选手（即刚操作完的选手）处于必胜局面，此时谁面临此状态谁必败。\n - 必胜态（N-position）：下一个选手（即将操作的选手）处于必胜局面，此时谁面临此状态谁必胜。\n \n性质：\n - 所有的终结点都是必败态\n - 从任何必胜态操作，至少能有一种方式进入必败态\n - 无论如何操作， 从必败态都只能进入必胜态\n\n ![图源https://blog.lordash.cf/posts/266a09be.html](https://img-blog.csdnimg.cn/20200805213144752.png)\n## 2.SG函数\n### 定义mex运算\n先定义mex(minimal excludant)运算，这是施加于一个集合的运算，**表示最小的不属于这个集合的非负整数**。\n - 如mex{2,3,5}=0、mex{0,1,2,4}=3、mex{}=0。\n\n对于任意状态x，定义SG(x)=mex(S)，其中**S是x后继状态的SG函数值的集合**。如x有三个后继状态分别为a、b、c，那么SG(x)=mex{SG(a), SG(b), SG(c)}。 这样，集合S的终态必然是空集，所以**当且仅当x为必败点P时，SG函数的终态为SG(x)=0**。\n\n通过SG函数，**每个ICG都可以转换成Nim博弈**。SG函数的定义域为ICG的决策树上的所有节点，此时具体定义为：SG(x)=mex{SG(y)|y是x的节点}。对于ICG的决策树上的节点u，我们可以把它想象成一个只有一堆石子，个数为SG(u)的Nim博弈。SG函数的求解方式我是通过这个博客理解的:[组合游戏 - SG函数和SG定理](https://blog.csdn.net/luomingjun12315/article/details/45555495)。\n\n> **取石子问题** \n> 有1堆n个的石子，每次只能取{ 1, 3, 4 }个石子，先取完石子者胜利，那么各个数的SG值为多少？ \n\nSG[0]=0，f[]={1,3,4},\n\n - x=1 时，可以取走1 - f{1}个石子，剩余{0}个，所以 SG[1] = mex{ SG[0] }= mex{0} = 1; \n - x=2 时，可以取走2 - f{1}个石子，剩余{1}个，所以 SG[2] = mex{ SG[1] }= mex{1} = 0;\n - x=3 时，可以取走3 - f{1,3}个石子，剩余{2,0}个，所以 SG[3] = mex{SG[2],SG[0]} = mex{0,0} =1;\n - x=4 时，可以取走4- f{1,3,4}个石子，剩余{3,1,0}个，所以 SG[4] = mex{SG[3],SG[1],SG[0]} = mex{1,1,0} = 2;\n - x=5 时，可以取走5 - f{1,3,4}个石子，剩余{4,2,1}个，所以SG[5] = mex{SG[4],SG[2],SG[1]} =mex{2,0,1} = 3;\n\n 以此类推…\n x = 0 1 2 3 4 5 6 7 8…\nSG[x] = 0 1 0 1 2 3 2 0 1…\n\n由上述实例我们就可以得到SG函数值求解步骤，那么计算1~n的SG函数值步骤如下：\n 1. 使用数组f将**可改变当前状态**的方式记录下来。\n 2. 用另一个数组将当前状态x 的后继状态标记。\n 3. 最后模拟mex运算，也就是我们在标记值中 搜索 未被标记值 的最小值，将其赋值给SG(x)。\n 4. 不断的重复 2 - 3 的步骤，就完成了 计算1~n 的函数值。\n模板如下：\n\n```cpp\n//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理\n//SG[]:0~n的SG函数值\n//S[]:为x后继状态的集合\nint f[N],SG[MAXN],S[MAXN];\nvoid  getSG(int n){\n    int i,j;\n    memset(SG,0,sizeof(SG));\n    //因为SG[0]始终等于0，所以i从1开始\n    for(i = 1; i <= n; i++){\n        //每一次都要将上一状态 的 后继集合 重置\n        memset(S,0,sizeof(S));\n        for(j = 0; f[j] <= i && j <= N; j++)\n            S[SG[i-f[j]]] = 1;  //将后继状态的SG函数值进行标记\n        for(j = 0;; j++) if(!S[j]){   //查询当前后继状态SG值中最小的非零值\n            SG[i] = j;\n            break;\n        }\n    }\n}  \n```\n## 3.SG定理\n 1. **游戏和的 SG 函数是所有子游戏的 SG 函数的异或和**，其中所有子游戏互相独立。 \n 2. 所以当且仅当每堆石子的 SG 函数的异或和不为0时，先手必胜。\n# 六、Green Hackenbush（树上删边游戏）\n做题第一题就被卡住了，搜了下题解发现是没学过的Green博弈\n参考博客：[博弈-Green Hackenbush](http://blog.sina.com.cn/s/blog_8f06da990101252l.html)，以下内容都是这里面的\n## 1.Hackenbush游戏概述\nHackenbush游戏是通过移除一个有根图的某些边，直到没有与地板的相连的边。地板用虚线来表示，其中移除某一条边的时候，那条边以上所连着的所有边都会移除，就像砍树枝那样，树枝以上的部分也会被移除。**在这里，我们讨论这个游戏的公平版本，每个玩家在他的回合可以删除任意的边。这个版本叫做Green Hackenbush，每条边都是绿色的，下面我们简称GH游戏**。这里还有一个不公平版本，叫做Blue-Red Hackenbush，有些边是蓝色，有些边是红色，而玩家一只能删除蓝色边，玩家二只能删除红色边。总的来说，Hackenbush游戏，可能会有只供玩家一删除的蓝色边，只供玩家二删除的红色边，还有两个玩家都可以进行操作的绿色边。\n\n\n## 2.克朗原理（Colon Principle）\n> 对于树上的某一个点，它的分支可以转化成以这个点为根的一根竹子，这个竹子的长度就是它各个分支的边的数量的异或和\n\n所有边权值为1，则是裸的green博弈，每个点的sg函数=子节点的sg函数+1的异或和。\n权值不同时，当AB权值=1时，sg[A]=sg[B]+1。\n当AB权值为偶数时，sg[A]=sg[B]。\n当AB权值为奇数时，sg[A]=sg[B]^1\n\n","sources":["xlog"],"attributes":[{"value":"bo-yi-lun--mo-ban--fen-xi--cun-yong-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/bo-yi-lun--mo-ban--fen-xi--cun-yong-md"],"date_published":"2020-08-05T22:30:01.000Z"}}}