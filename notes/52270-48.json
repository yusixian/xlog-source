{"characterId":52270,"noteId":48,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreiggj77z5tzs4ygqfs2ezzk5jg6hefvwwyitgmiq5tblhwjtroap4u","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:39:04.000Z","updatedAt":"2023-04-05T11:28:12.000Z","deletedAt":null,"publishedAt":"2022-01-27T14:30:17.000Z","transactionHash":"0xdc576b85b753d220cd2851aa2bc5e951b6f739ada0a82dfd613ec82afbd0296e","blockNumber":30317649,"logIndex":14,"updatedTransactionHash":"0xb36a46475cde9b2d52ea88ec256db673c3e2140c09df29a02e61327befa89fa5","updatedBlockNumber":30334997,"updatedLogIndex":0,"metadata":{"uri":"ipfs://bafkreiggj77z5tzs4ygqfs2ezzk5jg6hefvwwyitgmiq5tblhwjtroap4u","type":"NOTE","content":{"tags":["post","前端","WebGL","图形学","青训营"],"type":"note","title":"青训营 |「WebGL基础」","content":"---\ntitle: 青训营 |「WebGL基础」\nlink: note/front-end/bytedance-note/webgl-basics\ncatalog: true\ndate: 2022-01-27 14:30:17\nsubtitle: 这节课老师非常详尽的讲解了WebGL的绘图及其相关库，展示了很多有意思的WebGL小项目~\nlang: cn\ntags:\n- 前端\n- WebGL\n- 图形学\ncategories:\n- [笔记, 青训营笔记]\n---\n\n#  本节课重点内容\n\n##  Why WebGL / Why GPU?\n\n- WebGL是什么?\n  - GPU ≠ WebGL ≠ 3D\n- WebGL为什么不像其他前端技术那么简单?\n\n## 现代的图像系统\n\n- **光栅(Raster)**：几乎所有的现代图形系统都是**基于光栅来绘制**图形的，光栅就是指**构成图像的像素阵列**。\n- **像素(Pixel)**：**一个像素对应图像上的一个点**，它通常保存图像上的某个具体位置的颜色等信息。\n- **帧缓存(Frame Buffer)**：在绘图过程中，**像素信息被存放于帧缓存**中，帧缓存是一块内存地址。\n- **CPU (Central Processing Unit**)：中央处理单元，负责**逻辑计算**。\n- **GPU (Graphics Processing Unit)**：图形处理单元，负责**图形计算**。\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f97c08e4d8da45c4ae56b62f293a3be2~tplv-k3u1fbpfcp-watermark.image?)\n\n- 如上图，现代图像的渲染如图过程\n\n1. 轮廓提取/ meshing\n2. 光栅化\n3. 帧缓存\n4. 渲染\n\n### The Pipeline\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c26dca222e6942149b5a70c480f401a1~tplv-k3u1fbpfcp-watermark.image?)\n\n### GPU\n\n- GPU由**大量的小运算单元**构成\n- 每个运算单元只负责处理很**简单**的计算\n- 每个运算单元彼此**独立**\n- 因此所有计算可以**并行**处理\n\n### WebGL & OpenGL关系\n\n[OpenGL, OpenGL ES, WebGL, GLSL, GLSL ES API Tables (umich.edu)](http://web.eecs.umich.edu/~sugih/courses/eecs487/common/notes/APITables.xml)\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce125f7f2cc14fada66e2971853070d2~tplv-k3u1fbpfcp-watermark.image?)\n\n## WebGL绘图步骤\n\n**步骤**\n\n1. 创建WebGL上下文\n2. 创建WebGL Program\n3. 将数据存入缓冲区\n4. 将缓冲区数据读取到GPU\n5. GPU执行WebGL程序，输出结果\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a24f2b13adc646e28dec4623c43ee41f~tplv-k3u1fbpfcp-watermark.image?)\n\n如图，针对几个单词进行解释：\n\n- Raw Vertices & Primitives 原始顶点&原语\n- Vertex Processor **顶点着色器**\n- 运算后送到 **片元着色器** 进行处理：Fragment Processor\n\n### 创建WebGL上下文\n\n```js\nconst canvas = document.querySelector('canvas');\nconst gl = canvas.getContext('webgl');\n// 创建上下文， 注意兼容\nfunction create3DContext(canvas, options) {\n    const names = ['webgl', 'experimental-webgL','webkit-3d','moz-webgl'];  // 特性判断\n    if(options.webgl2) names.unshift(webgl2);\n    let context = null;\n    for(let ii = 0; ii < names.length; ++ii) {\n        try {\n            context = canvas.getContext(names[ii], options);\n        } catch(e) {\n            // no-empty\n        }\n        if(context) {\n            break;\n        }\n    }\n    return context;\n}\n```\n\n### 创建WebGL Program（The Shaders）\n\n1. Vertex Shader（顶点着色器）\n\n   通过类型数组position，**并行**处理每个顶点的位置\n\n   ```js\n   attribute vec2 position;// vec2 二维向量\n   void main() {\n       gl_PointSize = 1.0;\n       gl_Position = vec4(position, 1.0, 1.0);\n   }\n   ```\n\n2. Fragment Shader（片元着色器）\n\n   为顶点轮廓包围的区域内所有像素进行着色\n\n   ```js\n   precision mediump float;\n   void main() {\n       gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);//对应rgba（255，0，0，1.0），红色\n   }\n   ```\n\n其具体步骤如下：\n\n1. 创建顶点着色器和片元着色器代码：\n\n   ```js\n   // 顶点着色器程序代码\n   const vertexShaderCode = `\n   attribute vec2 position;\n   void main() {\n       gl_PointSize = 1.0;\n       gl_Position = vec4(position, 1.0, 1.0);\n   }\n   `;\n   // 片元着色器程序代码\n   const fragmentShaderCode = `\n   precision mediump float;\n   void main() {\n       gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n   }\n   `;\n   ```\n\n2. 使用 **[`createShader()`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/createShader)** 创建着色器对象 \n\n3. 使用 **[`shaderSource()`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/shaderSource)** 设置着色器的程序代码\n\n4. 使用 **[`compileShader()`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/compileShader)** 编译一个着色器\n\n   ```js\n   // 顶点着色器\n   const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n   gl.shaderSource(vertexShader, vertex);\n   gl.compileShader(vertexShader);\n   // 片元着色器\n   const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n   gl.shaderSource(fragmentShader, fragment);\n   gl.compileShader(fragmentShader);\n   ```\n\n5. 使用**[`createProgram()`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/createProgram)** 创建 [`WebGLProgram`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLProgram) 对象\n\n6. 使用 **[`attachShader() `](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/attachShader)** 往 [`WebGLProgram`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLProgram) 添加一个片段或者顶点着色器。\n\n7. 使用 **[`linkProgram()` ](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/linkProgram)**链接给定的[`WebGLProgram`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLProgram)，从而完成为程序的片元和顶点着色器准备GPU代码的过程。\n\n8. 使用 **[`useProgram()`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/useProgram)** 将定义好的[`WebGLProgram`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLProgram) 对象添加到当前的渲染状态\n\n   ```js\n   // 创建着色器程序并链接\n   const program = gl.createProgram();\n   gl.attachShader(program, vertexShader);\n   gl.attachShader(program, fragmentShader);\n   gl.linkProgram(program);\n   \n   gl.useProgram(program);\n   ```\n\n### 将数据存到缓冲区中（Data to Frame Buffer）\n\n- **坐标轴**：webGL的坐标系统是归一化的，**浏览器和canvas2D**的坐标系统是以**左上角为坐标原点，y轴向下，x轴向右**，坐标值相对于原点。而**webGL**的坐标系是以绘制画布的**中心点为原点**，**正常的笛卡尔坐标系**。\n\n通过一个顶点数组表示其顶点，使用 **[`createBuffer()`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/createBuffer)** 创建并初始化一个用于储存顶点数据或着色数据的[`WebGLBuffer`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLBuffer)对象并返回`bufferId`，然后使用 **[`bindBuffer()`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/bindBuffer)** 将给定的 `bufferId` 绑定到目标并返回，最后使用**[`bufferData()`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/bufferData)**，将数据绑定至buffer中。\n\n```js\n// 顶点数据\nconst points = new Float32Array([\n    -1, -1,\n    0, 1,\n    1, -1,\n]);\n// 创建缓冲区\nconst bufferId = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, bufferId);\ngl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);\n```\n\n### 读取缓冲区数据到GPU（Frame Buffer to GPU）\n\n> - [getAttribLocation() ](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/getAttribLocation)返回了给定[`WebGLProgram`](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLProgram)对象中某属性的下标指向位置。\n>\n> - [vertexAttribPointer()](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) 告诉显卡从当前绑定的缓冲区（bindBuffer()指定的缓冲区）中读取顶点数据。\n> - [enableVertexAttribArray()](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/enableVertexAttribArray) 可以打开属性数组列表中指定索引处的通用顶点属性数组。\n\n```js\nconst vPosition = gl.getAttribLocation(program, 'position'); // 获取顶点着色器中的position变量的地址\ngl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0); // 给变量设置长度和类型\ngl.enableVertexAttribArray(vPosition); // 激活这个变量\n```\n\n### 输出结果（Output）\n\n[Output](https://code.h5jun.com/kopozi/edit?js,output) \n\n> [drawArrays()](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/drawArrays) 从向量数组中绘制图元\n\n```js\n// output\ngl.clear(gl.COLOR_BUFFER_BIT);  //清除缓冲的数据\ngl.drawArrays(gl.TRIANGLES, 0, points.length / 2);\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a2a842817cf45c1b630cd7cfc168031~tplv-k3u1fbpfcp-watermark.image?)\n\n## WebGL太复杂？其他方式\n\n### canvas 2D\n\n看看人家canvas2D，绘制同样的三角形：\n\n```js\n// canvas 简单粗暴，都封装好了\nconst canvas = document.querySelector('canvas');\nconst ctx = canvas.getContext('2d');\nctx.beginPath();\nctx.moveTo(250, 0);\nctx.lineTo(500, 500);\nctx.lineTo(0, 500);\nctx.fillStyle = 'red';\nctx.fill();\n```\n\n### Mesh.js\n\n[mesh-js/mesh.js: A graphics system born for visualization 😘. (github.com)](https://github.com/mesh-js/mesh.js)\n\n```js\nconst {Renderer, Figure2D, Mesh2D} = meshjs;\nconst canvas = document.querySelector ('canvas');\nconst renderer = new Renderer(canvas);\n\nconst figure = new Figure2D();\nfigurie.beginPath();\nfigure.moveTo(250, 0);\nfigure.lineTo(500，500);\nfigure.lineTo(0, 500);\nconst mesh = new Mesh2D(figure, canvas);\nmesh.setFill({\n    color: [1, 0, 0, 1],\n});\nrenderer.drawMeshes([mesh]);\n```\n\n### Earcut\n\n使用[Earcut](https://github.com/mapbox/earcut)进行三角剖分\n\n```\nconst vertices = [\n    [-0.7, 0.5],\n    [-0.4, 0.3],\n    [-0.25, 0.71],\n    [-0.1, 0.56],\n    [-0.1, 0.13],\n    [0.4, 0.21],\n    [0, -0.6],\n    [-0.3, -0.3],\n    [-0.6, -0.3],\n    [-0.45, 0.0],\n];\nconst points = vertices.flat();\nconst triangles = earcut(points)\n```\n\n### 3D Meshing\n\n由设计师导出给我们，再提取\n\n[SpriteJS/next - The next generation of spritejs.](http://spritejs.com/demo/#/3d/wireframe)\n\n## 图形变换（Transforms）\n\n这就是数字图像处理相关的知识了（学过的都还回来了.jpg）\n\n### 平移\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b9bcc7942b446668eeef74d1132d637~tplv-k3u1fbpfcp-watermark.image?)\n\n### 旋转\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffd20cb1d9b54ce99cfb3bc5a4dc5758~tplv-k3u1fbpfcp-watermark.image?)\n\n### 缩放\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4faf8762b5434e02b5b65397216c536e~tplv-k3u1fbpfcp-watermark.image?)\n\n### 线性变换（旋转+缩放）\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b346ba1cae3a413a8532e226fe832e65~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/208ec6cae5a541089c5825d472ded91f~tplv-k3u1fbpfcp-watermark.image?)\n\n从线性变换到齐次矩阵\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d26773fa78f34969b4405ff5d4c25b9c~tplv-k3u1fbpfcp-watermark.image?)\n\n老师的又一个栗子：[Apply Transforms](https://code.h5jun.com/vikig/edit?js,output)\n\n## 3D Matrix\n\n3D标准模型的**四个齐次矩阵**(mat4)\n\n1. 投影矩阵Projection Matrix（正交投影和透视投影）\n2. 模型矩阵Model Matrix （对顶点进行变换Transform）\n3. 视图矩阵View Matrix（3D的视角，想象成一个相机，在相机的视口下）\n4. 法向量矩阵Normal Matrix（垂直于物体表面的法向量，通常用于计算物体光照）\n\n## Read more\n\n1. [The Book of Shaders](https://thebookofshaders.com/) （介绍片元着色器，非常好玩的）\n2. [Mesh.js](https://github.com/mesh-js/mesh.js) （底层库，欸嘿）\n3. [Glsl Doodle](https://doodle.webgl.group/) （片元着色器的一个轻量库，有很多小demo）\n4. [SpriteJS](http://spritejs.com/#/) （月影老师写的开源库orz）\n5. [Three.js](https://threejs.org/)（很多有意思的~~游戏~~项目）\n6. [Shadertoy BETA](https://www.shadertoy.com/)（很多有意思的项目）\n\n## 总结感想\n\n这节课老师非常详尽的讲解了WebGL的绘图及其相关库，展示了很多有意思的WebGL小项目~\n\n> 本文引用的大部分内容来自月影老师的课和MDN！月影老师，tql!\n\n","sources":["xlog"],"summary":"Why WebGL / Why GPU? WebGL是什么?\nGPU ≠ WebGL ≠ 3D\nWebGL为什么不像其他前端技术那么简单?\n现代的图像系统\n光栅(Raster)：几乎所有的现代图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列。 像素…","attributes":[{"value":"webgl-basicsmd","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/webgl-basicsmd"],"date_published":"2022-01-27T14:30:17.000Z"}}}