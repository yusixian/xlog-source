{"characterId":52270,"noteId":25,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreic5yhxzt5axm4dfciyrfgwyhyik2jvykkurpke6d3lx33ipp7tdyi","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:38:05.000Z","updatedAt":"2023-04-05T06:38:05.000Z","deletedAt":null,"publishedAt":"2020-03-21T20:41:41.000Z","transactionHash":"0xbfab47b82ecebba6e9fc656935da117e29078d33b8ae11d03dbc25062e62f2ae","blockNumber":30317590,"logIndex":0,"updatedTransactionHash":"0xbfab47b82ecebba6e9fc656935da117e29078d33b8ae11d03dbc25062e62f2ae","updatedBlockNumber":30317590,"updatedLogIndex":0,"metadata":{"uri":"ipfs://bafkreic5yhxzt5axm4dfciyrfgwyhyik2jvykkurpke6d3lx33ipp7tdyi","type":"NOTE","content":{"tags":["post","c++","数据结构","ST表"],"type":"note","title":"RMQ问题——ST表算法","content":"---\ntitle: RMQ问题——ST表算法\nlink: RMQ问题——ST表算法\ncatalog: true\nlang: cn\ndate: 2020-03-21 20:41:41\nsubtitle: O(nlogn)复杂度预处理，可以实现O(1)复杂度的查询。\ntags:\n- c++\n- 数据结构\n- ST表\ncategories:\n- [笔记, 算法]\n---\n\n## ST表是什么\nST表是一个用来解决区间最值问题查询的算法\n它用**O(nlogn)复杂度预处理，可以实现O(1)复杂度的查询。**\n**缺点：无法支持在线修改**\n模板题：[ST表-洛谷](https://www.luogu.com.cn/problem/P3865)\n### 1.预处理\n用一个二维数组dp[i][j]表示下标为 i ~ i + 2^j^ - 1 的最值（最大or最小值）\n则\n①易知边界条件dp[i][0]为a[i]，既i~i的最大值为其本身\n②接下来是状态转移方程，如图\n\n> #### **1 << j 相当于 2^j^**\n![](https://img-blog.csdnimg.cn/20200321173713916.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n初始化代码\n```cpp\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        dp[i][0] = a[i];\n    }\n    for (int j = 1; (1<<j) <= n; j++) {\n        for (int i = 0; i + (1<<j) <= n; i++) {\n            dp[i][j] = max(dp[i][j-1], dp[i+(1<<(j-1))][j-1]);\n        }\n    }\n}\n```\n### 2.查询\n接下来就是查询，因为每次给出的查询区间长度不一定恰好为2^j，所以我们需要以下定理:（参考[大佬证明](https://blog.csdn.net/Hanks_o/article/details/77547380)）\n>##  **2^log(a)^>a/2**\n>### log(a)表示小于等于a的2的最大几次方\n>###### eg:log(4)=2,log(5)=2,log(6)=2,log(7)=2,log(8)=3,log(9)=3……\n若我们要查询a~b区间的最小值\n首先我们求出区间长度**len = b-a+1** 并令 **t = log(len)**\n由上述定理，**2^t^>len/2**\n也就是说，2^t在a,b区间的右半边\na,b的最小值，即为min（a ~ (a+2^t^-1), (b-2^t^+1) ~ t）如图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200321184107899.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n查询代码：\n```cpp\nll sol(int a, int b) {\n    int t = (int) (log(b-a+1.0)/log(2.0));\n    return max(dp[a][t], dp[b-(1<<t)+1][t]);\n}\n```\n### 3.完整代码\n题目：[ST表-洛谷](https://www.luogu.com.cn/problem/P3865)\n开了O2优化和快读才能ac\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int maxn = 100000;\ntypedef long long ll;\nll a[maxn];\nll dp[maxn][25];//此处以最大值为例\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        dp[i][0] = a[i];\n    }\n    for (int j = 1; (1<<j) <= n; j++) {\n        for (int i = 0; i + (1<<j) <= n; i++) {\n            dp[i][j] = max(dp[i][j-1], dp[i+(1<<(j-1))][j-1]);\n        }\n    }\n}\nll sol(int a, int b) {\n    int t = (int) (log(b-a+1.0)/log(2.0));\n    return max(dp[a][t], dp[b-(1<<t)+1][t]);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    init(n);\n    while(m--) {\n        int x,y;\n        cin >> x >> y;\n        cout << sol(x-1,y-1) << endl;\n    }\n    return 0;\n}\n```\n\n\n","sources":["xlog"],"attributes":[{"value":"RMQ-wen-ti-ST-biao-suan-fa-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/RMQ-wen-ti-ST-biao-suan-fa-md"],"date_published":"2020-03-21T20:41:41.000Z"}}}