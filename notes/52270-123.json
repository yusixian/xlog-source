{"characterId":52270,"noteId":123,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreicrn7nqvite5jqy4ufhdambps4ideg5cfpxno3dr7wjuhcyrnlh5y","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-04-22T16:07:46.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":26,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":26,"metadata":{"uri":"ipfs://bafkreicrn7nqvite5jqy4ufhdambps4ideg5cfpxno3dr7wjuhcyrnlh5y","type":"NOTE","content":{"tags":["post","c++","数据结构","最小生成树"],"type":"note","title":"图论——解决最小生成树问题(Kruskal算法&Prim算法)","content":"---\ntitle: 图论——解决最小生成树问题(Kruskal算法&Prim算法)\nlink: 图论——解决最小生成树问题(Kruskal算法&Prim算法)\ncatalog: true\nlang: cn\ndate: 2020-04-22 16:07:46  \nsubtitle: ——来自算法竞赛入门经典第2版（紫书）\ntags:\n- c++\n- 数据结构\n- 最小生成树\ncategories:\n- 数据结构\n---\n\n上周末的蓝桥杯省模拟赛时最后一题是一道最小生成树的题目，因为恰好在慕课上刚看到这个地方，所以现学了Prim算法，解决了这个题目(大概)，赛后就打算多琢磨琢磨这一类题目。[题目链接](https://blog.csdn.net/qq_45890533/article/details/105668209)\n最小生成树问题，是指给定无向图G=(V,E)，连接G中所有点，且边集是E的子集的树称为G的生成树(Spanning Tree)，而权值最小的生成树称为最小生成树(Minimal Spanning Tree，MST)。\n# 一、Kruskal算法\nKruskal算法易于编写，且效率很高\n紫书p356描述如下：\n\nKruskal算法的第一步是给所有边按照从小到大的顺序排列，这一步可以直接使用库函数qsort或者sort。接下来从小到大依次考察每条边(u, v)。\n\n - **情况1：u和v在同一个连通分量中，那么加入(u, v)后会形成环，因此不能选择。** \n - **情况2：如果u和v在不同的连通分量，那么加入(u, v)一定是最优的。** 为什么呢？下面用反证法——如果不加这条边能得到一个最优解T,则T+(u, v)一定有且只有一个环，而且环中至少有一条边(u', v')的权值大于或等于(u, v)的权值。删除该边后，得到的新树T' = T + (u, v) - (u', v')不会比T更差。因此，加入(u, v)不会比不加入差。\n\n下面是伪代码：\n\n```cpp\n把所有边(按权值)排序，记第i小的边为e[i](1 <= i < m)\n初始化MST为空\n初始化连通分量，让每个点自成一个独立的连通分量\nfor(int i = 0; i < m; i++) {\n\tif(e[i].u 和 e[i].v 不在同一个连通分量) {\n\t\t把边e[i]加入MST\n\t\t合并e[i].u和e[i].v所在的连通分量\n\t}\n}\n```\n在上面的伪代码中，最关键的地方在于 **“连通分量的查询与合并”** ：需要知道任意两个点是否在同一连通分量中，还需要合并这两个连通分量。\n有一种简介高效的算法可以用来处理这个问题——**并查集**\n此处指路大佬解释：[超有爱的并查集~](https://blog.csdn.net/niushuai666/article/details/6662911)\n**将每个连通分量看作一个集合**，该集合包含了连通分量中的所有点。这些点两两相通，而具体的连通方式无关紧要。在图中，**每个点都恰好属于一个连通分量**，对应到集合表示中，即为**每个元素恰好属于一个集合**。换句话说，**图的所有连通分量可以用若干个不相交集合来表示。**\n奉上自己的并查集板子\n```cpp\n#include <iostream>\nusing namespace std;\n#define div 1000000007\ntypedef long long ll;\nconst int maxn = 1001;\nint fa[maxn];//\ninline void init(int n) {\n    for (int i = 1; i <= n; i++)\n        fa[i] = i;\n}\nint find(int x) {//查询+路径压缩 把沿途的每个节点的父节点都设为根节点\n    return x == fa[x] ? x : (fa[x] = find(fa[x]));\n}\ninline void merge(int i, int j) {\n    fa[find(i)] = find(j);//前者的父节点设为后者\n}\n```\n有了并查集之后，Kruskal算法的完整代码便不难给出了。假设第i条边的两个端点序号和权值分别保存在u[i]，v[i]和 w[i]中，而排序后第i小的边的序号保存在r[i]中(间接排序，即排序的关键字是对象的“代号”，而不是对象本身),p为并查集\n## 完整代码：\n```cpp\nint cmp(const int i, const int j) {\treturn w[i] < w[j]; }\t//间接排序函数\nint find(int x) { return p[x] == x ? x : p[x] = find(p[x])}\t//并查集的find\nint Kruskal() {\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++) p[i] = i;\t//初始化并查集\n\tfor(int i = 0; i < m; i++) r[i] = i;\n\tsort(r,r+m,cmp);\n\tfor(int i = 0; i < m; i++) {\n\t\tint e = r[i];\n\t\tint x = find(u[e]);//找出一个端点所在集合编号\n\t\tint y = find(v[e]);//找出另一个端点所在集合编号\n\t\tif(x != y) {\t\t//若在不同集合，合并\n\t\t\tans += w[e];\n\t\t\tp[x] = y;\n\t\t}\n\t}\n\treturn ans;\n}\n```\n## 练习题：\n 题号 |题目名称(英文)|备注|\n|--|--|--|--|\n [hdu1863](http://acm.hdu.edu.cn/showproblem.php?pid=1863)| 畅通工程  | 最小生成树 板子题\n  [hdu1879](http://acm.hdu.edu.cn/showproblem.php?pid=1879)| 继续畅通工程 | 最小生成树 板子题\n [hdu1875](http://acm.hdu.edu.cn/showproblem.php?pid=1875)|畅通工程再续|最小生成树 板子题\n[洛谷P3366](https://www.luogu.com.cn/problem/P3366)| 【模板】最小生成树 |最小生成树 板子题\n\n### 1. [hdu1863畅通工程](http://acm.hdu.edu.cn/showproblem.php?pid=1863)\n\n> Problem Description\n省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。\nInput\n测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( < 100 )；随后的 N\n行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。\n Output\n对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。\n\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 105;\nint N,M,cnt;\nint u[maxn],v[maxn],w[maxn];\nint r[maxn],fa[maxn];\nbool cmp(const int r1, const int r2) {\n    return w[r1] < w[r2];\n}\nint find(int x) {\n    return fa[x] == x ? x : fa[x] = find(fa[x]);\n}\nint Kruskal() {\n    int ans = 0;\n    for(int i = 0; i < M; i++) fa[i] = i;//初始化并查集，让每个点自成一个连通分量\n    for(int i = 0; i < N; i++) r[i] = i;//存储边序号\n    sort(r, r+N, cmp);//将边从小到大按权值排序\n    for(int i = 0; i < N; i++) {\n        int e = r[i];\n        int x = find(u[e]);\n        int y = find(v[e]);\n        if(x != y) {\n            ans += w[e];\n            cnt++;\n            fa[x] = y;\n        }\n    }\n    return ans;\n}\nint main() {\n    while(cin >> N >> M) {\n        cnt = 0;\n        if(N == 0) break;\n        for(int i = 0; i < N; i++) {\n            cin >> u[i] >> v[i] >> w[i];\n        }\n        int ans = Kruskal();\n        if(cnt != M-1) cout << \"?\" << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}\n```\n### 2.[hdu1879继续畅通工程](http://acm.hdu.edu.cn/showproblem.php?pid=1879)\n这题相比上题来说，就将已经建好了的道路花费置为0即可，同时注意本题输入输出好像都不能用cincout,会超时。\n> Problem Description\n省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建道路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全省畅通需要的最低成本。\nInput\n测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( 1< N < 100 )；随后的 N(N-1)/2 行对应村庄间道路的成本及修建状态，每行给4个正整数，分别是两个村庄的编号（从1编号到N），此两村庄间道路的成本，以及修建状态：1表示已建，0表示未建。\n当N为0时输入结束。\nOutput\n每个测试用例的输出占一行，输出全省畅通需要的最低成本。\n\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 5008;\nint fa[101];\nint find(int x) {\n    return fa[x] == x ? x : fa[x] = find(fa[x]);\n}\nstruct Edge {\npublic:\n    int u, v, w;\n    bool operator<(const Edge &a)const{ \n        return w < a.w;\n    }\n}E[maxn];\n\nint main() {\n    int N;\n    while(scanf(\"%d\", &N) != EOF) {\n        int ans = 0;\n        if(N == 0) break;\n        int M = N*(N-1)/2;\n        for(int i = 1; i <= M; ++i) {\n            int flag;\n            scanf(\"%d%d%d%d\", &E[i].u, &E[i].v, &E[i].w, &flag);\n            if(flag) E[i].w = 0;\n        }\n        for(int i = 1; i <= N; ++i) fa[i] = i;//初始化并查集，让每个点自成一个连通分量\n        sort(E+1,E+1+M);//将边从小到大按权值排序\n        for(int i = 1; i <= M; ++i) {\n            int x = find(E[i].u);\n            int y = find(E[i].v);\n            if(x != y) {\n                fa[x] = y;\n                ans += E[i].w;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n### 3.[hdu1875畅通工程再续](http://acm.hdu.edu.cn/showproblem.php?pid=1875)\n先输入所有顶点，再判断每两个顶点是否可以构成合适的边\n> Problem Description\n相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。\n Input\n输入包括多组数据。输入首先包括一个整数T(T <= 200)，代表有T组数据。\n每组数据首先是一个整数C(C <= 100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 <= x, y <= 1000的整数。\n Output\n每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”.\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int maxn = 5008;\ntypedef long long ll;\nstruct Point {\n    int x,y;\n} V[101];\nstruct Edge {\npublic:\n    int u, v;\n    double w;\n    bool operator<(const Edge &a)const{ \n        return w < a.w;\n    }\n}E[maxn];\nint fa[105];\nint find(int x) {\n    return fa[x] == -1 ? x : fa[x] = find(fa[x]);\n}\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while(T--) {\n        int N;\n        scanf(\"%d\", &N);\n        for(int i = 0; i < N; ++i) {\n            scanf(\"%d%d\", &V[i].x, &V[i].y);\n        }\n        int k = 0;\n        for(int i = 0; i < N-1; ++i) {\n            for(int j = i+1; j < N; ++j) {\n                double d = sqrt( (V[i].x-V[j].x)*(V[i].x-V[j].x) + \n                (V[i].y-V[j].y)*(V[i].y-V[j].y) );\n                if (d <= 1000 && d >= 10) {\n                    E[k].u = i;\n                    E[k].v = j;\n                    E[k].w = d*100;\n                    k++;\n                }\n            }\n        }\n        for(int i = 0; i < N; ++i) fa[i] = -1;//初始化并查集，让每个点自成一个连通分量\n        sort(E,E+k);//将边从小到大按权值排序\n        double ans = 0;\n        int cnt = 0;\n        for(int i = 0; i < k; ++i) {\n            int x = find(E[i].u);\n            int y = find(E[i].v);\n            if(x != y) {\n                fa[x] = y;\n                ans += E[i].w;\n                cnt++;\n            }\n        }\n        if (cnt == N-1) printf(\"%.1f\\n\",ans);\n        else printf(\"oh!\\n\");\n    }\n    return 0;\n}\n\n```\n\n### 4.[洛谷P3366【模板】最小生成树 ](https://www.luogu.com.cn/problem/P3366)\n板子题\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int maxm = 200000;\nint fa[5005];//最大顶点数5000\nint N,M,cnt;//顶点数 边数\nstruct edge {\n    int u,v,w;\n    bool operator<(const edge& a) const {\n        return w < a.w;\n    }\n} E[maxm];//最大边数maxn\nint find(int x) {\n    return fa[x] == -1 ? x : fa[x] = find(fa[x]);\n}\nint Kruskal() {\n    for(int i = 0; i < N; ++i) fa[i] = -1;\n    int ans = 0;\n    sort(E,E+M);\n    for(int i = 0; i < M; ++i) {\n        int x = find(E[i].u);\n        int y = find(E[i].v);\n        if(x != y) {\n            fa[x] = y;\n            ans += E[i].w;\n            cnt++;\n        }\n    }\n    if(cnt == N-1) return ans;\n    else return -1;\n}\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    for(int i = 0; i < M; ++i) {\n        scanf(\"%d%d%d\", &E[i].u, &E[i].v,&E[i].w);\n    }\n    int ans = Kruskal();\n    if(ans == -1) printf(\"orz\\n\");\n    else printf(\"%d\\n\",ans);\n    return 0;\n}\n```\n# 二、Prim算法\n[来自陈越姥姥的数据结构](https://www.icourse163.org/learn/ZJU-93001#/learn/content?type=detail&id=1214143639&cid=1217772500)\nPrim算法基本思路——从一个根节点开始，让一棵小树长大。与Dijkstra算法相近。\nDijkstra算法伪代码：\n```cpp\nvoid Dijkstra(Vertex s) {\n\twhile(1) {\n\t\tV = 未收录顶点中dist最小者\n\t\tif (这样的V不存在)\n\t\t\tbreak;\n\t\tcollected[V] = true;//将V收录\n\t\tfor(V的每个邻接点W) {\n\t\t\tif(collected[W] == false && dist[V] + E(V,W) < dist[W]) {\n\t\t\t\tdist[W] = dist[V]+E<V,W>;\n\t\t\t\tpath[W] = V;\n\t\t\t} \n\t\t}\n}\n```\nPrim算法伪代码：\n\n```cpp\nvoid Prim(Vertex s) {\n\twhile(1) {\n\t\tV = 未收录顶点中dist最小者\n\t\tif (这样的V不存在)\n\t\t\tbreak;\n\t\t将V收录进MST\n\t\tfor(V的每个邻接点W) {\n\t\t\tif(W未被收录 && E(V,W) < dist[W]) {\n\t\t\t\tdist[W] = E<V,W>;\n\t\t\t\tparent[W] = V;\n\t\t\t} \n\t\t}\n}\n```\n## Prim算法完整代码\n```cpp\ndouble edge[maxn][maxn];//存边的权值~\nint vis[maxn];//该点是否已访问过\ndouble dist[maxn];\ndouble ans;\ndouble Prim() {\n    for(int i = 2; i <= n; i++) {\n        dist[i] = edge[1][i];//初始化dist为根结点1到所有点的距离\n    }\n    vis[1] = 1;////收录初始点1 vis[i] == 0表示还未被收录\n    for(int i = 2; i <= n; i++) {\n        int min = INF;\n        int v = -1;\n        for(int j = 2; j <= n; j++) {//找v————未收录顶点中dist最小者\n            if(!vis[j] && dist[j] < min) {\n                min = dist[j];\n                v = j;\n            }\n        }\n        if(v != -1) {//找到了v~收入MST\n            vis[v] = 1;\n            ans += dist[v];\n            for(int j = 2;j <= n; j++) {//更新距离dist\n                if(!vis[j] && edge[v][j] < dist[j]) {//当这点未被访问且到任意一点的距离比现在到树的距离小就更新\n                    dist[j] = edge[v][j];\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n","sources":["xlog"],"attributes":[{"value":"tu-lun--jie-jue-zui-xiao-sheng-cheng-shu-wen-ti-Kruskal-suan-fa-Prim-suan-fa-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/tu-lun--jie-jue-zui-xiao-sheng-cheng-shu-wen-ti-Kruskal-suan-fa-Prim-suan-fa-md"],"date_published":"2020-04-22T16:07:46.000Z"}}}