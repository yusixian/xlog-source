{"characterId":52270,"noteId":119,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreiecorhuvjxmnxuzmiiilpqayrinl2ivhw45a3yx23y5zsjv3iglo4","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-04-07T23:10:09.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":22,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":22,"metadata":{"uri":"ipfs://bafkreiecorhuvjxmnxuzmiiilpqayrinl2ivhw45a3yx23y5zsjv3iglo4","type":"NOTE","content":{"tags":["post","c++","数据结构","哈夫曼树","并查集"],"type":"note","title":"数据结构学习笔记＜6＞ 堆与哈夫曼树与并查集","content":"---\ntitle: 数据结构学习笔记＜6＞ 堆与哈夫曼树与并查集\nlink: 数据结构学习笔记＜6＞ 堆与哈夫曼树与并查集\ncatalog: true\nlang: cn\ndate: 2020-04-07 23:10:09\nsubtitle: MOOC浙江大学的数据结构慕课学习记录——堆与哈夫曼树\ntags:\n- c++\n- 数据结构\n- 哈夫曼树\n- 并查集\ncategories:\n- [笔记, 数据结构]\n---\n\n# 一、堆\n## 1.堆是什么\n堆（**Heap**),是一个可以被看做一棵完全二叉树的数组对象，有以下性质：\n - 任意节点的值是其子树所有结点中的最大值/最小值（有序性）\n - 堆总是一棵用数组表示的完全二叉树。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020040722374694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n## 2.最大堆的操作函数\n定义\n```cpp\ntypedef struct HeapStruct *MaxHeap;\nstruct HeapStruct {\n\tElementType *Elements;//存储堆元素的数组\n\tint Size;//当前元素个数\n\tint Capacity;//最大容量\n};\n```\n\n### (1)空最大堆的创建(Create函数)\n```cpp\nMaxHeap Create(int MaxSize) {\n\tMaxHeap H = malloc(sizeof(struct HeapStruct) );\n\tH->Elements = malloc( (MaxSize+1) * sizeof(ElementType));//+1是由于我们从下标1开始存储\n\tH->Size = 0;\n\tH->Capacity = MaxSize;\n\tH->Elements[0] = MaxData;//下标0设为\"哨兵\" 为大于堆中所有可能元素的值，便于之后的操作\n\treturn H;\n}\n```\n### (2)最大堆的插入(Insert函数)\n插入一个元素时与其父结点比较，若插入元素更大则两者交换，再与其父节点比较，如此直到插入元素比父结点小为止。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020040721541166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n```cpp\nvoid Insert(MaxHeap H, ElementType item) {\n\tint i;\n\tif(IsFull(H)) {\n\t\tprintf(\"最大堆已满\");\n\t\treturn;\n\t}\n\ti = ++H->Size;//i指向插入后队中最后一个元素的位置。\n\tfor(; H->Elements[i/2] < item; i /= 2) {//当item的父结点的值小于item值循环才继续\n\t\tH->Elements[i] = H->Elements[i/2];//向下过滤结点（）\n\t}\n\tH->Elements[i] = item;//将item插入\n}\n```\n### (3)最大堆的删除(Delete函数)\n取出根节点（最大值）元素，同时在堆中删除根结点，保证其新的根节点仍是堆中的最大值。\n - 用最大堆中最后一个元素，作为新的根节点，删除原来的最后一个元素\n - 看根结点左右儿子是否比其大，是则继续往下过滤\n```cpp\nElementType DeleteMax(MaxHeap H) {\n\tint Parent,Child;//父结点，孩子结点\n\tElementType MaxItem, temp;\n\tif(IsEmpty(H) ) {\n\t\tprintf(\"最大堆已空\");\n\t\treturn;\n\t}\n\tMaxItem = H->Elements[1]; //取出根结点最大值，暂存在MaxItem中\n\ttemp = H->Elements[H->Size--];//存储最后一个元素，然后size--\n\tfor (Parent = 1; Parent*2 <= H->Size; Parent = Child) {\n\t\tChild = Parent * 2;//Child此时为Parent的左孩子\n\t\tif (Child != H->Size && H->Elements[Child] < H->Elements[Child+1] ) {\n\t\t\tChild++;\t//当且仅当右孩子存在且其值比左孩子大时，Child变成右孩子的下标\n\t\t} \n\t\tif (temp >= H->Elements[Child] ) break;//temp找到了应该放的地方\n\t\telse //用孩子结点的值取代父结点\n\t\t\tH->Elements[Parent] = H->Elements[Child];\n\t}\n\tH->Elements[Parent] = temp;\n\treturn MaxItem;//返回删除前最大值\n}\n```\n\n### (3)从已有元素创建最大堆\n将已经存在的N个元素按最大堆的要求存放在一个一维数组中。\n\n - 法1 通过插入操作，将N个元素**一个个插入到一个空的最大堆中**，时间复杂度最大为O(NlogN)。\n - 法2 在**线性时间复杂度**下建立最大堆。\n - （1）将N个元素按输入顺序存入，使其先满足**完全二叉树的结构特性**\n - （2）调整各结点位置，使其满足最大堆的**有序特性**\n\n建堆时间复杂度O(n)，为书中各结点的高度和\n 从倒数第一个有儿子的结点开始，其肯定有左儿子\n 将定义中的Elements数组改成Data数组存储已有元素\n```cpp\nvoid PercDown(MaxHeap H, int p) {//将H中以H->Data[p]为根的子堆调整为最大堆 原理同删除操作\n\tint Parent,Child;\n\tElementType X;\n\tX = H->Data[p];//取出根结点值\n\tfor(Parent = p; Parent*2 <= H->Size; Parent = Child) {\n\t\tChild = Parent * 2;\n\t\tif( Child != H->Size && H->Data[Child] < H->Data[Child+1]) {\n\t\t\tChild++;\n\t\t}\n\t\tif(X >= H->Data[Child]) break;//找到了合适位置\n\t\telse \n\t\t\tH->Data[Parent] = H->Data[Child];\n\t}\n\tH->Data[Parent] = X;\n}\nvoid BuildHeap(MaxHeap H) {//调整H->Data[]中的元素使其满足最大堆的有序性，此处假设所有H->Size个元素都已存在H->Data[]中\n\tint i;\n\t//从最后一个结点的父节点开始，到根结点1\n\tfor(i = H->Size/2; i > 0; i--)\n\t\tPercDown(H,i);\n}\n```\n\n# 二、哈夫曼树\n## 1.哈夫曼树是什么\n**带权路径长度(WPL)**：设二叉树有**n个叶子结点**，每个叶子结点带有权值w~k~，从根结点到每个叶子结点的长度为l~k~，则每个叶子结点的带权路径长度之和就是：WPL = $\\sum_{k=1}^n$w~k~ l~k~.\n**最优二叉树**，也称为**哈夫曼树**(Huffman Tree):WPL最小的二叉树，其特点为：\n\n - 没有度为1的结点\n - n个叶子结点的哈夫曼树共有2n-1个结点\n - 哈夫曼树的任意非叶结点的**左右子树交换后仍是哈夫曼树**\n - 同一组权值，是可能存在不同构的两棵哈夫曼树的\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200407230317308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n## 2.哈夫曼树的操作\n哈夫曼树的构造，每次将权值最小的两棵二叉树合并\n主要问题：如何选取两个最小的？**利用最小堆！**\n```cpp\ntypedef struct TreeNode *HuffmanTree;\nstruct TreeNode {\n\tint Weight;\n\tHuffmanTree Left,Right;\n};\nHuffmanTree Huffman(MinHeap H) {\n\t//假设H->Size个权值已经存在了H->Elements[]->Wight里\n\tint i;\tHuffmanTree T;\n\tBuildMinHeap(H);//将H->Elements[]按权值调整为最小堆\n\tfor(i = 1; i < H->Size; i++) {//做H->Size-1次合并\n\t\tT = malloc(sizeof(struct TreeNode));//建立新结点\n\t\tT->Left = DeleteMin(H);//从最小堆中删除一个结点，作为新T的左子结点\n\t\tT->Right = DeleteMin(H);//从最小堆中删除一个结点，作为新T的右子结点\n\t\tT->Weight = T->Left->Weight + T->Right->Weight;\n\t\tInsert(H,T);//将新T插入最小堆\n\t}\n\tT = DeleteMin(H);\n\treturn T;\n}\n```\n## 3.哈夫曼树的应用——哈夫曼编码\n如何进行编码，可以使总编码空间最少？\n**出现频率高的字符用的编码短些，出现频率低的字符编码可以长一些，同时要避免二义性。**\n**前缀码(prefix code)：** 任何字符的编码都不是另一字符的前缀，即可避免二义性\n可以构造一个二叉树用于编码，左右分支分别为0、1，当所有的字符都在叶结点上的时候即可\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200407230816301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n**就可以用哈夫曼树！**\n# 三、集合\n关于集合这一块主要就是并查集，之前有学过这篇博客写的超棒：[超有爱的并查集~(原博挂了，转载)](https://blog.csdn.net/shensiback/article/details/80089461?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-1.no_search_link)\n所以在这儿就不多说啦~\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200412195059228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020041219504180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n### ~  并查集板子 ~\n```cpp\n#include <iostream>\n#include <set>\nusing namespace std;\nconst int maxn = 1000000;\nint fa[maxn];\nint ans[maxn];\nvoid init(int n) {\n    for (int i = 1; i <= n; i++) {\n        fa[i] = i;\n    }\n}\nint find(int x) {//查询+路径压缩 找根节点并将沿途每个结点的父节点都设为根节点\n    return x == fa[x]? x : (fa[x] = find(fa[x]));\n}\ninline void merge(int a, int b) {\n    fa[find(a)] = find(b);\n}\nint main() {\n    int m, n, k, x;\n    cin >> m >> n >> k;\n    x = n*m;\n    init(x);\n    for (int i = 0; i < k; i++) {\n        int a,b;\n        cin >> a >> b;\n        merge(a, b);\n    }\n    for(int i = 1; i <= x; i++) {\n        ans[find(i)] = 1;\n    }\n    int cnt = 0;\n    for (int i = 1; i <= x; i++) {\n        if(ans[i] == 1) cnt++;\n    }\n    cout << cnt << endl;\n    return 0;\n}\n```\n","sources":["xlog"],"attributes":[{"value":"shu-ju-jie-gou-xue-xi-bi-ji-6-dui-yu-ha-fu-man-shu-yu-bing-cha-ji-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/shu-ju-jie-gou-xue-xi-bi-ji-6-dui-yu-ha-fu-man-shu-yu-bing-cha-ji-md"],"date_published":"2020-04-07T23:10:09.000Z"}}}