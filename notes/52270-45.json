{"characterId":52270,"noteId":45,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreicedkb3wralqwa3doc44wz3rqa3y2hhrwqpq3tbngbdxvv7poxkly","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:39:04.000Z","updatedAt":"2023-04-05T11:28:48.000Z","deletedAt":null,"publishedAt":"2022-01-24T14:30:17.000Z","transactionHash":"0xdc576b85b753d220cd2851aa2bc5e951b6f739ada0a82dfd613ec82afbd0296e","blockNumber":30317649,"logIndex":11,"updatedTransactionHash":"0x08cc75a19a6fc6185486bf238cbb350a46d69d8cb6dcb1fefb02872bb7420039","updatedBlockNumber":30335033,"updatedLogIndex":0,"metadata":{"uri":"ipfs://bafkreicedkb3wralqwa3doc44wz3rqa3y2hhrwqpq3tbngbdxvv7poxkly","type":"NOTE","content":{"tags":["post","前端","JavaScript","Node.js","青训营"],"type":"note","title":"青训营 |「Node.js 与前端开发实战」","content":"---\ntitle: 青训营 |「Node.js 与前端开发实战」\nlink: note/front-end/bytedance-note/nodejs-develop\ncatalog: true\ndate: 2022-01-24 14:30:17\nsubtitle: 这节课从Node.js介绍起，实现了其编写Http Server的一个实战（并用Promise优化回调，还对SSR有了一定的了解），并在延伸话题里老师也给出了一些建议与拓展阅读，好欸~\nlang: cn\ntags:\n- 前端\n- JavaScript\n- Node.js\ncategories:\n- [笔记, 青训营笔记]\n---\n#  本节课重点内容\n\n## Node.js 的应用场景（why）\n\n- 前端工程化\n\n  - 早期的jQuery等库都是直接在页面中引入，后来模块化逐渐成熟，Node.js赋予了开发者在浏览器外运行代码的能力，前端逐渐模块化、\n\n  - Bundle：[webpack](https://www.webpackjs.com/)、[Vite](https://cn.vitejs.dev/)、[esbuild](https://esbuild.docschina.org/)、[Parcel](https://www.parceljs.cn/)等\n\n  - Uglify：[UglifyJS](https://lisperator.net/uglifyjs/)\n\n  - Transplie：[babeljs](https://babeljs.io/)、[TypeScript](https://www.tslang.cn/)\n\n    >个人理解：Transplie就是将ES6这样最新的语法转译成低版本的写法，实现浏览器兼容  \n\n  - 其他语言加入前段工程化的竞争：[esbuild](https://esbuild.docschina.org/)、[Parcel](https://www.parceljs.cn/) 、prisma等\n  - 现状：Node.js难以替代\n\n- Web服务端应用\n\n  - 学习曲线平缓，**开发效率较高**\n  - **运行效率接近常见的编译语言**\n  - 社区生态丰富及**工具链成熟**（npm，V8 inspector）\n  - 与前端结合的场景会有优势（SSR，**同构前端应用**。 编写页面 和 后端数据的获取和填充都由 JavaScript 来完成）\n  - 现状：竞争激烈，Node.js 有自己独特的优势\n\n- Electron**跨端**桌面应用\n\n  - 商业应用: vscode、slack、discord、zoom\n  - 大型公司内的效率工具\n  - 现状:大部分场景在选型时，都值得考虑\n\n## Node.js运行时结构（what）\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4e16f59c5ba42b39cc07156fb27ef84~tplv-k3u1fbpfcp-watermark.image?)\n\n- N-API：用户代码中利用npm安装的一些包\n- [V8](http://nodejs.cn/learn/the-v8-javascript-engine)：JavaScript Runtime，诊断调试工具(inspector)\n- [libuv](https://luohaha.github.io/Chinese-uvbook/source/introduction.html)：eventloop (事件循环)，syscall (系统调用)\n  - 举例：用node-fetch发起请求时\n  - 整个过程中底层会调用非常多的c++代码\n\n**特点**\n\n- 异步I/O：\n\n  ```js\n  setTimeout(() => {\n      console.log('B');\n  })\n  console.log('A');\n  ```\n\n  - 一个常见场景：**读取文件**时。当Node.js执行I/O操作时，会在响应返回后恢复操作，而**不是阻塞线程并占用额外内存等待**。（内存占用更少）\n\n    ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68794c8de61049ed90ecc828b3436dc5~tplv-k3u1fbpfcp-watermark.image?)\n\n- 单线程\n\n  - worker_thread可以起一个独立线程，但每个线程的模型没有太大变化\n\n    ```js\n    function fibonacci(num:number):number {\n    \tif(num === 1 || num === 2) {\n            return 1;\n        }\n        return fibonacci(num-1) + fibonacci(num-2);\n    }\n    fibonacci(42)\n    fibonacci(43)\n    ```\n\n  - JS单线程\n\n    - 实际:JS线程 + uv线程池（4个线程） + V8任务线程池 + V8 Inspector线程\n\n  - 优点：不用考虑多线程状态同步问题，**也就不需要锁**。同时还能比较高效地利用系统资源;\n\n  - 缺点：**阻塞会产生更多负面影响**、异步问题、延时有要求的场景需要考虑。\n\n    - 解决办法：多进程或多线程\n\n- 跨平台（大部分功能、api）\n\n  - 想用linux上的Socket，而不同平台上调用的又不一样，只需：\n\n    ```js\n    const net = require('net')\n    const socket = new net.Socket('/tmp/socket.sock')\n    ```\n\n  - Node.js跨平台 + **JS无需编译环境**（+ **Web跨平台** + 诊断工具跨平台）\n    - = **开发成本低**（大部分场景无需担心跨平台问题），整体学习成本低\n\n## 编写Http Server （how）\n\n### 安装Node.js\n\n- Mac, Linux推荐使用nvm。**多版本管理。**\n- Windows推荐nvm4w或是[官方安装包](https://nodejs.org/en/download/)。\n- 安装慢，安装失败的情况，设置安装源\n  - NVM_ NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node nvm install 16\n\n### 编写Http Server + Client, 收发GET, POST请求\n\n- 前提：安装好Node.js，以管理员权限打开cmd下转至当前文件目录下\n\n#### Http Server\n\n- 首先编写一个server.js，如下\n\n  - [`createServer`](https://nodejs.org/api/http.html#httpcreateserveroptions-requestlistener) 说明\n\n    >req 请求，res响应\n\n    [`server.listen`](https://nodejs.org/api/http.html#serverlisten) 说明 \n\n    > port 要监听的端口号，成功后的回调函数\n\n  - ```js\n    const http = require('http');\n    const server = http.createServer((req, res) => {\n        res.end('hello'); // 响应直接就是hello\n    });\n    const port = 3000;\n    server.listen(port, () => {\n        console.log(`server listens on:${port}`);\t// 监听3000端口\n    })\n\n- 使用node启动，此时输入localhost:3000就可以看到hello\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86eaa345e5ea499ca25569b7b2cbd9d3~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7baced8533a046adb95f1acd0a92bd87~tplv-k3u1fbpfcp-watermark.image?)\n\n- 改为JSON版\n```js\n  const server = http.createServer((req, res) => {\n      // receive body from client\n      const bufs = [];    // 取传的数据\n      req.on('data', data => {\n          bufs.push(data);\n      });\n      req.on('end', () => {\n          const buf = Buffer.concat(bufs).toString('utf-8');\n          let msg = 'Hello';\n          try {\n              reqData = JSON.parse(buf);\n              msg = reqData.msg;\n          } catch (err) {\n              res.end('invalid json');\n          }\n          // response\n          const responseJson = {\n              msg: `receive：${msg}`\n          }\n          res.setHeader('Content-Type', 'application/json');\n          res.end(JSON.stringify(responseJson));\n      });\n  });\n  ```\n\n  - ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25a3c3639d4947b290df7623d97a87bb~tplv-k3u1fbpfcp-watermark.image?)\n  - ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a752766165644b1c8bf4e1493a482c6a~tplv-k3u1fbpfcp-watermark.image?)\n\n\n#### Http Client\n\n- [`http.request(url[, options\\][, callback])`](http://nodejs.cn/api/http/http_request_url_options_callback.html)\n\n```js\nconst http = require('http');\nconst body = JSON.stringify({ msg: 'hello from my own client' });\n// [url] [option] [callback]\nconst req = http.request('http://127.0.0.1:3000', {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': body.length,\n    },\n}, (res) => {   // 响应体   \n    const bufs = [];\n    res.on('data', data => {\n        bufs.push(data);\n    });\n    res.on('end', () => {\n        const buf = Buffer.concat(bufs);\n        const receive = JSON.parse(buf);\n        console.log('receive json.msg is:', receive);\n    });\n})\nreq.end(body);\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ccdb0821cb0403093a6192544066cbc~tplv-k3u1fbpfcp-watermark.image?)\n\n#### Promisify\n\n可以用 [Promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise) + [async和await](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Async_await) 重写这两个例子（why？）\n\n> 当 [await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) 关键字与异步函数一起使用时，它的真正优势就变得明显了 —— 事实上， **await 只在异步函数里面才起作用**。它可以放在任何异步的，基于 promise 的函数之前。它会暂停代码在该行上，直到 promise 完成，然后返回结果值。在暂停的同时，其他正在等待执行的代码就有机会执行了\n>\n> `async/await` 让你的代码看起来是同步的，在某种程度上，也使得它的行为更加地同步。 `await` 关键字会阻塞其后的代码，直到promise完成，就像执行同步操作一样。它确实可以允许其他任务在此期间继续运行，但您自己的代码被阻塞。\n\n- 回调写太多容易找不到，不宜维护\n\n  ```js\n  function wait(t) {\n      return new Promise((resolve, reject) => {\n          setTimeout(() => {\n              resolve();\n          }, t);\n      });\n  }\n  wait(1000).then(() => { console.log('get called'); });\n  ```\n\n- 并不是所有回调都适合改写成Promise\n\n  - 适合只被调用一次的回调函数\n\n  ```js\n  const server = http.createServer(async (req, res) => {  // 注意这里的async\n      // receive body from client 改成了Promise形式\n      const msg = await new Promise((resolve, reject) => {    //执行完再交给msg\n          const bufs = [];    \n          req.on('data', data => {\n              bufs.push(data);\n          });\n          req.on('error', (err) => {\n              reject(err);\n          })\n          req.on('end', () => {\n              const buf = Buffer.concat(bufs).toString('utf-8');\n              let msg = 'Hello';\n              try {\n                  reqData = JSON.parse(buf);\n                  msg = reqData.msg;\n              } catch (err) {\n                  // \n              }\n              resolve(msg);\n          });\n      });\n      // response\n      const responseJson = {\n          msg: `receive：${msg}`\n      }\n      res.setHeader('Content-Type', 'application/json');\n      res.end(JSON.stringify(responseJson));\n  });\n  ```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dbdf3381e8a493983e2d317ed9c5a43~tplv-k3u1fbpfcp-watermark.image?)\n\n### 编写静态文件服务器\n\n编写一个简单的静态服务，接受用户发过来的http请求，拿到图片的url约定为静态文件服务器磁盘上对应的路径，再把具体内容返回给用户。这次除了 [http](http://nodejs.cn/api/http.html) 模块，还需要 [fs](http://nodejs.cn/api/fs.html) 模块和 [path](http://nodejs.cn/api/path.html) 模块\n\n先编写一个简单的 index.html，放于static目录下\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4896177811004202ac15fc53ea8746ee~tplv-k3u1fbpfcp-watermark.image?)\n\n#### static_server.js\n\n```js\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst url = require('url');\n// __dirname是当前这个文件所在位置, ./为当前文件所在文件夹 folderPath即为static文件夹相对于当前文件路径\nconst folderPath = path.resolve(__dirname, './static');\n\nconst server = http.createServer((req, res) => {  // 注意这里的async\n    // expected http://127.0.0.1:3000/index.html\n    const info = url.parse(req.url);\n\n    // static/index.html\n    const filepath = path.resolve(folderPath, './'+info.path);\n    console.log('filepath', filepath);\n    // stream风格的api，其内部内存使用率更好\n    const filestream = fs.createReadStream(filepath);\n    filestream.pipe(res);\n});\nconst port = 3000;\nserver.listen(port, () => {\n    console.log(`server listens on:${port}`);\n})\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/002356c010394791918d5d7deb0005ea~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eb03ea97a7a4263835a1261bb207849~tplv-k3u1fbpfcp-watermark.image?)\n\n- 与高性能、可靠的服务相比，还差什么?\n\n1. **CDN**：**缓存+加速**\n2. **分布式**储存，**容灾**（服务器挂了也能正常服务）\n\n### 编写React SSR服务\n\n- SSR (server side rendering)有什么特点？\n- 相比传统HTML模版引擎:避免重复编写代码\n- 相比SPA (single page application)：首屏渲染更快，SEO（搜索引擎优化）友好\n- 缺点：\n  - 通常qps（每秒查询率）较低，前端代码编写时需要考虑服务端渲染情况\n  - 编写比较难，编写js还要考虑前端中的表现\n\n#### 安装React\n\n```\nnpm init\nnpm i react react-dom\n```\n\n#### 编写示例\n\n```react\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst http = require('http');\nfunction App(props) {\n    return React.createElement('div', {}, props.children || 'Hello');\n}\nconst server = http.createServer((req, res) => {\n    res.end(`\n        <!DOCTYPE html>\n        <html>\n            <head>\n                <title>My Application</title>\n            </head>\n            <body>\n                ${ReactDOMServer.renderToString(\n                    React.createElement(App, {}, 'my_content'))}\n                <script>\n                    alert('yes');\n                </script>\n            </body>\n        </html>\n    `);\n})\nconst port = 3000;\nserver.listen(port, () => {\n    console.log('listening on: ', port);\n})\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/258be264f1104f669d64d5ee1883dafe~tplv-k3u1fbpfcp-watermark.image?)\n\n- SSR难点\n\n1. 需要处理打包代码\n2. 需要思考前端代码在服务端运行时的逻辑\n3. 移除对服务端无意义的副作用，或重置环境\n\n### 适用inspector进行调试、诊断\n\n- V8 Inspector:开箱即用、特性丰富强大、与前端开发一致、跨平\n  台\n\n  - `node -- inspect`\n  - `open http://localhost:9229/json`\n\n  ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73f242fda3c741b6abdb6a9b8cceab2e~tplv-k3u1fbpfcp-watermark.image?)\n\n- 场景:\n  - 查看console.log内容\n  - breakpoint\n  - 高CPU、死循环: cpuprofile\n  - 高内存占用：heapsnapshot（堆快照）\n  - 性能分析\n\n### 部署简介\n\n写完了，如何部署到生产环境捏？\n\n- 部署要解决的问题\n\n  - 守护进程：当进程退出时，重新拉起\n\n  - 多进程：cluster便捷地利用多进程\n  - 记录进程状态，用于诊断\n\n- 容器环境\n\n  - 通常有健康检查的手段，只需考虑多核cpu利用率即可\n\n## 延伸话题\n\n### 快速了解Node.js代码\n\n[Node. js Core贡献入门](https://github.com/joyeecheung/talks/blob/master/code_and_learn_2019_beijing/contributing-to-node-core.pdf)\n\n- 好处\n  - 从使用者的角色逐步理解底层细节，可以解决更复杂的问题，\n  - 自我证明，有助于职业发展;\n  - 解决社区问题，促进社区发展;\n- 难点:\n  - 花时间（真实）\n\n### 编译Node.js\n\n- 为什么要学习编译Node.js\n  - 认知:黑盒到白盒，发生问题时能有迹可循\n  - 贡献代码的第一步\n- 如何编译\n  - ./configure &&make install\n  - 演示：给net模块添加自定义属性\n\n### 诊断/追踪\n\n- 诊断是一个低频、重要同时也相当有挑战的方向。是企业衡量自己能否依赖一个门语言的重要参考。\n- 技术咨询行业中的热门角色。\n- 难点:\n  - 需要了解Node.js底层，需要了解操作系统以及各种工具\n  - 需要经验\n\n### WASM, NAPI\n\n- Node.js(因为V8)是执行WASM代码的天然容器，和浏览器WASM是同一运行时，同时Node.js支持WASI。\n- NAPI执行C接口的代码(C/C++/Rust...)，同时能保留原生代码的性能。\n- 不同编程语言间通信的一种方案。\n\n## 总结感想\n\n本节课从Node.js介绍起，实现了其编写Http Server的一个实战（并用Promise优化回调，还对SSR有了一定的了解），并在延伸话题里老师也给出了一些建议与拓展阅读，好欸~\n\n> 本文引用的内容大部分来自欧阳亚东老师的课以及MDN。","sources":["xlog"],"summary":"Node.js 的应用场景（why） 前端工程化\n\n早期的jQuery等库都是直接在页面中引入，后来模块化逐渐成熟，Node.js赋予了开发者在浏览器外运行代码的能力，前端逐渐模块化、\n\nBundle：webpack、Vite、esbuild、Parcel等\n\nUgl…","attributes":[{"value":"nodejs-developmd","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/nodejs-developmd"],"date_published":"2022-01-24T14:30:17.000Z"}}}