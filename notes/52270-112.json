{"characterId":52270,"noteId":112,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreihdrfxgzphizqizteqnpk5q72euad3ngs6fe3ilsmxrqs5pdw3vuy","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-10-09T15:03:23.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":15,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":15,"metadata":{"uri":"ipfs://bafkreihdrfxgzphizqizteqnpk5q72euad3ngs6fe3ilsmxrqs5pdw3vuy","type":"NOTE","content":{"tags":["post","链表","c++","数据结构"],"type":"note","title":"模板类封装(1)——单链表","content":"---\ntitle: 模板类封装(1)——单链表\nlink: 模板类封装(1)——单链表\ncatalog: true\nlang: cn\ndate: 2020-10-09 15:03:23 \nsubtitle: 自封装链表模板类,c++实现\ntags:\n- 链表\n- c++\n- 数据结构\ncategories:\n- [笔记, 数据结构]\n---\n加入了ReverseList函数，逆转单链表操作\n改了个bug，逆转链表时特判一个结点的情况\n又改了N个bug，特判空链表的情况\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n\n试试模板类加上数据结构\n肯定还是会有遗漏的地方的，欢迎指正\n不多说，上代码\nps:nullptr是c++11特性，使用时需注意\n\n\n# 结点定义\n```cpp\ntemplate <class T> class LNode {\nprivate:\n\tLNode* next;  //指针\n\tT Data;\t\t  //数据\npublic:\n\tfriend class List;\n\tLNode(T data = 0) {\n\t\tData = data;\n\t\tnext = nullptr;\n\t}\n\tvoid showdata() { cout << Data << endl; }\n};\n```\n# 链表操作类定义\n```cpp\ntemplate <class T> class List {\nprivate:\n\tLNode<T>* head;\t //头结点 不存储元素但分配空间\npublic:\n\tfriend class LNode<T>;\n\tList();\n\t~List();\n\tLNode<T>* FindKth(int K);  //按序号查找查找 查找链表中第K个元素\n\t\t\t\t\t\t\t   //若找到返回指向该结点的指针，找不到返回空指针\n\tLNode<T>* Find(T data);\t //按值查找: 查找元素data\n\t\t\t\t\t\t\t //若找到返回指向该结点的指针，找不到返回空指针\n\tvoid\n\tDelete(int pos =\n\t\t\t   1);\t//删除操作(删除链表第pos个位置上的结点) 默认为删第一个元素\n\tvoid Insert(T data, int pos = 1);  //默认为头插法 将data插入在第pos个元素\n\tvoid PrintList();\t\t\t\t   //展示该链表\n\tint getLength();\t\t\t\t   //获取该链表长度\n};\n```\n# 构造函数和析构函数\n头结点不放数据，所有操作从head->next开始操作\n```cpp\n//构造函数 为head分配空间，不放数据\ntemplate <class T> List<T>::List() {\n\thead = new LNode<T>;\n\thead->next = nullptr;\n}\n//析构函数 释放空间\ntemplate <class T> List<T>::~List() {\n\twhile (head->next) {\n\t\tDelete(1);\n\t}\n\tdelete head;\n}\n```\n# 操作类实现\n## (1) 按序号查找\n查找链表中第K个元素，若找到返回指向该结点的指针，找不到或位置不合法返回空指针。\n\n```cpp\ntemplate <class T> LNode<T>* List<T>::FindKth(int K) {\n\tLNode<T>* p = head->next;  //第一个元素\n\tif (!p) {\n\t\tcout << \"Element not found,This List is empty!\" << endl;\n\t\treturn nullptr;\n\t}\n\tint pos = 1;\n\twhile (p->next && pos < K) {\n\t\tp = p->next;\n\t\tpos++;\n\t}\n\tif (pos == K)\n\t\treturn p;  //找到第K个则返回指针\n\telse {\t\t   //否则位置不合法，返回空指针\n\t\tcout << \"The location is illegal.\" << endl;\n\t\treturn nullptr;\n\t}\n}\n```\n## (2) 按值查找 \n查找元素data，若找到返回指向该结点的指针，若找不到，返回空指针。\n\n```cpp\ntemplate <class T> LNode<T>* List<T>::Find(T data) {\n\tLNode<T>* p = head->next;\n\tif (!p) {\n\t\tcout << \"Element not found,This List is empty!\" << endl;\n\t\treturn nullptr;\n\t}\n\twhile (p->next && p->Data != data)\n\t\tp = p->next;\n\tif (p->Data != data) {  //到最后了但元素仍不是data\n\t\tcout << \"Element not found!\" << endl;\n\t\treturn nullptr;\n\t}\n\telse\n\t\treturn p;\n}\n```\n\n## (3) 删除操作\n删除链表第pos个位置上的结点,默认为删第一个元素\n```cpp\ntemplate <class T>\nvoid List<T>::Delete(int pos) {\t //删除操作(删除链表第i个位置上的结点)\n\tLNode<T>* p = head->next;\n\tif (!p) {\n\t\tcout << \"Deleted failed,This List is empty!\" << endl;\n\t\treturn;\n\t}\n\tif (pos == 1) {\t //若要删除的是表的第一个结点\n\t\thead->next = p->next;\n\t\tif (p)\n\t\t\tdelete p;\n\t\treturn;\n\t}\n\tLNode<T>* s = FindKth(pos - 1);\t //找到第pos-1个元素\n\tif (!s) {\n\t\tcout << \"The \" << pos-1 << \" node does not exist!\" << endl;\n\t\treturn;\n\t}\n\tp = s->next;\n\tif (!p) {\n\t\tcout << \"The \" << pos << \" node does not exist!\" << endl;\n\t\treturn;\n\t} else {\n\t\ts->next = p->next;\t// s指向第pos+1个结点\n\t\tdelete p;\t\t\t//将p从链表中删除\n\t\tcout << \"Successfully deleted!\" << endl;\n\t}\n}\n```\n## (4)插入操作\n默认为头插法 将data插入在第pos个元素\n\n```cpp\ntemplate <class T> void List<T>::Insert(T data, int pos) {\n\tLNode<T>* p = new LNode<T>();//申请新节点p的空间\n\tp->Data = data;\n\tif (pos == 1) {\t //插在第一个\n\t\tp->next = head->next;\n\t\thead->next = p;\n\t\tcout << \"Successfully Inserted!\" << endl;\n\t\treturn;\n\t}\n\tLNode<T>* s = FindKth(pos - 1);\t //找到第pos-1个元素\n\tif (!s) {\n\t\tcout << \"The location is illegal,Insertion failed!\" << endl;\n\t\treturn;\n\t}\n\tp->next = s->next;\n\ts->next = p;\n\tcout << \"Successfully Inserted!\" << endl;\n}\n```\n## (5)获取该链表长度\n```cpp\ntemplate <class T> int List<T>::getLength() {\n\tLNode<T>* p = head;\t // p指向表的第一个节点\n\tint cnt = 0;\n\twhile (p->next) {\n\t\tp = p->next;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}\n```\n## (6)展示该链表\n```cpp\ntemplate <class T> int List<T>::getLength() {\n\tLNode<T>* p = head;\t // p指向表的头节点\n\tif (!head->next)\n\t\tcout << \"This List is empty!\" << endl;\n\tint cnt = 0;\n\twhile (p->next) {\n\t\tp = p->next;\n\t\tcnt++;\n\t\tcout << \"The \" << cnt << \"th Data is:\";\n\t\tp->showdata();\n\t}\n\tcout << \"The list has \" << cnt << \" elements in total.\" << endl;\n}\n```\n## (7)逆转该链表\n大致思想：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201019013358764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n代码：\n```cpp\ntemplate <class T> void List<T>::ReverseList() {\n\tLNode<T>* now = head->next;\t // now指向表的第一个节点\n\tif(!now) {\n\t\tcout << \"This List is empty!\";\n\t\treturn;\n\t}\n\tLNode<T>* tmp = now->next;\t // 指向now之后的一个节点\n\twhile (tmp) {\t\t\t\t //把tmp放到头结点后边\n\t\tnow->next = tmp->next;\n\t\ttmp->next = head->next;\n\t\thead->next = tmp;\n\t\ttmp = now->next;\n\t}\n}\n```\n# 完整代码\n```cpp\n#include <Windows.h>\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Student {\npublic:\n\tstring id;\t  //学号\n\tstring name;  //学生姓名\n\tint age;\t  //年龄\n\tbool operator==(const Student& s) { return id == s.id; }\n\tbool operator!=(const Student& s) { return id != s.id; }\n\tbool operator<(const Student& s) { return id < s.id; }\n\tStudent() : name(\"小明\"), age(18) {}\n\tfriend istream& operator>>(istream& is, Student& s) {\n\t\tis >> s.id >> s.name >> s.age;\n\t\tgetchar();\n\t\treturn is;\n\t}\n\tfriend ostream& operator<<(ostream& os, const Student& s) {\n\t\tos << \"学号:\" << s.id << \"  姓名:\" << s.name << \"  年龄:\" << s.age\n\t\t   << endl;\n\t\treturn os;\n\t}\n};\ntemplate <class T> class List;\n//结点定义\ntemplate <class T> class LNode {\nprivate:\n\tLNode* next;  //指针\n\tT Data;\t\t  //数据\npublic:\n\tfriend class List<T>;\n\tLNode() { next = nullptr; }\n\tvoid showdata() { cout << Data << endl; }\n};\n\n//链表操作类定义\ntemplate <class T> class List {\nprivate:\n\tLNode<T>* head;\t //头结点 不存储元素但分配空间\npublic:\n\tfriend class LNode<T>;\n\tList();\n\t~List();\n\tLNode<T>* FindKth(int K);  //按序号查找查找 查找链表中第K个元素\n\t\t\t\t\t\t\t   //若找到返回指向该结点的指针，找不到返回空指针\n\tLNode<T>* Find(T data);\t //按值查找: 查找元素data\n\t\t\t\t\t\t\t //若找到返回指向该结点的指针，找不到返回空指针\n\tvoid\n\tDelete(int pos =\n\t\t\t   1);\t//删除操作(删除链表第pos个位置上的结点) 默认为删第一个元素\n\tvoid Insert(T data, int pos = 1);  //默认为头插法 将data插入在第pos个元素\n\tvoid PrintList();\t\t\t\t   //展示该链表\n\tint getLength();\t\t\t\t   //获取该链表长度\n\tvoid ReverseList();\t\t\t\t   //逆转该链表\n};\n\n//链表操作类实现\n//构造函数 为head分配空间，不放数据\ntemplate <class T> List<T>::List() {\n\thead = new LNode<T>;\n\thead->next = nullptr;\n}\n//析构函数 释放空间\ntemplate <class T> List<T>::~List() {\n\twhile (head->next) {\n\t\tDelete(1);\n\t}\n\tdelete head;\n}\n//(1) 按序号查找::查找链表中第K个元素\n// 若找到返回指向该结点的指针，找不到返回空指针\ntemplate <class T> LNode<T>* List<T>::FindKth(int K) {\n\tLNode<T>* p = head->next;  //第一个元素\n\tif (!p) {\n\t\tcout << \"Element not found,This List is empty!\" << endl;\n\t\treturn nullptr;\n\t}\n\tint pos = 1;\n\twhile (p->next && pos < K) {\n\t\tp = p->next;\n\t\tpos++;\n\t}\n\tif (pos == K)\n\t\treturn p;  //找到第K个则返回指针\n\telse {\t\t   //否则位置不合法，返回空指针\n\t\tcout << \"The location is illegal.\" << endl;\n\t\treturn nullptr;\n\t}\n}\n\n//(2) 按值查找: 查找元素data\n//若找到返回指向该结点的指针，找不到返回空指针\ntemplate <class T> LNode<T>* List<T>::Find(T data) {\n\tLNode<T>* p = head->next;\n\tif (!p) {\n\t\tcout << \"Element not found,This List is empty!\" << endl;\n\t\treturn nullptr;\n\t}\n\twhile (p->next && p->Data != data)\n\t\tp = p->next;\n\tif (p->Data != data) {  //到最后了但元素仍不是data\n\t\tcout << \"Element not found!\" << endl;\n\t\treturn nullptr;\n\t}\n\telse\n\t\treturn p;\n}\n\n//(3) 删除操作:删除链表第pos个位置上的结点,默认为删第一个元素\ntemplate <class T>\nvoid List<T>::Delete(int pos) {\t //删除操作(删除链表第i个位置上的结点)\n\tLNode<T>* p = head->next;\n\tif (!p) {\n\t\tcout << \"Deleted failed,This List is empty!\" << endl;\n\t\treturn;\n\t}\n\tif (pos == 1) {\t //若要删除的是表的第一个结点\n\t\thead->next = p->next;\n\t\tif (p)\n\t\t\tdelete p;\n\t\treturn;\n\t}\n\tLNode<T>* s = FindKth(pos - 1);\t //找到第pos-1个元素\n\tif (!s) {\n\t\tcout << \"The \" << pos-1 << \" node does not exist!\" << endl;\n\t\treturn;\n\t}\n\tp = s->next;\n\tif (!p) {\n\t\tcout << \"The \" << pos << \" node does not exist!\" << endl;\n\t\treturn;\n\t} else {\n\t\ts->next = p->next;\t// s指向第pos+1个结点\n\t\tdelete p;\t\t\t//将p从链表中删除\n\t\tcout << \"Successfully deleted!\" << endl;\n\t}\n}\n\n//(4)插入操作 默认为头插法 将data插入在第pos个元素\ntemplate <class T> void List<T>::Insert(T data, int pos) {\n\tLNode<T>* p = new LNode<T>();//申请新节点p的空间\n\tp->Data = data;\n\tif (pos == 1) {\t //插在第一个\n\t\tp->next = head->next;\n\t\thead->next = p;\n\t\tcout << \"Successfully Inserted!\" << endl;\n\t\treturn;\n\t}\n\tLNode<T>* s = FindKth(pos - 1);\t //找到第pos-1个元素\n\tif (!s) {\n\t\tcout << \"The location is illegal,Insertion failed!\" << endl;\n\t\treturn;\n\t}\n\tp->next = s->next;\n\ts->next = p;\n\tcout << \"Successfully Inserted!\" << endl;\n}\n\n//(5)获取该链表长度\ntemplate <class T> int List<T>::getLength() {\n\tLNode<T>* p = head;\t // p指向表的头节点\n\tint cnt = 0;\n\twhile (p->next) {\n\t\tp = p->next;\n\t\tcnt++;\n\t}\n\treturn cnt;\n}\n//(6)展示该链表\ntemplate <class T> void List<T>::PrintList() {\n\tLNode<T>* p = head;\t // p指向表的头节点\n\tif (!head->next)\n\t\tcout << \"This List is empty!\" << endl;\n\tint cnt = 0;\n\twhile (p->next) {\n\t\tp = p->next;\n\t\tcnt++;\n\t\tcout << \"The \" << cnt << \"th Data is:\";\n\t\tp->showdata();\n\t}\n\tcout << \"The list has \" << cnt << \" elements in total.\" << endl;\n}\n//(7)逆转该链表\ntemplate <class T> void List<T>::ReverseList() {\n\tLNode<T>* now = head->next;\t // now指向表的第一个节点\n\tif (!now) {\n\t\tcout << \"This List is empty!\" << endl;\n\t\treturn;\n\t}\n\tLNode<T>* tmp = now->next;\t// 指向now之后的一个节点\n\twhile (tmp) {\t\t\t\t//把tmp放到头结点后边\n\t\tnow->next = tmp->next;\n\t\ttmp->next = head->next;\n\t\thead->next = tmp;\n\t\ttmp = now->next;\n\t}\n}\n//主函数中调用的函数\ntemplate <class T> void input(List<T>& Head) {\n\tT data;\n\tcout << \"请输入链表元素(以空格间隔，回车结束):\";\n\tcin >> data;\n\tHead.Insert(data);\n}\ntemplate <class T> void remove(List<T>& Head) {\n\tint i;\n\tcout << \"请输入i(删除链表第i个元素):\";\n\tcin >> i;\n\tgetchar();\n\n\tHead.Delete(i);\n}\ntemplate <class T> void findKth(List<T>& Head) {\n\tint K;\n\tLNode<T>* s = nullptr;\n\tcout << \"(按序号查找)请输入K，查找链表中第K个元素:\";\n\tcin >> K;\n\tgetchar();\n\ts = Head.FindKth(K);\n\tif (!s)\n\t\tcout << \"未找到!\" << endl;\n\telse {\n\t\tcout << \"查找成功!该元素为:\";\n\t\ts->showdata();\n\t}\n}\ntemplate <class T> void findData(List<T>& Head) {\n\tstring data;\n\tcout << \"请输入待查找学生的学号:\";\n\tcin >> data;\n\tStudent t;\n\tt.id = data;\n\tgetchar();\n\tLNode<T>* s = nullptr;\n\ts = Head.Find(t);\n\tif (!s)\n\t\tcout << \"未找到该元素！\" << endl;\n\telse {\n\t\tcout << \"查找成功!该元素在链表中。\";\n\t}\n}\ntemplate <class T> void insert(List<T>& Head) {\n\tint i;\n\tT data;\n\tcout << \"在链表第i个位置上插入一名学生信息,输入i:\";\n\tcin >> i;\n\tcout << \"输入该学生信息，学号 姓名 年龄以空格间隔，回车结束:\";\n\tcin >> data;\n\tHead.Insert(data, i);\n}\ntemplate <class T> inline void getlength(List<T>& Head) {\n\tcout << \"该链表长度为:\" << Head.getLength() << endl;\n}\ntemplate <class T> void printList(List<T>& Head) {\n\tcout << \"---------------------- List P --------------------\" << endl;\n\tHead.PrintList();\n}\ntemplate <class T> void reverseList(List<T>& Head) {\n\tT data;\n\tcout << \"---------------------- List P --------------------\" << endl;\n\tHead.PrintList();\n\tcout << endl;\n\n\tHead.ReverseList();\n\tcout << \"------------- After reverse, List P ---------------\" << endl;\n\tHead.PrintList();\n}\nint main() {\n\tList<Student> P;\n\tint choice;\n\tcout << \"1 添加一名学生信息\" << endl;\n\tcout << \"2 删除链表第i个元素\" << endl;\n\tcout << \"3 按序号查找链表中第K个元素\" << endl;\n\tcout << \"4 按值查找元素data\" << endl;\n\tcout << \"5 在链表第i个位置上插入元素data\" << endl;\n\tcout << \"6 获取该链表长度\" << endl;\n\tcout << \"7 打印所有学生信息\" << endl;\n\tcout << \"8 逆转该链表\" << endl;\n\tcout << \"9 结束\" << endl;\n\twhile (1) {\n\t\tcout << \"菜单选择(1-6):\";\n\t\tcin >> choice;\n\t\tgetchar();\n\t\tswitch (choice) {\n\t\t\tcase 1: input(P); break;\n\t\t\tcase 2: remove(P); break;\n\t\t\tcase 3: findKth(P); break;\n\t\t\tcase 4: findData(P); break;\n\t\t\tcase 5: insert(P); break;\n\t\t\tcase 6: getlength(P); break;\n\t\t\tcase 7: printList(P); break;\n\t\t\tcase 8: reverseList(P); break;\n\t\t\tcase 9: break;\n\t\t\tdefault: cout << \"输入错误，请重新输入\";\n\t\t}\n\t\tif (choice == 9)\n\t\t\texit(0);\n\t\tcout << \"按回车键继续…\" << endl;\n\t\tgetchar();\n\t};\n\treturn 0;\n}\n```\n","sources":["xlog"],"attributes":[{"value":"mo-ban-lei-feng-zhuang-1-dan-lian-biao-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/mo-ban-lei-feng-zhuang-1-dan-lian-biao-md"],"date_published":"2020-10-09T15:03:23.000Z"}}}