{"characterId":52270,"noteId":113,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreihiicbu7stqej2cvou6j2o6w2sk6hnxfjd3kke2626bmqaaedltbm","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-10-23T13:34:43.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":16,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":16,"metadata":{"uri":"ipfs://bafkreihiicbu7stqej2cvou6j2o6w2sk6hnxfjd3kke2626bmqaaedltbm","type":"NOTE","content":{"tags":["post","数据结构","栈","c++"],"type":"note","title":"模板类封装(2)——顺序栈和链式栈","content":"---\ntitle: 模板类封装(2)——顺序栈和链式栈\nlink: 模板类封装(2)——顺序栈和链式栈\ncatalog: true\nlang: cn\ndate:  2020-10-23 13:34:43 \nsubtitle: 自封装栈模板类，c++实现\ntags:\n- 数据结构\n- 栈\n- c++\ncategories:\n- [笔记, 数据结构]\n---\n\n<hr style=\" border:solid; width:100px; height:1px;\" color=#000000 size=1\">\n\nc++语言，链栈实现\n\n> 实验内容：\n> 1. 编程实现栈的如下功能：\n（1）建立一个长度为n的顺序栈，元素类型可自行定义，并输出栈中各元素值。\n（2）将数据元素e入栈，并输出入栈后的顺序栈中各元素值。\n（3）将顺序栈中的栈顶元素出栈，并输出出栈元素的值和出栈后顺序栈中各元素值。\n> 2. 编程实现队列的如下功能：\n（1）建立一个长度为n的循环队列，元素类型可自行定义，并输出队列中各元素值。\n（2）将数据元素e入队，并输出入队后的队列中各元素值。\n（3）将循环队列的队首元素出队，并输出出队元素的值和出队后队列中各元素值。\n>3. 编程实现链式栈的如下功能\n建立长度为n的链式栈，元素类型可自行定义，实现栈的初始化、进栈、出栈等典型操作。\n\n整体上，一是实现顺序栈和链栈的基本操作：入栈操作（Push）、出栈操作（Pop）、取栈顶元素（Top）、判断栈空（IsEmpty）、判断栈满（IsFull）、获取栈中元素个数（Size）、展示栈中所有元素（PrintStack）、清空栈中所有元素（Clear）。二是实现队列的基本操作：入队操作（Push）、出队操作（Pop）、取队首元素（Front）、判断队空（IsEmpty）、判断队满（IsFull）、获取队中元素个数（Size）、展示队中所有元素（PrintQueue）、清空队中所有元素（Clear）。依旧是封装一个模板类。初始化和销毁操作在构造函数和析取函数中实现。\n@[TOC](目录)\n# 顺序栈\n## 顺序栈操作类定义\n```cpp\n//顺序栈定义\ntemplate <class T> class myStack1 {\nprivate:\n\tint MaxSize;  //堆栈容量\n\tT* Data;\t  //数据\n\tint top;  //记录栈顶元素 为栈顶元素下标后一个下标，为空时top为0\npublic:\n\tmyStack1(int maxsize = 100);  //构造函数 分配空间\n\t~myStack1();\t\t\t\t   //析构函数 回收空间\n\tvoid PrintStack();\t\t   //展示顺序栈中所有元素\n\tvoid Push(T data);\t//入栈操作,top值加一,存储元素item在栈顶\n\tT Pop();\t\t\t//出栈操作,将元素弹出返回,Top值减一\n\tT Top();\t\t\t//取栈顶元素,不弹出\n\tint Size();\t\t\t//获取堆栈元素数量\n\tbool IsEmpty();\t\t//判断栈空与否\n\tbool IsFull();\t\t//判断栈满与否\n};\n```\n## 主要操作\n### (1) 构造函数和析构函数\n```cpp\ntemplate <class T>\nmyStack1<T>::myStack1(int maxsize) : MaxSize(maxsize), top(0) {\n\tData = new T[maxsize];\n};\ntemplate <class T> myStack1<T>::~myStack1() {\n\tif (Data)\n\t\tdelete[] Data;\n}\n```\n### (2) 判断栈空栈满\n```cpp\n//判断栈空与否\ntemplate <class T> bool myStack1<T>::IsEmpty() {\n\treturn top == 0;\n}\n//判断栈满与否\ntemplate <class T> bool myStack1<T>::IsFull() {\n\treturn top == MaxSize;\n}\n```\n### (3) 入栈操作\n存储元素data在栈顶,Top值加一\n```cpp\ntemplate <class T> void myStack1<T>::Push(T data) {\n\tif (IsFull()) {\n\t\tcout << \"error:Failed to Push,The Stack is Full!\" << endl;\n\t} else {\n\t\tData[top++] = data;\n\t}\n}\n```\n### (4) 取栈顶元素\n取栈顶元素,不弹出\n```cpp\ntemplate <class T> T myStack1<T>::Top() {\n\tif (IsEmpty()) {\n\t\tcout << \"error:The Top isn't existed, The Stack is Empty!\" << endl;\n\t\treturn error;  // ERROR为T类型中的特殊值\n\t} else {\n\t\treturn Data[top - 1];\n\t}\n}\n```\n### (5) 获取堆栈元素数量\n```cpp\ntemplate <class T> int myStack1<T>::Size() {\n\treturn top;\n}\n```\n### (6) 出栈操作\n弹出栈顶元素,Top值减一\n\n```cpp\ntemplate <class T> T myStack1<T>::Pop() {\n\tif (IsEmpty()) {\n\t\tcout << \"error:Failed to Pop, The Stack is Empty!\" << endl;\n\t\treturn error;  // ERROR为T类型中的特殊值\n\t} else {\n\t\tT temp = Data[--top];\n\t\treturn temp;\n\t}\n}\n```\n### (7) 展示顺序栈中所有元素\n\n```c\ntemplate <class T> void myStack1<T>::PrintStack() {\n\tif (IsEmpty())\n\t\tcout << \"This Stack is empty!\" << endl;\n\tfor (int i = 0; i < top; ++i) {\n\t\tcout << \"The \" << i + 1 << \"th Data is:\";\n\t\tcout << Data[i] << endl;\n\t}\n\tcout << \"The Stack has \" << top << \" elements in total.\" << endl;\n}\n```\n\n## 完整代码\n```cpp\n//顺序栈\n#include <bits/stdc++.h>\n#define error -1\nusing namespace std;\n//顺序栈定义\ntemplate <class T> class myStack1 {\nprivate:\n\tint MaxSize;  //堆栈容量\n\tT* Data;\t  //数据\n\tint top;  //记录栈顶元素 为栈顶元素下标后一个下标，为空时top为0\npublic:\n\tmyStack1(int maxsize = 100);  //构造函数 分配空间\n\t~myStack1();\t\t\t\t   //析构函数 回收空间\n\tvoid PrintStack();\t\t   //展示顺序栈中所有元素\n\tvoid Push(T data);\t//入栈操作,top值加一,存储元素item在栈顶\n\tT Pop();\t\t\t//出栈操作,将元素弹出返回,Top值减一\n\tT Top();\t\t\t//取栈顶元素,不弹出\n\tint Size();\t\t\t//获取堆栈元素数量\n\tbool IsEmpty();\t\t//判断栈空与否\n\tbool IsFull();\t\t//判断栈满与否\n};\n\n//顺序栈操作类实现\n//构造函数 分配空间\ntemplate <class T>\nmyStack1<T>::myStack1(int maxsize) : MaxSize(maxsize), top(0) {\n\tData = new T[maxsize];\n};\n//析构函数 释放空间\ntemplate <class T> myStack1<T>::~myStack1() {\n\tif (Data)\n\t\tdelete[] Data;\n}\n//(1) 判断栈空与否\ntemplate <class T> bool myStack1<T>::IsEmpty() {\n\treturn top == 0;\n}\n//(2) 判断栈满与否\ntemplate <class T> bool myStack1<T>::IsFull() {\n\treturn top == MaxSize;\n}\n//(3) 入栈操作\n// 存储元素data在栈顶,Top值加一\ntemplate <class T> void myStack1<T>::Push(T data) {\n\tif (IsFull()) {\n\t\tcout << \"error:Failed to Push,The Stack is Full!\" << endl;\n\t}\n\telse {\n\t\tData[top++] = data;\n\t}\n}\n//(4) 取栈顶元素,不弹出\ntemplate <class T> T myStack1<T>::Top() {\n\tif (IsEmpty()) {\n\t\tcout << \"error:The Top isn't existed, The Stack is Empty!\" << endl;\n\t\treturn error;  // ERROR为T类型中的特殊值\n\t}\n\telse {\n\t\treturn Data[top - 1];\n\t}\n}\n//(5) 获取堆栈元素数量\ntemplate <class T> int myStack1<T>::Size() {\n\treturn top;\n}\n//(6) 出栈操作\n// 弹出栈顶元素,Top值减一\ntemplate <class T> T myStack1<T>::Pop() {\n\tif (IsEmpty()) {\n\t\tcout << \"error:Failed to Pop, The Stack is Empty!\" << endl;\n\t\treturn error;  // ERROR为T类型中的特殊值\n\t}\n\telse {\n\t\tT temp = Data[--top];\n\t\treturn temp;\n\t}\n}\n//(7) 展示顺序栈中所有元素\ntemplate <class T> void myStack1<T>::PrintStack() {\n\tif (IsEmpty())\n\t\tcout << \"This Stack is empty!\" << endl;\n\tfor (int i = 0; i < top; ++i) {\n\t\tcout << \"The \" << i + 1 << \"th Data is:\";\n\t\tcout << Data[i] << endl;\n\t}\n\tcout << \"The Stack has \" << top << \" elements in total.\" << endl;\n}\n//主函数中调用的函数 (测试用)\ntemplate <class T> void Stack_Push(myStack1<T>& S) {\n\tT data;\n\tcout << \"请输入要入栈的元素:\";\n\tcin >> data;\n\tS.Push(data);\n\tcout << \"------------- After Push, Stack S ---------------\" << endl;\n\tS.PrintStack();\n}\ntemplate <class T> void Stack_Pop(myStack1<T>& S) {\n\tT data = S.Pop();\n\tif (data != error) {\n\t\tcout << \"出栈元素为:\";\n\t\tcout << data << endl;\n\t}\n\tcout << \"------------- After Pop, Stack S ---------------\" << endl;\n\tS.PrintStack();\n}\ntemplate <class T> void Stack_Top(myStack1<T>& S) {\n\tT data = S.Top();\n\tif (data != error) {\n\t\tcout << \"栈顶元素为:\";\n\t\tcout << data << endl;\n\t}\n}\ntemplate <class T> void Stack_Size(myStack1<T>& S) {\n\tcout << \"该堆栈中元素个数为:\" << S.Size() << endl;\n}\ntemplate <class T> void Stack_PrintStack(myStack1<T>& S) {\n\tcout << \"---------------------- Stack S --------------------\" << endl;\n\tS.PrintStack();\n}\nint main() {\n\tint n;\n\tcout << \"输入n,建立长度为n的顺序栈:\";\n\tcin >> n;\n\tmyStack1<int> S(n);\n\tcout << \"输入n个元素:\" << endl;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint data;\n\t\tcin >> data;\n\t\tS.Push(data);\n\t}\n\tcout << \"1 入栈操作\" << endl;\n\tcout << \"2 出栈操作\" << endl;\n\tcout << \"3 取栈顶元素\" << endl;\n\tcout << \"4 取堆栈元素个数\" << endl;\n\tcout << \"5 输出顺序栈中所有元素\" << endl;\n\tcout << \"6 结束\" << endl;\n\twhile (1) {\n\t\tint choice;\n\t\tcout << \"菜单选择:\";\n\t\tcin >> choice;\n\t\tgetchar();\n\t\tswitch (choice) {\n\t\t\tcase 1: Stack_Push(S); break;\n\t\t\tcase 2: Stack_Pop(S); break;\n\t\t\tcase 3: Stack_Top(S); break;\n\t\t\tcase 4: Stack_Size(S); break;\n\t\t\tcase 5: Stack_PrintStack(S); break;\n\t\t\tcase 6: break;\n\t\t\tdefault: cout << \"输入错误，请重新输入\";\n\t\t}\n\t\tif (choice == 6)\n\t\t\texit(0);\n\t\tcout << \"按回车键继续…\" << endl;\n\t\tgetchar();\n\t};\n\treturn 0;\n}\n```\n# 链栈\n## 链栈结点定义\n\n```cpp\ntemplate <class T> class SNode {\nprivate:\n\tSNode* next;  //指针\n\tT Data;\t\t  //数据\npublic:\n\tfriend class Stack<T>;\n\tSNode() { next = nullptr; }\t //空结点\n\tSNode(T data) {\t\t\t\t //有数据的结点\n\t\tData = data;\n\t\tnext = nullptr;\n\t}\n\tvoid showdata() { cout << Data << endl; }  //展示该结点数据\n};\n```\n\n## 链栈操作类定义\n\n```cpp\ntemplate <class T> class Stack {\nprivate:\n\tint maxsize;  //堆栈容量\n\tSNode<T>* head;\t //头指针 带空头结点，所以栈顶元素一直为head->next\npublic:\n\tStack(int size = 100);\t//构造函数 分配空间,空头结点\n\t~Stack();\t\t\t\t//析构函数 回收空间\n\tvoid PrintStack();\t\t//展示栈中所有元素\n\tvoid Clear();\t\t\t//清空栈中所有元素\n\tvoid Push(T data);\t\t//入栈操作 存储元素data在栈顶\n\tT Pop();\t\t //出栈操作 弹出栈顶元素并将其在栈中删除\n\tT Top();\t\t //取栈顶元素,不弹出\n\tint Size();\t\t //获取堆栈元素数量\n\tbool IsEmpty();\t //判断栈空与否\n\tbool IsFull();\t //判断栈满与否\n};\n```\n\n## 主要操作\n### (1) 构造函数和析构函数\n```cpp\n//构造函数 分配空间,空头结点\ntemplate <class T> Stack<T>::Stack(int size) : maxsize(size) {\n\thead = new SNode<T>;\n\thead->next = nullptr;\n};\n\n//析构函数 释放空间\ntemplate <class T> Stack<T>::~Stack() {\n\twhile (head->next) {\n\t\tPop();\n\t}\n\tif (head)\n\t\tdelete head;\n}\n```\n### (2) 判断栈空栈满\n\n```cpp\ntemplate <class T> bool Stack<T>::IsEmpty() {\n\tif (head->next) return false;\n\telse return true;\n}\ntemplate <class T> bool Stack<T>::IsFull() {\n\tif (Size() < maxsize) return false;\n\telse return true;\n}\n```\n### (3) 入栈操作\n存储元素data在栈顶\n\n```cpp\ntemplate <class T> void Stack<T>::Push(T data) {\n\tif (IsFull()) {\n\t\tcout << \"error:Failed to Push,The Stack is Full!\" << endl;\n\t} else {\n\t\tSNode<T>* p = new SNode<T>;\n\t\tp->Data = data;\n\t\tp->next = head->next;\n\t\thead->next = p;\n\t}\n}\n```\n### (4) 取栈顶元素\n```cpp\ntemplate <class T> T Stack<T>::Top() {\n\tif (IsEmpty()) {\n\t\tcout << \"error:The Top isn't existed, The Stack is Empty!\" << endl;\n\t\treturn error;\n\t} else {\n\t\tT temp = head->next->Data;\n\t\treturn temp;\n\t}\n}\n```\n### (5) 获取堆栈元素数量\n\n```cpp\ntemplate <class T> int Stack<T>::Size() {\n\tint cnt = 0;\n\tSNode<T>* p = head;\n\twhile (p->next) {\n\t\tcnt++;\n\t\tp = p->next;\n\t}\n\treturn cnt;\n}\n```\n### (6) 出栈操作\n弹出栈顶元素并将其在栈中删除\n\n```cpp\ntemplate <class T> T Stack<T>::Pop() {\n\tif (IsEmpty()) {\n\t\tcout << \"error:Failed to Pop, The Stack is Empty!\" << endl;\n\t\treturn error;\n\t} else {\n\t\tSNode<T>* temp = head->next;\n\t\tT TopData = temp->Data;\n\t\thead->next = temp->next;\n\t\tdelete temp;\n\t\treturn TopData;\n\t}\n}\n```\n### (7) 展示栈中所有元素\n弹出栈顶元素并将其在栈中删除\n\n```cpp\ntemplate <class T> T Stack<T>::Pop() {\n\tif (IsEmpty()) {\n\t\tcout << \"error:Failed to Pop, The Stack is Empty!\" << endl;\n\t\treturn error;\n\t} else {\n\t\tSNode<T>* temp = head->next;\n\t\tT TopData = temp->Data;\n\t\thead->next = temp->next;\n\t\tdelete temp;\n\t\treturn TopData;\n\t}\n}\n```\n### (8) 清空栈中所有元素\n```cpp\n//(8) 清空栈中所有元素\ntemplate <class T> void Stack<T>::Clear() {\n\twhile (head->next) {\n\t\tPop();\n\t}\n}\n```\n\n## 完整代码\n\n```cpp\n//链栈\n#include <bits/stdc++.h>\n#define error -1\nusing namespace std;\ntemplate <class T> class Stack;\n//链栈结点定义\ntemplate <class T> class SNode {\nprivate:\n\tSNode* next;  //指针\n\tT Data;\t\t  //数据\npublic:\n\tfriend class Stack<T>;\n\tSNode() { next = nullptr; }\t //空结点\n\tSNode(T data) {\t\t\t\t //有数据的结点\n\t\tData = data;\n\t\tnext = nullptr;\n\t}\n\tvoid showdata() { cout << Data << endl; }  //展示该结点数据\n};\n//链栈操作类定义\ntemplate <class T> class Stack {\nprivate:\n\tint maxsize;  //堆栈容量\n\tSNode<T>* head;\t //头指针 带空头结点，所以栈顶元素一直为head->next\npublic:\n\tStack(int size = 100);\t//构造函数 分配空间,空头结点\n\t~Stack();\t\t\t\t//析构函数 回收空间\n\tvoid PrintStack();\t\t//展示栈中所有元素\n\tvoid Clear();\t\t\t//清空栈中所有元素\n\tvoid Push(T data);\t\t//入栈操作 存储元素data在栈顶\n\tT Pop();\t\t //出栈操作 弹出栈顶元素并将其在栈中删除\n\tT Top();\t\t //取栈顶元素,不弹出\n\tint Size();\t\t //获取堆栈元素数量\n\tbool IsEmpty();\t //判断栈空与否\n\tbool IsFull();\t //判断栈满与否\n};\n\n//链栈操作类实现\n//构造函数 分配空间,空头结点\ntemplate <class T> Stack<T>::Stack(int size) : maxsize(size) {\n\thead = new SNode<T>;\n\thead->next = nullptr;\n};\n\n//析构函数 释放空间\ntemplate <class T> Stack<T>::~Stack() {\n\twhile (head->next) {\n\t\tPop();\n\t}\n\tif (head)\n\t\tdelete head;\n}\n//(1) 判断栈空与否\ntemplate <class T> bool Stack<T>::IsEmpty() {\n\tif (head->next)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n//(2) 判断栈满与否\ntemplate <class T> bool Stack<T>::IsFull() {\n\tif (Size() < maxsize)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n//(3) 入栈操作\n// 存储元素data在栈顶\ntemplate <class T> void Stack<T>::Push(T data) {\n\tif (IsFull()) {\n\t\tcout << \"error:Failed to Push,The Stack is Full!\" << endl;\n\t}\n\telse {\n\t\tSNode<T>* p = new SNode<T>;\n\t\tp->Data = data;\n\t\tp->next = head->next;\n\t\thead->next = p;\n\t}\n}\n//(4) 取栈顶元素,不弹出\ntemplate <class T> T Stack<T>::Top() {\n\tif (IsEmpty()) {\n\t\tcout << \"error:The Top isn't existed, The Stack is Empty!\" << endl;\n\t\treturn error;\n\t}\n\telse {\n\t\tT temp = head->next->Data;\n\t\treturn temp;\n\t}\n}\n//(5) 获取堆栈元素数量\ntemplate <class T> int Stack<T>::Size() {\n\tint cnt = 0;\n\tSNode<T>* p = head;\n\twhile (p->next) {\n\t\tcnt++;\n\t\tp = p->next;\n\t}\n\treturn cnt;\n}\n//(6) 出栈操作\n// 弹出栈顶元素并将其在栈中删除\ntemplate <class T> T Stack<T>::Pop() {\n\tif (IsEmpty()) {\n\t\tcout << \"error:Failed to Pop, The Stack is Empty!\" << endl;\n\t\treturn error;\n\t}\n\telse {\n\t\tSNode<T>* temp = head->next;\n\t\tT TopData = temp->Data;\n\t\thead->next = temp->next;\n\t\tdelete temp;\n\t\treturn TopData;\n\t}\n}\n//(7) 展示栈中所有元素\ntemplate <class T> void Stack<T>::PrintStack() {\n\tif (IsEmpty())\n\t\tcout << \"This Stack is empty!\" << endl;\n\tSNode<T>* p = head;\n\tint cnt = 0;\n\twhile (p->next) {\n\t\t++cnt;\n\t\tp = p->next;\n\t\tcout << \"The \" << cnt << \"th Data is:\";\n\t\tcout << p->Data << endl;\n\t}\n\tcout << \"The Stack has \" << Size() << \" elements in total.\" << endl;\n}\n//(8) 清空栈中所有元素\ntemplate <class T> void Stack<T>::Clear() {\n\twhile (head->next) {\n\t\tPop();\n\t}\n}\n//主函数中调用的函数 (测试用)\ntemplate <class T> void Stack_Push(Stack<T>& S) {\n\tT data;\n\tcout << \"请输入要入栈的元素:\";\n\tcin >> data;\n\tgetchar();\n\tS.Push(data);\n\tcout << \"------------- After Push, Stack S ---------------\" << endl;\n\tS.PrintStack();\n}\ntemplate <class T> void Stack_Pop(Stack<T>& S) {\n\tT data = S.Pop();\n\tif (data != error) {\n\t\tcout << \"出栈元素为:\";\n\t\tcout << data << endl;\n\t}\n\tcout << \"------------- After Pop, Stack S ---------------\" << endl;\n\tS.PrintStack();\n}\ntemplate <class T> void Stack_Top(Stack<T>& S) {\n\tT data = S.Top();\n\tif (data != error) {\n\t\tcout << \"栈顶元素为:\";\n\t\tcout << data << endl;\n\t}\n}\ntemplate <class T> void Stack_Size(Stack<T>& S) {\n\tcout << \"该堆栈中元素个数为:\" << S.Size() << endl;\n}\ntemplate <class T> void Stack_PrintStack(Stack<T>& S) {\n\tcout << \"---------------------- Stack S --------------------\" << endl;\n\tS.PrintStack();\n}\ntemplate <class T> void Stack_ClearStack(Stack<T>& S) {\n\tS.Clear();\n\tcout << \"成功清空！\" << endl;\n}\nint main() {\n\tint n;\n\tcout << \"输入n,建立长度为n的链栈:\";\n\tcin >> n;\n\tStack<int> S(n);\n\tcout << \"输入n个元素:\" << endl;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint data;\n\t\tcin >> data;\n\t\tS.Push(data);\n\t}\n\tcout << \"1 入栈操作\" << endl;\n\tcout << \"2 出栈操作\" << endl;\n\tcout << \"3 取栈顶元素\" << endl;\n\tcout << \"4 取堆栈元素个数\" << endl;\n\tcout << \"5 输出栈中所有元素\" << endl;\n\tcout << \"6 清空栈中所有元素\" << endl;\n\tcout << \"7 结束\" << endl;\n\twhile (1) {\n\t\tint choice;\n\t\tcout << \"菜单选择:\";\n\t\tcin >> choice;\n\t\tgetchar();\n\t\tswitch (choice) {\n\t\t\tcase 1: Stack_Push(S); break;\n\t\t\tcase 2: Stack_Pop(S); break;\n\t\t\tcase 3: Stack_Top(S); break;\n\t\t\tcase 4: Stack_Size(S); break;\n\t\t\tcase 5: Stack_PrintStack(S); break;\n\t\t\tcase 6: Stack_ClearStack(S); break;\n\t\t\tcase 7: break;\n\t\t\tdefault: cout << \"输入错误，请重新输入\";\n\t\t}\n\t\tif (choice == 7)\n\t\t\texit(0);\n\t\tcout << \"按回车键继续…\" << endl;\n\t\tgetchar();\n\t};\n\treturn 0;\n}\n```\n","sources":["xlog"],"attributes":[{"value":"mo-ban-lei-feng-zhuang-2-shun-xu-zhan-he-lian-shi-zhan-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/mo-ban-lei-feng-zhuang-2-shun-xu-zhan-he-lian-shi-zhan-md"],"date_published":"2020-10-23T13:34:43.000Z"}}}