{"characterId":52270,"noteId":53,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreiczm33tot56tsn77cqhzffertafxjypqqzw3aiqav4eel4vlzfh5a","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:39:52.000Z","updatedAt":"2023-04-05T06:39:52.000Z","deletedAt":null,"publishedAt":"2022-04-15T16:41:49.000Z","transactionHash":"0x16c8bbbc59b889d2e6569492006a2c6cfbcfe39cb15611ff19baebf93088d12d","blockNumber":30317697,"logIndex":0,"updatedTransactionHash":"0x16c8bbbc59b889d2e6569492006a2c6cfbcfe39cb15611ff19baebf93088d12d","updatedBlockNumber":30317697,"updatedLogIndex":0,"metadata":{"uri":"ipfs://bafkreiczm33tot56tsn77cqhzffertafxjypqqzw3aiqav4eel4vlzfh5a","type":"NOTE","content":{"tags":["post","编译原理"],"type":"note","title":"编译原理 实验二 LL(1)分析法程序","content":"---\ntitle: 编译原理 实验二 LL(1)分析法程序\nlink: compile-learning-experiment_2\ncatalog: true\nlang: cn\ndate: 2022-04-15 16:41:49 \nsubtitle: 编译原理第二次实验~LL(1)分析法\ntags:\n- 编译原理\ncategories:\n- [笔记, CS基础]\n---\n源代码仓库：[CompilePrincipleLearning/experiment_2 · yusixian/CompilePrincipleLearning (github.com)](https://github.com/yusixian/CompilePrincipleLearning/tree/master/experiment_2)\n\n# 一.\t实验目的\n\n1. 掌握LL(1)分析法的基本原理\n2. 掌握LL(1)分析表的构造方法\n3. 掌握LL(1)驱动程序的构造方法\n\n# 二.\t实验内容及要求\n\n编写识别单词的词法分析程序。\n\n根据某一文法编制调试LL（1）分析程序，以便对任意输入的符号串进行分析。本次实验的目的主要是加深对预测分析LL（1）分析法的理解。\n\n例：对下列文法，用LL（1）分析法对任意输入的符号串进行分析：\n\n（1）E->TG\n\n（2）G->+TG|—TG\n\n（3）G->ε\n\n（4）T->FS\n\n（5）S->*FS|/FS\n\n（6）S->ε\n\n（7）F->(E)\n\n（8）F->i\n\n输出的格式如下：\n\n(1) `LL（1）分析程序，编制人：姓名，学号，班级`\n\n(2) 输入一以#结束的符号串(包括 `+*（）i#`)：i*(i+i)+(i*i)#\n\n(3) 输出过程步骤如下：\n\n| **步骤** | **分析栈** | **剩余输入串** | **所用产生式** |\n| -------------- | ---------------- | -------------------- | -------------------- |\n| 1              | E                | i+i*i#               | E->TG                |\n\n(4)输入符号串为非法符号串(或者为合法符号串)\n\n备注：\n\n(1) 在“ **所用产生式** ”一列中如果对应有推导则写出所用产生式；如果为匹配终结符则写明匹配的终结符；如分析异常出错则写为“分析出错”；若成功结束则写为“分析成功”。\n\n(2)在此位置输入符号串为用户自行输入的符号串。\n\n(3)上述描述的输出过程只是其中一部分的。\n\n注意：1．表达式中允许使用运算符（+-*/）、分割符（括号）、字符i，结束符#；\n\n2．如果遇到错误的表达式，应输出错误提示信息（该信息越详细越好）；\n\n3．对学有余力的同学，测试用的表达式事先放在文本文件中，一行存放一个表达式，同时以分号分割。同时将预期的输出结果写在另一个文本文件中，以便和输出进行对照；\n\n4．可采用的其它的文法\n\n# 三.\t实验过程\n\n## 1、采用的数据结构\n\n产生式类型定义为type，左侧为origin，大写字符，右侧产生的字符\n\n```cpp\nstruct type { /*产生式类型定义      */\n    char origin;   /*产生式左侧字符 大写字符  */\n    string array; /*产生式右边字符 */\n    int length;    /*字符个数      */\n    type():origin('N'), array(\"\"), length(0) {}\n    void init(char a, string b) {\n        origin = a;\n        array = b;\n        length = array.length();\n    }\n};\n```\n\n初始化数据结构如下：\n\n```cpp\ne.init('E', \"TG\"), t.init('T', \"FS\");\ng.init('G', \"+TG\"), g1.init('G', \"^\");\ns.init('S', \"*FS\"), s1.init('S', \"^\");\nf.init('F', \"(E)\"), f1.init('F', \"i\");\n```\n\n## 2、头文件声明和全局变量定义\n\n如下\n\n```cpp\n#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nconst string ExpFileName = \"./exp.txt\";\nchar analyeStack[20];                           /*分析栈*/\nchar restStack[20];                             /*剩余栈*/\nconst string v1 = \"i+*()#\"; /*终结符 */\nconst string v2 = \"EGTSF\";      /*非终结符   */\nconst string acceptStr = \"i+*()#\";   // 接受的字符串\nint top, ridx, len; /*len为输入串长度 */\nstruct type { /*产生式类型定义      */\n    char origin;   /*产生式左侧字符 大写字符  */\n    string array; /*产生式右边字符 */\n    int length;    /*字符个数      */\n    type():origin('N'), array(\"\"), length(0) {}\n    void init(char a, string b) {\n        origin = a;\n        array = b;\n        length = array.length();\n    }\n};\ntype e, t, g, g1, s, s1, f, f1; /* 产生式结构体变量 */\ntype C[10][10];                 /* 预测分析表 */\n```\n\n## 4、函数汇总\n\n### （1）函数汇总表\n\n| 函数名称         | 功能简述                                                                     |\n| ---------------- | ---------------------------------------------------------------------------- |\n| `readFile`     | 读取文件函数，返回一个string动态数组，以行数分割                             |\n| `init`         | 初始化函数，在该函数中进行分析栈、剩余栈的初始化                             |\n| `print`        | 输出当前分析栈和剩余栈                                                       |\n| `isTerminator` | 判断当前字符c是否是终结符                                                    |\n| `analyze`      | 分析字符串s，输出其分析步骤                                                  |\n| `main`         | 主程序入口，从此进入，填充初始分析表及产生式初始化，调用读取文件函数开始分析 |\n\n### （2）函数的调用关系\n\n![function](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0a3179495a4adbbba74a5ef1a1f637~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 5、实验结果\n\n### 输入\n\n文件exp.txt\n\n```txt\ni*(i+i)+(i*i)#\ni*i-i/1#\ni+i*i+i*(i+i*i)#\ni+*i(i)+i(i+i*i)#\ni+i(i)#code.txt\n```\n\n### 输出\n\n![实验结果](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20f32d9b81fb45b1a9b46517aa1853c8~tplv-k3u1fbpfcp-zoom-1.image)\n\n![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e09a14f82544339b77fddfa8968db9f~tplv-k3u1fbpfcp-zoom-1.image)\n\n# 完整代码\n\n```cpp\n/*\n * @Author: cos\n * @Date: 2022-04-12 23:03:36\n * @LastEditTime: 2022-04-13 01:32:58\n * @LastEditors: cos\n * @Description: \n * @FilePath: \\CS\\experiment_2\\main.cpp\n */\n#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <cstring>\nusing namespace std;\nconst string ExpFileName = \"./exp.txt\";\nchar analyeStack[20];                           /*分析栈*/\nchar restStack[20];                             /*剩余栈*/\nconst string v1 = \"i+*()#\"; /*终结符 */\nconst string v2 = \"EGTSF\";      /*非终结符   */\nint top, ridx, len; /*len为输入串长度 */\nstruct type { /*产生式类型定义      */\n    char origin;   /*产生式左侧字符 大写字符  */\n    string array; /*产生式右边字符 */\n    int length;    /*字符个数      */\n    type():origin('N'), array(\"\"), length(0) {}\n    void init(char a, string b) {\n        origin = a;\n        array = b;\n        length = array.length();\n    }\n};\ntype e, t, g, g1, s, s1, f, f1; /* 产生式结构体变量 */\ntype C[10][10];                 /* 预测分析表 */\nvoid print() {/*输出分析栈和剩余栈 */\n    for(int i = 0; i <= top + 1; ++i)   /*输出分析栈  */\n        cout << analyeStack[i];\n    cout << \"\\t\\t\";\n\n    for(int i = 0; i < ridx; ++i) /*输出对齐符*/\n        cout << ' ';\n    for(int i = ridx; i <= len; ++i)   /*输出剩余串*/\n        cout << restStack[i];\n    cout << \"\\t\\t\\t\";\n}\n// 读文件\nvector<string> readFile(string fileName) {\n    vector<string> res;\n    try {\n        ifstream fin;\n        fin.open(fileName);\n        string temp;\n        while (getline(fin, temp))\n            res.push_back(temp);\n        return res;\n    } catch(const exception& e) {\n        cerr << e.what() << '\\n';\n        return res;\n    }\n}\nbool isTerminator(char c) { // 判断是否是终结符\n    return v1.find(c) != string::npos;\n}\nvoid init(string exp) {\n    top = ridx = 0;\n    len = exp.length();     /*分析串长度*/\n    for(int i = 0; i < len; ++i)\n        restStack[i] = exp[i];\n}\nvoid analyze(string exp) {  // 分析一个文法\n    init(exp);\n    int k = 0;\n    analyeStack[top] = '#';\n    analyeStack[++top] = 'E'; /*'#','E'进栈*/\n    cout << \"步骤\\t\\t分析栈 \\t\\t剩余字符 \\t\\t所用产生式 \" << endl;\n    while(true) {\n        char ch = restStack[ridx];\n        char x = analyeStack[top--]; /*x为当前栈顶字符*/\n        cout << ++k << \"\\t\\t\";\n        if(x == '#') {\n            cout << \"分析成功！AC！\\n\" << endl; /*接受 */\n            return;\n        }\n        if(isTerminator(x)) {\n            if (x == ch) {  // 匹配上了\n                print();\n                cout << ch << \"匹配\" << endl;\n                ch = restStack[++ridx]; /*下一个输入字符*/\n            } else {             /*出错处理*/\n                print();\n                cout << \"分析出错，错误终结符为\" << ch << endl; /*输出出错终结符*/\n                return;\n            }\n        } else {    /*非终结符处理*/\n            int m, n;   // 非终结符下标， 终结符下标\n            v2.find(x) != string::npos ? m = v2.find(x) : -1;   // m为-1则说明找不到该非终结符，出错\n            v1.find(ch) != string::npos ? n = v1.find(ch) : -1; // n为-1则说明找不到该终结符，出错\n            if(m == -1 || n == -1) { /*出错处理*/\n                print();\n                cout << \"分析出错，错误非终结符为\" << x << endl; /*输出出错非终结符*/\n                return;\n            }\n            type nowType = C[m][n];/*用来接受C[m][n]*/\n            if(nowType.origin != 'N') {/*判断是否为空*/\n                print();\n                cout << nowType.origin << \"->\" << nowType.array << endl; /*输出产生式*/\n                for (int j = (nowType.length - 1); j >= 0; --j) /*产生式逆序入栈*/\n                    analyeStack[++top] = nowType.array[j];\n                if (analyeStack[top] == '^') /*为空则不进栈*/\n                    top--;\n            } else { /*出错处理*/\n                print();\n                cout << \"分析出错，错误非终结符为\" << x << endl; /*输出出错非终结符*/\n                return;\n            }\n        }\n    }\n}\nint main() {\n    e.init('E', \"TG\"), t.init('T', \"FS\");\n    g.init('G', \"+TG\"), g1.init('G', \"^\");\n    s.init('S', \"*FS\"), s1.init('S', \"^\");\n    f.init('F', \"(E)\"), f1.init('F', \"i\"); /* 结构体变量 */\n    /*填充分析表*/\n    C[0][0] = C[0][3] = e;\n    C[1][1] = g; \n    C[1][4] = C[1][5] = g1;\n    C[2][0] = C[2][3] = t;\n    C[3][2] = s;\n    C[3][4] = C[3][5] = C[3][1] = s1;\n    C[4][0] = f1; C[4][3] = f;\n    cout << \"LL（1）分析程序分析程序，编制人：xxx xxx 计科xxxx班\" << endl;\n    cout << \"提示:本程序只能对由'i','+','*','(',')'构成的以'#'结束的字符串进行分析，每行一个读入的字符串\" << endl;\n    cout << \"读取的文件名为：\" << ExpFileName << endl; \n    vector<string> exps = readFile(ExpFileName);\n    int len = exps.size();\n    for(int i = 0; i < len; i++) {\n        string exp = exps[i];\n        cout << \"------------------待分析字符串\" << i+1 << \"：\"<< exp << \"--------------------\" << endl;\n        bool flag = true;\n        for(int j = 0; j < exp.length(); j++) {\n            if(!isTerminator(exp[j])) {\n                cout << \"第\"<< i+1 << \"行输入的字符串不合法，请重新输入\" << endl;\n                flag = false;\n                break;\n            }\n        }\n        if(flag) {\n            cout << \"字符串\" << i+1 << \"：\" << exp << endl;\n            analyze(exp);\n        }\n    }\n    return 0;\n}\n\n```\n","sources":["xlog"],"attributes":[{"value":"bian-yi-yuan-li-shi-yan-er-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/bian-yi-yuan-li-shi-yan-er-md"],"date_published":"2022-04-15T16:41:49.000Z"}}}