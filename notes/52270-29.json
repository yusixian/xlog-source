{"characterId":52270,"noteId":29,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreif7wzcf2xzim5ouloqy2irasn34b4zgk54xkcn7h4qlkcmhl2tire","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:38:05.000Z","updatedAt":"2023-04-05T06:38:05.000Z","deletedAt":null,"publishedAt":"2020-09-05T22:39:22.000Z","transactionHash":"0xbfab47b82ecebba6e9fc656935da117e29078d33b8ae11d03dbc25062e62f2ae","blockNumber":30317590,"logIndex":4,"updatedTransactionHash":"0xbfab47b82ecebba6e9fc656935da117e29078d33b8ae11d03dbc25062e62f2ae","updatedBlockNumber":30317590,"updatedLogIndex":4,"metadata":{"uri":"ipfs://bafkreif7wzcf2xzim5ouloqy2irasn34b4zgk54xkcn7h4qlkcmhl2tire","type":"NOTE","content":{"tags":["post","c++","算法"],"type":"note","title":"状压dp——模板&分析&例题（存用）","content":"---\ntitle: 状压dp——模板&分析&例题（存用）\nlink: 状压dp——模板&分析&例题（存用）\ncatalog: true\nlang: cn\ndate:  2020-09-05 22:39:22 \nsubtitle: 状压dp，即将状态压缩成2进制来保存，是动态规划中的一种非常暴力的做法\ntags:\n- c++\n- 算法\ncategories:\n- [笔记, 算法]\n---\n\n状压讲解部分参考博客[状压DP详解（位运算）](https://www.cnblogs.com/smallhester/p/10394328.html)\n# 一、什么是状压dp？\n\n> 这里是引用\n\n   状压dp，即将状态压缩成2进制来保存，如矩阵中将一行的状态压缩成一个二进制串，如dp[S][v]中，S可以代表已经访问过的顶点的集合，v可以代表当前所在的顶点为v。S代表的就是一种状态（二进制表示）， (11001)~2~  代表在二进制中{0，3，4}三个顶点已经访问过了，(11001)~2~ 代表的十进制数就是25 ，所以当S为25的时候其实就是代表已经访问过了{0，3，4}三个顶点，那假如一共有5个顶点（标号为01234）的话，所有的顶点都访问完毕，Sj就是　(11111)~2~。\n\n# 二、常用位运算\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200814161751719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n对于上面的一些操作举例一些\n就如之上的　(11001)~2~　来说是已经访问了0，3，4三个顶点，当我接下去要访问顶点2的话可以有以下操作：1.看看第3位是什么？那么选择取出二进制数x的第k位，y = x >>(k-1) & 1，y = (110)~2~ & 1 = 0，2.把第3位变为1，y = x | (1<<(k-1))，y = (11001)~2~  |  (100)~2~ = (11101)~2~，所以顶点2访问完毕，加入到集合S中也结束了，此时S为(11101)2 = 29。\n\n\n# 三、例题\n## [A-Hie with the Pie](https://vjudge.net/contest/389291#problem/A)\n### 题意\n给出所有地点之间来往的所需时间（来往时间可能不同），如何用最短时间送完所有地点的订单并返回披萨店（编号0）\n### 思路\n先用Floyd算法得出最短路矩阵，用S表示状态，dp[S][i]表示送达第i个地点所需的最短时间，由S可知当前已送达哪些城市，S = 1<<N-1即为全部送达的状态（N位全为1）\n### 代码\n```cpp\n// A-Hie with the Pie\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define div 1000000007\nconst int maxn = 12;\nconst int inf  = 0x3f3f3f;\nint N,S,ans;\nint dis[maxn][maxn];\nint dp[1<<maxn][maxn];\nvoid Floyd() {\n    for(int k = 0; k <= N; ++k) {\n        for(int i = 0; i <= N; ++i) {\n            for(int j = 0; j <= N; ++j) {\n                if(dis[i][j] > dis[i][k] + dis[k][j]) {\n                    dis[i][j] = dis[i][k] + dis[k][j];\n                }\n            }\n        }\n    }\n}\nint main(){\n    while(scanf(\"%d\", &N) && N) {\n        for(int i = 0; i <= N; ++i) {\n            for(int j = 0; j <= N; ++j) {\n                scanf(\"%d\", &dis[i][j]);\n            }\n        }\n        Floyd();\n        for(int S = 0; S < (1<<N); ++S) {//S的所有状态\n            for(int i = 1; i <= N; ++i) {//所有要送的地点\n                if(S & ( 1<<(i-1) )) {  //要送往地点i\n                    if(S == ( 1<<(i-1) )) {//若S还没有送往任何一个地点\n                        dp[S][i] = dis[0][i];\n                        break;\n                    } else {\n                        dp[S][i] = inf;\n                        for(int j = 1; j <= N; ++j) {\n                            if(j == i) continue;\n                            //枚举除当前要送往地点之外已送达地点，看时间是否更短\n                            if(S&( 1<<(j-1) )) {\n                                dp[S][i] = min(dp[S][i],dp[S^(1<<(i-1))][j] + dis[j][i]);\n                            }\n                            \n                            \n                        }\n                    }\n                }\n            }\n        }\n        ans = inf;\n        for(int i = 1; i <= N; ++i) {\n            ans = min(ans, dp[(1<<N)-1][i] + dis[i][0]);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n## [B - Travelling](https://vjudge.net/contest/389291#problem/B)\n### 题意\n给出N个城市、M条道路成本，Acmer先生想前往所有城市并且每个城市最多去两次，求最低所需费用，若找不到这样的路线则输出-1\n### 思路\n三进制状压dp，每位上0表示没去过，1表示去过1次，2表示去过2次，这里用cnt[i][j]来表示i在3进制下从右往左第j位，用three[i]为三进制的第i位位权 即three[i]类似于二进制中1<<i，最后若是全部访问过且每个不超过2次则跟ans比较\n### 代码\n```cpp\n// B - Travelling\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define div 1000000007\nconst int maxn = 12;\nconst int maxt = 59049;\nconst int inf  = 0x3f3f3f;\nint N,M,S,ans;\nint three[maxn];//three[i]为三进制的第i位最大值 类似于二进制中1<<i\nint map[maxn][maxn];\nint cnt[maxt][maxn];//cnt[i][j]表示i在3进制下从右往左第j位\nint dp[maxt][maxn];//dp[i][j]表示i状态下前往j城市后总费用\nvoid init() {\n    memset(dp, -1, sizeof(dp));\n    for(int i = 1; i <= N; ++i) {\n        for(int j = 1; j <= N; ++j) {\n            map[i][j] = inf;\n        }\n        map[i][i] = 0;\n    }\n}\nint main(){\n    int x = 3;\n    three[0] = 0;\n    three[1] = 1;\n    for(int i = 2; i < maxn; ++i) {\n        three[i] = x;\n        x *= 3;\n    }\n    for(int i = 0; i < three[maxn-1]; ++i) {\n        int now = i;\n        for(int j = 1; j <= 10 && now; ++j) {\n            cnt[i][j] = now % 3;\n            now /= 3;\n        }\n    }\n    while(~scanf(\"%d %d\", &N, &M)) {\n        init();\n        for(int i = 1; i <= M; ++i) {\n            int u,v,w;\n            scanf(\"%d %d %d\", &u, &v, &w);\n            if(w < map[u][v]) {\n                map[u][v] = map[v][u] = w;\n            }\n        }\n        for(int i = 1; i <= N; ++i) {\n            dp[three[i]][i] = 0;\n        }\n        int ans = inf;\n        for(int S = 0; S < three[maxn-1]; ++S) {//S的所有状态\n            bool allvis = true;\n            for(int i = 1; i <= N; ++i) {//枚举每个城市\n                if(cnt[S][i] == 0)   //该状态下有城市还没有被访问过\n                    allvis = false;\n                if(dp[S][i] == -1) continue;\n                for(int j = 1; j <= N; ++j) {   //枚举下一个能访问的城市\n                    if(i == j || map[i][j] == inf || cnt[S][j] >= 2) \n                        continue;   \n                    int nS = S+three[j];//下一个状态\n                    if(dp[nS][j] == -1 || dp[S][i] + map[i][j] < dp[nS][j]) { //下一个城市的总费用小\n                        dp[nS][j] = dp[S][i] + map[i][j];\n                    }\n                }\n            }\n            if(allvis) {\n                for(int i = 1; i <= N; ++i) {\n                    if(dp[S][i] != -1) {\n                        ans = min(ans, dp[S][i]);\n                    }\n                }\n            }\n        }\n        if(ans == inf) printf(\"-1\\n\");\n        else printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```\n","sources":["xlog"],"attributes":[{"value":"zhuang-ya-dp-mo-ban--fen-xi--li-ti--cun-yong-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/zhuang-ya-dp-mo-ban--fen-xi--li-ti--cun-yong-md"],"date_published":"2020-09-05T22:39:22.000Z"}}}