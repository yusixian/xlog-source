{"characterId":52270,"noteId":121,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreig73nnx6cjzlxttvm6vgsj5vwb6qxtmkywim47gric2z4eic76tae","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-08-26T19:32:59.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":24,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":24,"metadata":{"uri":"ipfs://bafkreig73nnx6cjzlxttvm6vgsj5vwb6qxtmkywim47gric2z4eic76tae","type":"NOTE","content":{"tags":["post","c++","数据结构","排序算法"],"type":"note","title":"数据结构学习笔记＜8＞ 排序","content":"---\ntitle: 数据结构学习笔记＜8＞ 排序\nlink: 数据结构学习笔记＜8＞ 排序\ncatalog: true\nlang: cn\ndate:  2020-08-26 19:32:59\nsubtitle: MOOC浙江大学的数据结构慕课学习记录——排序\ntags:\n- c++\n- 数据结构\n- 排序算法\ncategories:\n- [笔记, 数据结构]\n---\n\n\n# 一、拓扑排序\n## 1.概念定义\n### AOV网络\n例如，假定一个计算机专业的学生必须完成图3-4所列出的全部课程。从图中可以清楚地看出各课程之间的先修和后续的关系。如课程C5的先修课为C2，后续课程为C4和C6。通常，我们把这种顶点表示活动、边表示活动间先后关系的有向图称做顶点活动网(Activity On Vertex network)，简称AOV网。\n![以计算机](https://img-blog.csdnimg.cn/2020080821191843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n### 拓扑序、DAG\n - 若图中从V到W有一条有向路径，则V一定排在W之前。**满足该条件的顶点序列**称为一个拓扑序\n - **获得一个拓扑序的过程就是拓扑排序**\n - AOV若有合理的拓扑序，则必定是**有向无环图**（Directed Acyclic Graph,**DAG**）\n## 2.拓扑排序思路\n拓扑排序的思路是每次都找一个入度为0的顶点并输出，并且将该顶点所有邻接点入度减1。\n可以看出，找入度为0的顶点是关键，若每次都要遍历那必定会耗费大量时间空间，所以更聪明的算法是，**随时将入度变为0的顶点放入一个容器中。**\n伪码描述如下\n```cpp\nvoid TopSort() {\n\tint cnt = 0;\n    for(图中的每个顶点V) \n\t\tif( Indegree[W] == 0)\n\t\t\tEnqueue(V,Q);\n\twhile(!isEmpty(Q)) {\n\t\tV = Dequeue(Q);\n\t\t输出V,或记录V的输出序号,cnt++;\n        for(V的每个邻接点W)\n        \tif(--Indegree[W] == 0)\n\t            Enqueue(V,Q);\n\t}\n\tif(cnt != |V|)\n\t\tError(\"图中有回路\");\n}\n```\n模板代码：\n\n```cpp\nconst int maxn = 1005;\nint N,M;//顶点数、边数（活动数）\nint edge[maxn][maxn];\nint mint[maxn];//到每个活动检查点的最短时间\nint In[maxn];//每个活动检查点的入度\nvoid init() {\n    memset(edge, -1, sizeof(edge));\n    memset(mint, 0, sizeof(mint));\n    memset(In, 0, sizeof(In));\n}\nbool Topsort() {//拓扑排序\n    queue<int> q;\n    for(int i = 0; i < N; ++i) {\n        if(In[i] == 0) \n            q.push(i);\n    }\n    int cnt = 0;\n    while(!q.empty()) {\n        int v = q.front();\n        q.pop();\n        cnt++;\n        for(int i = 0; i < N; ++i) {\n            if(v == i || edge[v][i] == -1) continue;//检查以v为起点的所有边\n            In[i]--;\n            //其他操作\n            if(In[i] == 0) q.push(i);\n        }\n    }\n    if(cnt != N) return false;\n    else return true;\n}\n```\n\n## 例题\n[08-图8 How Long Does It Take (25分)](https://pintia.cn/problem-sets/1268384564738605056/problems/1286606445168746497)\n是一道拓扑排序的变形，程序不算复杂，建议尝试；\n题意、代码及思路指路博客：\n## 3.解决实际问题\n### 关键路径问题\n####  AOE网络(Activity On Edge)网络 \n - 一般用于安排项目的工序\n - 在AOE网络中，**活动是表示在边上的**，顶点被分为三个部分：顶点编号、最早完成时间和最晚完成时间\n![https://www.icourse163.org/learn/ZJU-93001?tid=1459700443#/learn/content?type=detail&id=1235254066&cid=1254945243&replay=true](https://img-blog.csdnimg.cn/20200808232540505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n##### 先推出最早完成时间 —— mint [ j ] = max( mint[ j ], mint[ i ]+edge[ i ][ j ])\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200808233007470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n##### 再由后往前推出最晚完工时间—— maxt[ i ] = min( maxt[ j ], maxt[ j ]-edge[ i ][ j ])\n##### 即可得机动时间—— D[ i ][ j ] = maxt[ j ] - mint[ i ] - edge[ i ][ j ]\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200808233514966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n而关键路径，是由**绝对不允许延误**的活动组成的路径，即**没有机动时间的路径。**\n###  例题\n[08-图8 How Long Does It Take (25分)](https://pintia.cn/problem-sets/1268384564738605056/problems/1286606445168746497)\n是一道拓扑排序的变形，求最早完成时间\n[08-图9 关键活动 (30分)](https://pintia.cn/problem-sets/1268384564738605056/problems/1286606445168746498)\n求关键路径\n代码及思路指路博客：[PTA数据结构题目集 第八周——图（下）](https://blog.csdn.net/qq_45890533/article/details/107885357)\n# 二、简单排序\n## 1.前提\n\n```cpp\nvoid X_Sort(ElementType A[], int N);\n```\n - 为简单起见，讨论整数的从小到大排序\n - N为**正**整数\n - 只讨论基于**比较**的排序（> = < 有定义）\n - 只讨论**内部**排序\n - **稳定性**:任意两个相等的数据排序前后的相对位置不发生改变\n - **没有哪一种排序是任何情况下都表现最好的！**\n## 2.排序算法\n测试题目：[09-排序1 排序 (25分)](https://pintia.cn/problem-sets/1268384564738605056/problems/1289169858763866112)\n### 冒泡排序\n\n> 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到**没有相邻元素需要交换，也就是说该元素列已经排序完成。**\n> 这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。\n> <p align=\"right\">——摘自百度百科</p>\n\n```cpp\nvoid Bubble_Sort(ll a[], int N) {\n    for(int P = N-1; P >= 0; P--) {\n        bool flag = false;\n        //一趟冒泡 从上往下比较，上边大于下边则交换\n        for(int i = 0; i < P; ++i) {    \n            if(a[i] > a[i+1]) {\n                swap(a[i], a[i+1]);\n                flag = true;\n            }\n        }\n        if(!flag) break; //一趟下来已经有序了，未发生交换\n    }\n}\n```\n#### 时间复杂度\n最好情况：顺序，时间复杂度 T = O(N)\n最坏情况：整个逆序，时间复杂度 T = O(N^2^)\n#### 优缺点\n优点：简单易写，只需交换相邻元素，即使是单向链表也可直接排序，稳定（交换前后相等元素的位置不变）\n缺点：时间复杂度较大，慢！\n#### 测试结果\n测试结果如下，有3个样例没过\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200821181622149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n\n### 插入排序\n> 插入排序，一般也被称为直接插入排序。对于**少量元素**的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。\n> <p align=\"right\">——摘自百度百科</p>\n\n```cpp\nvoid Insertion_Sort(ll a[], int N) {\n    for(int P = 1; P < N; P++) {\n        ll t = a[P];//摸下一张牌\n        int i;\n        for(i = P; i > 0 && a[i-1] > t; --i) \n            a[i] = a[i-1];  //移出空位 直到前面那个这个元素小于当前元素\n        a[i] = t;   //新牌落位\n    }\n}\n```\n\n#### 时间复杂度\n最好情况：顺序，时间复杂度 T = O(N)\n最坏情况：整个逆序，时间复杂度 T = O(N^2^)\n一般情况下时间复杂度下界计算：\n交换两个相邻元素正好消去1个逆序对\n设有I个逆序对\n则T(N,I) = O(N+I)\n#### 优缺点\n优点:稳定\n缺点：比较次数不一定，比较次数越少，插入点后的数据移动越多，尤其是当数据总量庞大的时候\n\n#### 测试结果\n测试结果如下，挺给力的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200821183558941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n#### 如何提高效率\n有定理如下\n - 任意N个不同元素组成的序列平均具有N(N-1)/4个逆序对\n - 任何**仅以交换相邻两元素**来排序的算法，其平均时间复杂度为O(N^2^)\n\n**所以要提高算法效率，我们必须**\n - 每次消去不止1个逆序对！\n - 每次交换相隔较远的2个元素！\n### 希尔排序\n利用了插入排序的简单，克服插入排序只能交换相邻两元素的缺点。\n> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。\n> <p align=\"right\">——摘自百度百科</p>\n定义增量序列D~M~ >D~M-1~>…>D~1~ = 1\n对每个D~k~进行“D~k~间隔”排序（k=M，M-1，……，1）\n<font color=\"#dd0000\">注意:“D~k~间隔”有序的序列，在执行“D~k-1~间隔”排序后，仍然是“D~k~间隔”有序的！</font>\n#### 希尔增量序列选取\n - 原始希尔排序增量序列 D~M~ = N/2， D~k~ = D~k+1~ / 2\n \t- 增量元素不互质，则小增量可能根本不起作用！\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200821192636172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n```cpp\nvoid Shell_Sort(ll a[], int N) {\n    for(int D = N/2; D > 0; D /= 2) { //希尔增量序列\n        for(int P = D; P < N; ++P) { //插入排序\n            ll t = a[P];\n            int i;\n            for(i = P; i >= D && a[i-D] > t; i -= D) \n                a[i] = a[i-D];\n            a[i] = t;\n        }\n    }\n}\n```\n - Hibbard增量序列\n\t - D~k~ = 2^k^-1 ——相邻元素互质\n - Sedgewick增量序列等\n\n#### 优缺点\n优点:快，数据移动少！适用于数据量较大的情况\n缺点：不同的增量序列选取会导致算法复杂度差异，如何选取增量序列只能根据经验，不稳定\n\n#### 测试结果\n可以看到耗时都没超过100ms，在这些测试样例里的速度还是很理想的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200821193100810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n### 选择排序\n> 在介绍堆排序前，先介绍选择排序，老朋友了\n```cpp\nvoid Selection_Sort(ll a[], int N) {\n    for(int i = 0; i < N; ++i) {\n        int mini = 0;\n        ll ans = inf;\n        //找i后边的最小元 并将其位置赋给mini\n        for(int j = i; j <= N-1; ++j) {\n            if(a[j] < ans) {\n                ans = a[j];\n                mini = j;\n            }\n        }\n        //将未排序部分的最小元换到有序部分的最后位置\n        swap(a[i], a[mini]);\n    }\n}\n```\n\n#### 时间复杂度\n无论如何复杂度都为O(N^2^)\n\n#### 测试结果\n测试结果如下，虽然都能过，但后几个样例耗时都很大\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200821194724447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n### 堆排序\n> 这里以排成升序为例，我们需要将其原始数组调整成下标从0开始的最大堆，再将最大堆顶与当前最后的元素交换（相当于删除最大堆顶）后调整\n```cpp\nvoid swap(ll& x, ll& y) {\n    ll t = x;\n    x = y;\n    y = t;\n}\nvoid PercDown(ll a[], int N, int rt) {\n    //将N个元素的数组中以a[now]为根的子堆调整为最大堆\n    int father, son;\n    ll tmp = a[rt];\n    for(father = rt; (father*2+1) < N; father = son) {\n        son = father * 2 + 1;//左儿子\n        if(son != N-1 && a[son] < a[son+1]) //右儿子存在且比左儿子大\n            son++;\n        if(tmp >= a[son]) break;//找到该放的地方\n        else a[father] = a[son];//下滤\n    }\n    a[father] = tmp;\n}\ninline void BuildHeap(ll a[], int N) {\n    for(int i = N/2-1; i >= 0; --i) {\n        PercDown(a, N, i);\n    }\n}\nvoid Heap_Sort(ll a[], int N) {\n    BuildHeap(a, N);\n    for(int i = N-1; i > 0; --i) {\n        swap(a[0], a[i]);//最大堆顶a[0]与a[i]交换\n        PercDown(a, i, 0);//删除后进行调整\n    }\n}\n```\n\n#### 时间复杂度\n堆排序给出了最佳的平均时间复杂度\n最好情况O(nlogn)\n最坏情况O(nlogn)\n平均时间复杂度O(nlogn)\n#### 优缺点\n优点: 快！即使是最坏情况下性能也很优越，使用的辅助空间少\n缺点：不稳定，不适合对象的排序。\n#### 测试结果\n测试结果如下，好像比希尔排序给力些哦~\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020082515570814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n### 归并排序\n> 核心是有序子列的合并，这里给出递归实现的版本~非递归实现看这里哦[归并排序循环实现](https://blog.csdn.net/qq_45890533/article/details/108249317)\n```cpp\nvoid Merge(ll a[], int s, int m, int e, ll tmp[]) {\n    //将数组a的局部a[s,m]和a[m+1,e]合并到数组tmp,并保证tmp有序\n    //然后再拷贝回a[s,m]  时间复杂度O(e-m+1),即O(n);\n    int pb = s;//pb为tmp数组的下标\n    int p1 = s, p2 = m+1;//p1指向前一半p2指向后一半\n    while (p1 <= m && p2 <= e) {\n        if (a[p1] < a[p2])\n            tmp[pb++] = a[p1++];\n        else \n            tmp[pb++] = a[p2++];\n    }\n    while(p1 <= m) \n        tmp[pb++] = a[p1++];\n    while(p2 <= e) \n        tmp[pb++] = a[p2++];\n    for (int i = 0; i < e-s+1; ++i)\n        a[s+i] = tmp[i];\n}\nvoid MergeSort(ll a[], int s, int e, ll tmp[]) {\n    if (s < e) {//若s>=e则不做任何事情\n        int m = s + (e-s)/2;\n        MergeSort(a, s, m, tmp);//前一半排序\n        MergeSort(a, m+1, e, tmp);//后一半排序\n        Merge(a, s, m, e, tmp);//归并 将a中s到m和m+1到e的两个数组有序的归并\n    }\n}\n```\n\n#### 时间复杂度\n最好情况O(nlogn)\n最坏情况O(nlogn)\n平均时间复杂度O(nlogn)\n#### 优缺点\n优点: 稳定、快\n缺点：较占用空间\n#### 测试结果\n测试结果如下，你品，你细品\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200825193947126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n### 快速排序\n> 1.设k = a[0],将k挪到适当位置，使得比k小的元素都在k左边，比k大的元素都在k右边(在O(n)时间完成)\n> 2.把k左边的部分快速排序\n> 3.把k右边的部分快速排序\n> k为主元\n```cpp\nvoid QuickSort(ll a[], int s, int e){//将a[s,e]快排\n    if (s >= e)\n        return;\n    int k = a[s];\n    int i = s,j = e;\n    while (i != j) {\n        while (j > i && a[j] >= k)  --j;\n        swap(a[i],a[j]);\n        while (i < j && a[i] <= k)  ++i;\n        swap(a[i],a[j]);\n    }//处理完后a[i] = k;\n    QuickSort(a, s, i-1);//快排左边部分\n    QuickSort(a, i+1, e);//快排右边部分\n}\n```\n\n#### 时间复杂度\n最好情况每次正好中分O(nlogn)\n最坏情况O(N^2^)\n平均时间复杂度O(nlogn)\n#### 优缺点\n优点: 是所有内部排序的最快的算法\n缺点：不稳定，最坏情况下效率较慢！\n#### 测试结果\n测试结果如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200825195739968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n### 表排序\n> 当数据量大且待排序的元素为对象、移动所需时间特别高时，我们需要**间接排序**\n> 定义一个指针数组作为“表”（table），记录待排元素\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200826162743812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n#### 时间复杂度\n最好情况初始即有序\n最坏情况有N/2个环，每个环包含2个元素，交换两个元素需要走三步，需要3N/2次元素移动\nT = O(m N)，m是每个A元素的复制时间\n### 基数排序（桶排序的推广）\n> 之前讲的算法都需要比较，最坏情况下也都有Nlogn，还能更快吗？\n> 假设我们有N个学生，他们的成绩是0~100之间的整数（于是**有M = 101个不同的成绩值**），如何在**线性时间**内将学生按成绩排序\n> LSD主位优先 MSD次位优先![在这里插入图片描述](https://img-blog.csdnimg.cn/20200826165348423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020082616515848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n\n基数排序的代码我参考了这篇博客的，用的方法**非常巧妙**：[基数排序](https://www.cnblogs.com/skywang12345/p/3603669.html)\n\n```cpp\nll getMax(ll a[], int n) {//找n个元素的a数组中最大数\n    int maxx = a[0];\n    for(int i = 1; i < n; ++i) {\n        if(a[i] > maxx) maxx = a[i];\n    }\n    return maxx;\n}\nvoid radixsort(ll a[], int n, int exp) { //对n个元素的数组a按照\"某个位数\"进行排序(桶排序),基数为10\n    ll tmp[maxn];\n    ll T[20] = {0}; //有负数的十进制 二十个桶\n    for(int i = 0; i < n; ++i) //T存储该桶里有多少个数\n        T[(a[i]/exp)%10 + 10]++;\n    for(int i = 1; i < 20; ++i) //让T的值是在tmp中的位置\n        T[i] += T[i-1];\n    for(int i = n - 1; i >= 0; --i) {\n        int now = T[(a[i]/exp)%10 + 10];//当前这个数所应在的位置\n        tmp[now-1] = a[i];\n        T[(a[i]/exp)%10 + 10]--;\n    }\n    for(int i = 0; i < n; ++i)\n        a[i] = tmp[i]; //将排好序的tmp赋给a\n}\nvoid Radix_Sort(ll a[], int n) {\n    ll maxnum = getMax(a, n);\n    for(int exp = 1; maxnum/exp > 0; exp *= 10) \n        radixsort(a, n, exp);\n}\n```\n\n#### 时间复杂度\nN为待排序元素个数，而B是桶数\nO(P(N+B)) 一趟分配时间为O(N)，一趟收集时间复杂度为O(B)，共进行P趟分配和收集\n#### 优缺点\n优点：适用于位数不多，待排序列最大位数不是特别大的情况，快\n缺点：空间换时间\n\n#### 测试结果\n测试结果如下，超快的说~\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200826190332331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n# 三、排序算法的比较\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200826192613486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70#pic_center)\n","sources":["xlog"],"attributes":[{"value":"shu-ju-jie-gou-xue-xi-bi-ji-8-pai-xu-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/shu-ju-jie-gou-xue-xi-bi-ji-8-pai-xu-md"],"date_published":"2020-08-26T19:32:59.000Z"}}}