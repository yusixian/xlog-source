{"characterId":52270,"noteId":20,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreihyildquofwr6cj3mbrqstfgwgu3rfhruigyxp6uoef4furon63uq","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:36:12.000Z","updatedAt":"2023-04-05T06:36:12.000Z","deletedAt":null,"publishedAt":"2022-03-19T20:00:56.000Z","transactionHash":"0xb7216c8d5fe8021bfcdec160f48a3012b791b8beaff373f9040a0b29932022b2","blockNumber":30317477,"logIndex":0,"updatedTransactionHash":"0xb7216c8d5fe8021bfcdec160f48a3012b791b8beaff373f9040a0b29932022b2","updatedBlockNumber":30317477,"updatedLogIndex":0,"metadata":{"uri":"ipfs://bafkreihyildquofwr6cj3mbrqstfgwgu3rfhruigyxp6uoef4furon63uq","type":"NOTE","content":{"tags":["post","前端","笔试题"],"type":"note","title":"2022春360笔试题目复盘-研发E卷","content":"---\ntitle: 2022春360笔试题目复盘-研发E卷\nlink: 360-examination-2022-spring-frontend\ncatalog: true\nlang: cn\ndate: 2022-03-19 20:00:56 \nsubtitle: 只有两道编程题，难度very easy(相比起美团的) 终于有个能AK的笔试了(x)\ncover: img/header_img/galaxy-ngc-3190-wallpaper-for-2880x1800-60-653.jpg\ntags:\n- 前端\n- 笔试题\ncategories:\n- [笔试面经, 笔试复盘]\n---\n\n360笔试题目复盘-研发E卷，前端开发的笔试题，包括选择题30道与两道编程\n# 选择题（30道）\n啥都考，巴拉巴拉巴拉的，数据库啊高数啊方程啊，后半段前端题居多。\n# 编程题-1 强密码验证（简易）\n要求大致为\n- 密码长度为8以上\n- 必须包含数字、大写字母、小写字母和特殊符号（缺一不可）\n\n输入样例\n```\n12_Aaqq12\nPassword123\nPASSWORD_123\nPaSS^word\n12_Aaqq\n```\n\n输出样例\n```\nOk\nIrregular password\nIrregular password\nIrregular password\nIrregular password\n```\n## 思路\njs的话写个正则就好了，但是我正则玩不溜qwq\n只能遍历一遍判断了，也没啥问题一遍过,非常的简单粗暴啊（小孩子不要学）\n## 代码\n```cpp\n#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\nstring str;\nbool judge(string s) {\n    int len = s.length();\n    if(len < 8) return false;\n    bool flag[4];   // 有数字 \n    memset(flag, false, sizeof(flag));\n    int cnt = 0;\n    for(int i = 0; i < len; ++i) {\n        if(s[i] >= 'A' && s[i] <= 'Z') {\n            if(!flag[0]) {\n                flag[0] = true;\n                ++cnt;\n            }\n        } else if(s[i] >= 'a' && s[i] <= 'z') {\n            if(!flag[1]) {\n                flag[1] = true;\n                ++cnt;\n            }\n        } else if(s[i] >= '0' && s[i] <= '9') {\n            if(!flag[2]) {\n                flag[2] = true;\n                ++cnt;\n            }\n        } else if(!flag[3]) {   // 特殊字符\n            flag[3] = true;\n            ++cnt;\n        }\n        if(cnt == 4) return true;\n    }\n    return false;\n}\nint main() {\n    while(cin >> str) {\n        if(judge(str)) cout << \"Ok\" << endl;\n        else cout << \"Irregular password\" << endl;\n    }\n    return 0;\n}\n```\n\n# 编程题-2 堆积货物（Web）\n大意就是，原有R*C*L的货物堆成一个长方体，被小偷偷成了(R-2)*(C-1)*(L-2)的长方体。\n通过现在的货物总数。算出最坏情况下被偷了多少的货物，输出这个最坏的值。\n\n输入描述\n输入为一个数n,表示题面中的(R-2)*(C-1)*(L-2)\n\n输出描述\n输出为一个数，表示最坏情况下被偷了多少的货物\n\n样例输入\n```\n4\n```\n样例输出\n```\n41\n```\n\n提示\n对于100%的数据：1 ≤ n ≤ 10^9 \n样例解释：`R=3,C=5,L=3, 3*5 * 3-(3-2)*(5-1)*(3-2)=41`\n\n## 分析\n3 2 3 = 18\n1 1 1 = 1\n偷走了17\n4 2 5 = 40\n2 1 3 = 6\n偷走了34\n\n偷走三个长方体  偷走体积为`1*(R+2)*(L+2)+ 2*R*C +2*(R+2)*C`\n（估计是可以用数学推出来的，不过我暴力然后剪枝之后也ac100%了）\n俺的暴力解法：设r、l、c分别为偷走后的长宽高，R = r+2, L = l+2, C = c+1，易知rcl肯定都为n的因数，将n分解质因数后把所有质因数存在m中，遍历m取得每个r、l、c，中途再剪剪枝，当前两个数乘起来已经大于n了的时候就跳过。\n## 代码\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nint n;\nll ans;\nvector<ll> m;\nint main() {\n    cin >> n;\n    int k = sqrt(n);\n    for(int i = 1; i <= k; ++i) {  \n        if(n % i == 0) {\n            m.push_back(i);\n            m.push_back(n/i);\n        }\n    }\n    sort(m.begin(), m.end());\n    int len = m.size();\n    for(int r = 0; r < len; ++r) {\n        for(int l = 0; l < len; ++l) {\n            ll t = m[r]*m[l];\n            if(t > n) continue; // 剪枝\n            for(int c = 0; c < len; ++c) {\n                ll nown = t*m[c];\n                if(nown != n) continue;\n                ll R = m[r]+2;\n                ll L = m[l]+1;\n                ll C = m[c]+2;\n                ll stole = ll(R*L*C) - nown;\n                ans = max(ans, stole);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n","sources":["xlog"],"attributes":[{"value":"2022-chun-360-bi-shi-ti-mu-fu-pan---yan-fa-E-juan-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/2022-chun-360-bi-shi-ti-mu-fu-pan---yan-fa-E-juan-md"],"date_published":"2022-03-19T20:00:56.000Z"}}}