{"characterId":52270,"noteId":115,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreiflivm4o3bwap2o4dxtb4nme3c77rdpdnrqs6z5cz635ikjuajjyq","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-02-28T12:26:41.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":18,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":18,"metadata":{"uri":"ipfs://bafkreiflivm4o3bwap2o4dxtb4nme3c77rdpdnrqs6z5cz635ikjuajjyq","type":"NOTE","content":{"tags":["post","c++","数据结构","堆栈"],"type":"note","title":"数据结构学习笔记＜2＞ 堆栈","content":"---\ntitle: 数据结构学习笔记＜2＞ 堆栈\nlink: 数据结构学习笔记＜2＞ 堆栈\ncatalog: true\nlang: cn\ndate:  2020-02-28 12:26:41\nsubtitle: MOOC浙江大学的数据结构慕课学习记录——堆栈\ntags:\n- c++\n- 数据结构\n- 堆栈\ncategories:\n- [笔记, 数据结构]\n---\n\n##  一、堆栈的抽象数据类型描述\n类型名：堆栈（Stack）\n数据对象集：一个有0个或多个元素的有穷线性表\n操作集：长度为MaxSize的堆栈S∈Stack, 堆栈元素item∈ElementType\n\n> **1.生成空堆栈，其最大长度为MaxSize; \n> \tStack CreateStack(int MaxSize);\n> 2.判断堆栈S是否已满 \n> int IsFull(Stack S, int MaxSize);\n> 3.将元素item压入堆栈 \n> void Push(Stack S, ElementType item);\n> 4.判断堆栈S是否已空 \n> int IsEmpty(Stack S);\n> 5.删除并返回栈顶元素 \n> ElementType Pop(Stack S);**\n## 二、栈的顺序存储实现\n### 1.定义\n栈的顺序存储结构通常由**一个一维数组**和**一个记录栈顶元素位置的变量**组成\n\n```cpp\n#define MaxSize <储存数据元素的最大个数>\ntypedef struct SNode *Stack;//定义SNode的结构指针可以用Stack\nstruct SNode {\n    ElementType Data[MaxSize];//一维数组\n    int Top;//记录栈顶元素\n};\n```\nStack PtrS 既定义了一个指向SNode 的结构体指针PtrS\n\n### 2.操作\n#### (1)入栈操作(Push)\nTop值加一，存储元素item在栈顶\n```cpp\nvoid Push(Stack PtrS, ElementType item) {\n    if (PtrS->Top == MaxSize-1) {//堆栈全部放满了\n        printf(\"堆栈满\");\n        return;\n    } else {    //堆栈未满，执行入栈操作\n        PtrS->Data[++(PtrS->Top)] = item;//Top值先增加，然后存储\n        return;\n    }\n}\n```\n#### (2)出栈操作(Pop)\n将元素弹出,Top值减一\n\n```cpp\nElementType Pop(Stack PtrS) {\n    if(PtrS->Top == -1) {//堆栈为空\n        printf(\"堆栈空\");\n        return ERROR;//ERROR是ElementType的特殊值，表示错误。\n    } else \n        return (PtrS->Data[(PtrS->Top)--]) //先把栈顶元素返回，再将Top减一\n}\n```\n## 三、栈的链式存储实现\n### 1.定义\n栈的链式存储结构实际上就是一个**单链表**，叫做**链栈**，插入和删除操作只能在链栈的栈顶进行。**栈顶指针Top应在链表的头部！**\n\n```cpp\ntypedef struct SNode *Stack;\nstruct SNode {\n    ElementType Data;//当前数据\n    struct SNode* Next;//指向下一个Snode的指针\n};\n```\n### 2.操作\n#### (1)堆栈初始化（CreateStack）\n构建一个堆栈的头结点，返回指针\n```cpp\nStack CreateStack() {\n    Stack S;\n    S = (Stack)malloc(sizeof(struct SNode));\n    S->Next = NULL;\n    return S;\n}\n```\n#### (2)判断堆栈是否为空（IsEmpty）\n判断堆栈S是否为空,若为空函数返回1，否则返回0\n```cpp\nint IsEmpty(Stack S) {\n    return (S->Next == NULL);//若后面没节点，则为空\n}\n```\n#### (3)将元素item压入堆栈 (Push)\n先创建一个新结点的结构指针TmpCell，分配空间，然后将数据赋值为item，Next指针赋值为原先的S的Next指针。再将S的Next指针指向TmpCell。\n```cpp\nvoid Push(ElementType item, Stack S) {\n    Stack TmpCell;\n    TmpCell = (Stack) malloc(sizeof(struct SNode));\n    TmpCell->Data = item;\n    TmpCell->Next = S->Next;\n    S->Next = TmpCell;\n}\n```\n#### (4)删除并返回堆栈S的栈顶元素 (Pop)\n先暂存当前结点(S) ，将FirstCell赋值为S的Next指针，再将S的Next指针赋值为下一个的地址，既让S的Next指针直接指向第二个结点。然后将FirstCell内的数据取出并释放动态分配的内存，返回该数据。\n```cpp\nElementType Pop(Stack S) {\n    Stack FirstCell;\n    ElementType TopElem;\n    if(IsEmpty(S)) {//若为空\n        printf(\"堆栈空\");\n        return NULL;\n    } else {\n        FirstCell = S->Next;//先把指向下一个结点的指针存起来\n        S->Next = FirstCell->Next;\n        TopElem = FirstCell->Data;\n        free(FirstCell);\n        return TopElem;\n    }\n}\n```\n## 四、堆栈应用（表达式求值）\n中缀表达式如何转换为后缀表达式？\n**从头到尾读取中缀表达式的每个对象，对不同对象按照不同情况处理**\n\n##### 1. 运算数：直接输出。\n##### 2. 左括号：压入堆栈。\n##### 3. 右括号：将栈顶的运算符弹出并输出，直到遇到左括号（出栈，不输出）\n##### 4. 运算符：优先级大于栈顶运算符时，将其压入栈中；优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出，再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级位置，然后将该运算符压入栈中。\n##### 5. 若各对象处理完毕，则将堆栈中存留的运算符一并输出。\n堆栈的其他应用：函数调用与递归实现、深度优先搜索、回溯算法等……","sources":["xlog"],"attributes":[{"value":"shu-ju-jie-gou-xue-xi-bi-ji-2-dui-zhan-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/shu-ju-jie-gou-xue-xi-bi-ji-2-dui-zhan-md"],"date_published":"2020-02-28T12:26:41.000Z"}}}