{"characterId":52270,"noteId":26,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreicujy7ewfeuus3abu3ycaqrgup55ieeedr2zx3wzevs47yxladlei","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:38:05.000Z","updatedAt":"2023-04-05T06:38:05.000Z","deletedAt":null,"publishedAt":"2020-04-01T20:08:52.000Z","transactionHash":"0xbfab47b82ecebba6e9fc656935da117e29078d33b8ae11d03dbc25062e62f2ae","blockNumber":30317590,"logIndex":1,"updatedTransactionHash":"0xbfab47b82ecebba6e9fc656935da117e29078d33b8ae11d03dbc25062e62f2ae","updatedBlockNumber":30317590,"updatedLogIndex":1,"metadata":{"uri":"ipfs://bafkreicujy7ewfeuus3abu3ycaqrgup55ieeedr2zx3wzevs47yxladlei","type":"NOTE","content":{"tags":["post","c++","线段树","数据结构"],"type":"note","title":"RMQ问题——线段树","content":"---\ntitle: RMQ问题——线段树\nlink: RMQ问题——线段树\ncatalog: true\nlang: cn\ndate: 2020-04-01 20:08:52\nsubtitle: ~RMQ问题之线段树板子~\ntags:\n- c++\n- 线段树\n- 数据结构\ncategories:\n- [笔记, 算法]\n---\n\n上篇说到RMQ问题可以用ST表算法处理，但需要在线修改的时候，线段树是更好的选择。\n如图，很明显线段树是个二叉搜索树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200401162921333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n要注意的点如下：\n 1. 线段树用数组存储，**数组空间**简单的就一般开到原数组的4*n倍（准确的说是将n向上扩充到2的幂次方然后乘2，如5->8->16）\n 2. 线段树数组存储中，某个结点的编号为n，则其**左子结点**编号为2 * n（**表示成 n << 1**）,**右子节点**编号为2*n+1(表示为 **n << 1 | 1**)\n 3. 规定根节点为1\n\n##  一、查询区间最值（点修改）\n[模板题：hihoCoder #1077  RMQ问题再临-线段树](http://hihocoder.com/problemset/problem/1077)\n题目大意：给出一个数组A，每次有查询或修改两种操作，此处是查询区间l到r上的最小值，或将编号为p的值改为v。\n用线段树维护最值，想要改成查询最大值，只需把所有min改成max，然后把inf换成0\n### 1.建树\n```cpp\nvoid pushup(int rt) {//更新节点信息 这里以求最小值为例 可改为最大值\n    Tree[rt] = min(Tree[rt << 1], Tree[rt << 1|1]);\n}\nvoid Build(int l, int r, int rt) {//[l,r]表示区间，rt表示真实存储的编号\n    if (l == r) {//抵达叶结点\n        Tree[rt] = A[l];\n        return;\n    }\n    int mid = l+r>>1;\n    Build(l,mid,rt << 1);//先建好左结点\n    Build(mid+1,r,rt << 1 | 1);//再建好右节点\n    pushup(rt);//用左右节点更新信息\n}\n```\n### 2.更新\n调用时参数为根节点编号、修改位置p、要修改成的值v、修改影响的区间（即1~n）。\n```cpp\nvoid Update_point(int rt, int p, int val, int l, int r) {   //点修改\n    if (l == r) {\n        Tree[rt] = val;\n        return;\n    }\n    int mid = (l+r) >> 1;\n    if (p <= mid)//修改的位置如果是在左半区间，则更新左子树\n        Update_point(rt<<1, p, val, l, mid);\n    else Update_point(rt<<1|1, p, val, mid+1, r);//否则更新右子树\n    pushup(rt);//更新当前点~\n}\n```\n\n### 3.查询\n难点所在，调用时参数分别为根结点、整个区间(1 ~ n)、要查询的区间(x ~ y)\nps:要查询的区间是要一直传下去不会变的~当要查询的区间子区间为l ~ r时即可返回\n```cpp\nint query(int rt, int l, int r,int x, int y) {//从节点rt开始查询L到R的最小值/最大值/区间和 此处以最小值为例\n    if (x <= l && r <= y) {//当l ~ r为要查询的区间的子区间时可直接返回当前结点的值\n        return Tree[rt];\n    }\n    int mid = l+r >> 1;\n    int ans = inf;//若求最大值，将此处改为0\n    if (x <= mid) //若当前区间左端点小于等于mid，则肯定要查询左半区间\n        ans = min(query(rt<<1,l,mid,x,y), ans);\n    if (y > mid)//若当前区间右端点大于mid，则肯定要查询右半区间\n        ans = min(query(rt<<1|1,mid+1,r,x,y), ans); \n    return ans;\n}\n```\n\n### 完整代码\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n//定义\nconst int maxn = 1000005;\nconst int inf  = 0x3f3f3f;\nint Tree[maxn<<2];\nint A[maxn];\nint n;\nvoid pushup(int rt) {//向上更新节点信息 这里以求最小值为例 可改为最大值\n    Tree[rt] = min(Tree[rt << 1], Tree[rt << 1|1]);\n}\nvoid Build(int l, int r, int rt) {//[l,r]表示区间，rt表示真实存储的编号\n    if (l == r) {//抵达叶结点\n        Tree[rt] = A[l];\n        return;\n    }\n    int mid = l+r>>1;\n    Build(l,mid,rt << 1);//先建好左结点\n    Build(mid+1,r,rt << 1 | 1);//再建好右节点\n    pushup(rt);//用左右节点更新信息\n}\nvoid Update_point(int rt, int p, int val, int l, int r) {   //点修改\n    if (l == r) {\n        Tree[rt] = val;\n        return;\n    }\n    int mid = (l+r) >> 1;\n    if (p <= mid)//修改的位置如果是在左半区间，则更新左子树\n        Update_point(rt<<1, p, val, l, mid);\n    else Update_point(rt<<1|1, p, val, mid+1, r);//否则更新右子树\n    pushup(rt);//更新当前点~\n}\nint query(int rt, int l, int r,int x, int y) {//从节点rt开始查询L到R的最小值/最大值/区间和 此处以最小值为例\n    if (x <= l && r <= y) {//当l ~ r为要查询的区间的子区间时可直接返回当前结点的值\n        return Tree[rt];\n    }\n    int mid = l+r >> 1;\n    int ans = inf;//若求最大值，将此处改为0\n    if (x <= mid) //若当前区间左端点小于等于mid，则肯定要查询左半区间\n        ans = min(query(rt<<1,l,mid,x,y), ans);\n    if (y > mid)//若当前区间右端点大于mid，则肯定要查询右半区间\n        ans = min(query(rt<<1|1,mid+1,r,x,y), ans); \n    return ans;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for(int i = 1; i <= n; i++) {\n        cin >> A[i];\n    }\n    Build(1,n,1);\n    int T;\n    cin >> T;\n    while(T--) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        if (a == 1) {\n            Update_point(1,b,c,1,n);\n        } else {\n            int ans = query(1,1,n,b,c);\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n```\n## 二、区间修改（和、差、积、商等）\n### 1.区间加操作\n[洛谷 P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)\n大意为：已知一个数列，你需要进行下面两种操作：\n1.将某区间每一个数加上 kk。\n2.求出某区间每一个数的和。\n[大神题解](https://www.luogu.com.cn/problemnew/solution/P3372)\n~~大神都写这么详细了我还写这个干嘛啊~~\n~~算了算了自己敲一遍留着看也不错嘛~~  \n我们可以用线段树来维护区间和，以及修改的话是进行修改区间修改~这就需要一个标记数组标记，其实点修改就是区间修改的一个子问题\n#### pushdown操作\n向下更新，因为懒标记add记录了对其子结点的影响，所以需要一个向下传递影响的函数\n\n```cpp\ninline void f(int rt, int l, int r, ll k) {//给当前结点加上k的影响，并更新其懒标记\n    Tree[rt] += k * (r-l+1);//区间和 这里维护的是区间和，区间内每个数都加上k\n    add[rt] += k;\n}\nvoid pushdown(int rt, int l, int r) {\n    int mid = l+r >>1;\n    f(rt<<1, l, mid, add[rt]);//更新左儿子的懒标记及其维护的值(区间和)\n    f(rt<<1|1, mid+1, r, add[rt]);//更新右儿子的懒标记及其维护的值(区间和)\n    add[rt] = 0;//当前懒标记置为0\n}\n```\n#### 更新区间\n\n```cpp\nvoid Update_section(int rt, int val, int l, int r, int rl, int rr) {   //区间修改\n    if (rl <= l && r <= rr) {//~当前区间为要修改的区间的子区间时直接更新其值和懒标记~\n        f(rt, l, r, val);\n        return;\n    }\n    pushdown(rt, l, r);//下一次递归前，先将当前结点的影响向下传递，然后更新当前结点\n    int mid = (l+r) >> 1;\n    if (rl <= mid)//修改的区间如果能影响到左半区间，则更新左子树\n        Update_section(rt<<1, val, l, mid, rl, rr);\n    if (rr > mid)\n        Update_section(rt<<1|1, val, mid+1, r, rl, rr);//否则更新右子树\n    pushup(rt);//~向上更新~\n}\n```\n\n#### 完整代码\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n//定义\ntypedef long long ll;\nconst int maxn = 1000005;\nconst int inf  = 0x3f3f3f;\nll add[maxn<<2];//懒标记 即对其所有子结点的影响 不包括其自身\nll Tree[maxn<<2];\nll A[maxn];\nint n, T;\ninline void pushup(int rt) {//向上更新节点信息 即用左孩子和右孩子的值来更新当前结点\n    Tree[rt] = Tree[rt << 1]+Tree[rt << 1|1];\n}\ninline void f(int rt, int l, int r, ll k) {//给当前结点加上k的影响，并更新其懒标记\n    Tree[rt] += k * (r-l+1);//区间和 这里维护的是区间和，区间内每个数都加上k\n    add[rt] += k;\n}\nvoid pushdown(int rt, int l, int r) {\n    int mid = l+r >>1;\n    f(rt<<1, l, mid, add[rt]);//更新左儿子的懒标记及其维护的值(区间和)\n    f(rt<<1|1, mid+1, r, add[rt]);//更新右儿子的懒标记及其维护的值(区间和)\n    add[rt] = 0;//当前懒标记置为0\n}\nvoid Build(int l, int r, int rt) {//[l,r]表示区间，rt表示真实存储的编号\n    add[rt] = 0;\n    if (l == r) {//抵达叶结点\n        Tree[rt] = A[l];\n        return;\n    }\n    int mid = l+r>>1;\n    Build(l,mid,rt << 1);//先建好左结点\n    Build(mid+1,r,rt << 1 | 1);//再建好右节点\n    pushup(rt);//用左右节点更新信息\n}\nvoid Update_section(int rt, int val, int l, int r, int rl, int rr) {   //区间修改\n    if (rl <= l && r <= rr) {//~当前区间为要修改的区间的子区间时直接更新其值和懒标记~\n        f(rt, l, r, val);\n        return;\n    }\n    pushdown(rt, l, r);//下一次递归前，先将当前结点的影响向下传递，然后更新当前结点\n    int mid = (l+r) >> 1;\n    if (rl <= mid)//修改的区间如果能影响到左半区间，则更新左子树\n        Update_section(rt<<1, val, l, mid, rl, rr);\n    if (rr > mid)\n        Update_section(rt<<1|1, val, mid+1, r, rl, rr);//否则更新右子树\n    pushup(rt);//~向上更新~\n}\nll query(int rt, int l, int r,int x, int y) {//从节点rt开始查询l到r的中x~y的区间和 此处以最小值为例\n    if (x <= l && r <= y) {//当l ~ r为要查询的区间的子区间时可直接返回当前结点的值\n        return Tree[rt];\n    }\n    int mid = l+r >> 1;\n    ll ans = 0;\n    pushdown(rt, l, r);\n    if (x <= mid) //若当前区间左端点小于等于mid，则肯定要查询左半区间\n        ans += query(rt<<1,l,mid,x,y);\n    if (y > mid)//若当前区间右端点大于mid，则肯定要查询右半区间\n        ans += query(rt<<1|1,mid+1,r,x,y); \n    return ans;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin >> n >> T;\n    for(int i = 1; i <= n; i++) {\n        cin >> A[i];\n    }\n    Build(1,n,1);\n    while(T--) {\n        int a, l, r;\n        cin >> a;\n        if (a == 1) {\n            int k;\n            cin >> l >> r >> k;\n            Update_section(1, k, 1, n, l, r);\n        } else {\n            cin >> l >> r;\n            ll ans = query(1, 1, n, l, r);\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n```\n\n### 2.区间加、乘操作（较完整）\n[洛谷 P3373【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)\n[大神题解](https://www.luogu.com.cn/problemnew/solution/P3373)\n这题就是在上一题的基础上变成可将某区间每个数乘/加上一个数，则需要两个懒标记数组add、mul，而在更新懒标记操作中也要注意若要更新add标记则只更新add,**若要更新mul则更新mul的同时也必须更新add（add乘上k）**\n先乘后加！！\n先乘后加！！！\n先乘后加！！！\n重要的事情说三遍\n\n#### pushdown操作的变动\n主要是f函数的变动\n注意到f函数的功能是给当前结点rt的值加上上一个结点ft的所有影响（懒标记带来的），并更新当前结点ft的懒标记\n```cpp\ninline void f(int rt, int l, int r, int ft) {//给当前结点rt加上上一个结点ft的所有影响，更新其懒标记\n    //先乘后加！！更新其值\n    Tree[rt] = (Tree[rt] * mul[ft]) % p;\n    Tree[rt] = (Tree[rt] + add[ft] * (r-l+1)) % p;\n    //更新懒标记，mul直接更新(*父结点的mul)\n    mul[rt] = (mul[rt] * mul[ft]) % p;\n    //add应先*父结点的mul标记,然后再+父节点的add标记！！！\n    add[rt] = (add[rt] * mul[ft]) % p;\n    add[rt] = (add[rt] + add[ft]) % p;\n}\nvoid pushdown(int rt, int l, int r) {\n    int mid = l+r >>1;\n    f(rt<<1, l, mid, rt);//更新左儿子的懒标记及其维护的值\n    f(rt<<1|1, mid+1, r, rt);//更新右儿子的懒标记及其维护的值\n    add[rt] = 0;\n    mul[rt] = 1;//当前懒标记\n}\n```\n#### 更新操作变动（分两种更新）\n加更新~\n```cpp\nvoid Update_section_add(int rt,int val, int l, int r, int rl, int rr) {   //区间修改 +val\n    if (rl <= l && r <= rr) {//~当前区间为要修改的区间的子区间时直接更新其值和懒标记~\n        Tree[rt] =  (Tree[rt] + val * (r-l+1)) % p;//给当前结点加上val的+影响，并更新其懒标记\n        add[rt] = (add[rt] + val) % p;\n        return;\n    }\n    pushdown(rt, l, r);//下一次递归前，先将影响向下传递\n    int mid = (l+r) >> 1;\n    if (rl <= mid)//修改的区间如果能影响到左半区间，则更新左子树\n        Update_section_add(rt<<1, val, l, mid, rl, rr);\n    if (rr > mid)\n        Update_section_add(rt<<1|1, val, mid+1, r, rl, rr);//否则更新右子树\n    pushup(rt);//开始回溯~向上更新~\n}\n```\n乘更新~乘会影响到加的懒标记！\n```cpp\nvoid Update_section_mul(int rt,int val, int l, int r, int rl, int rr) {   //区间修改 *val\n    if (rl <= l && r <= rr) {//~当前区间为要修改的区间的子区间时直接更新其值和懒标记~\n        Tree[rt] = (Tree[rt] * val) % p;\n        mul[rt] = (mul[rt] * val) % p;\n        add[rt] = (add[rt] * val) % p;//very重要！！\n        return;\n    }\n    pushdown(rt, l, r);//下一次递归前，先将影响向下传递\n    int mid = (l+r) >> 1;\n    if (rl <= mid)//修改的区间如果能影响到左半区间，则更新左子树\n        Update_section_mul(rt<<1, val, l, mid, rl, rr);\n    if (rr > mid)\n        Update_section_mul(rt<<1|1, val, mid+1, r, rl, rr);//否则更新右子树\n    pushup(rt);//开始回溯~向上更新~\n}\n```\n\n#### 完整代码\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n//定义\ntypedef long long ll;\nconst int maxn = 1000005;\nll add[maxn<<2];//懒标记1 即对其所有子结点的影响 不包括其自身\nll mul[maxn<<2];//懒标记2\nll Tree[maxn<<2];\nll A[maxn];\nint n, T;\nll p;\ninline void pushup(int rt) {//向上更新节点信息 即用左孩子和右孩子的值来更新当前结点\n    Tree[rt] = Tree[rt << 1]+Tree[rt << 1|1];\n}\ninline void f(int rt, int l, int r, int ft) {//给当前结点rt加上上一个结点ft的k的所有影响，更新其懒标记\n    //先乘后加！！\n    Tree[rt] = (Tree[rt] * mul[ft]) % p;\n    Tree[rt] = (Tree[rt] + add[ft] * (r-l+1)) % p;\n    //mul直接更新\n    mul[rt] = (mul[rt] * mul[ft]) % p;\n    //加的懒标记应先*父结点的mul标记,然后再+父节点的add标记！！！\n    add[rt] = (add[rt] * mul[ft]) % p;\n    add[rt] = (add[rt] + add[ft]) % p;\n}\nvoid pushdown(int rt, int l, int r) {\n    int mid = l+r >>1;\n    f(rt<<1, l, mid, rt);//更新左儿子的懒标记及其维护的值\n    f(rt<<1|1, mid+1, r, rt);//更新右儿子的懒标记及其维护的值\n    add[rt] = 0;\n    mul[rt] = 1;//当前懒标记\n}\nvoid Build(int l, int r, int rt) {//[l,r]表示区间，rt表示真实存储的编号\n    add[rt] = 0;\n    mul[rt] = 1;\n    if (l == r) {//抵达叶结点\n        Tree[rt] = A[l];\n        return;\n    }\n    int mid = l+r>>1;\n    Build(l,mid,rt << 1);//先建好左结点\n    Build(mid+1,r,rt << 1 | 1);//再建好右节点\n    pushup(rt);//用左右节点更新信息\n}\nvoid Update_section_add(int rt,int val, int l, int r, int rl, int rr) {   //区间修改 +val\n    if (rl <= l && r <= rr) {//~当前区间为要修改的区间的子区间时直接更新其值和懒标记~\n        Tree[rt] =  (Tree[rt] + val * (r-l+1)) % p;//给当前结点加上val的+影响，并更新其懒标记\n        add[rt] = (add[rt] + val) % p;\n        return;\n    }\n    pushdown(rt, l, r);//下一次递归前，先将影响向下传递\n    int mid = (l+r) >> 1;\n    if (rl <= mid)//修改的区间如果能影响到左半区间，则更新左子树\n        Update_section_add(rt<<1, val, l, mid, rl, rr);\n    if (rr > mid)\n        Update_section_add(rt<<1|1, val, mid+1, r, rl, rr);//否则更新右子树\n    pushup(rt);//开始回溯~向上更新~\n}\nvoid Update_section_mul(int rt,int val, int l, int r, int rl, int rr) {   //区间修改 *val\n    if (rl <= l && r <= rr) {//~当前区间为要修改的区间的子区间时直接更新其值和懒标记~\n        Tree[rt] = (Tree[rt] * val) % p;\n        mul[rt] = (mul[rt] * val) % p;\n        add[rt] = (add[rt] * val) % p;//very重要！！\n        return;\n    }\n    pushdown(rt, l, r);//下一次递归前，先将影响向下传递\n    int mid = (l+r) >> 1;\n    if (rl <= mid)//修改的区间如果能影响到左半区间，则更新左子树\n        Update_section_mul(rt<<1, val, l, mid, rl, rr);\n    if (rr > mid)\n        Update_section_mul(rt<<1|1, val, mid+1, r, rl, rr);//否则更新右子树\n    pushup(rt);//开始回溯~向上更新~\n}\nll query(int rt, int l, int r,int x, int y) {//从节点rt开始查询l到r的中x~y的区间和 此处以最小值为例\n    if (x <= l && r <= y) {//当l ~ r为要查询的区间的子区间时可直接返回当前结点的值\n        return Tree[rt];\n    }\n    int mid = l+r >> 1;\n    ll ans = 0;\n    pushdown(rt, l, r);\n    if (x <= mid) //若当前区间左端点小于等于mid，则肯定要查询左半区间\n        ans = (ans + query(rt<<1,l,mid,x,y)) % p;\n    if (y > mid)//若当前区间右端点大于mid，则肯定要查询右半区间\n        ans = (ans + query(rt<<1|1,mid+1,r,x,y)) % p; \n    return ans;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin >> n >> T >> p;\n    for(int i = 1; i <= n; i++) {\n        cin >> A[i];\n    }\n    Build(1,n,1);\n    while(T--) {\n        int a, l, r;\n        cin >> a;\n        if (a == 1) {\n            int k;\n            cin >> l >> r >> k;\n            Update_section_mul(1, k, 1, n, l, r);\n        } else if(a == 2) {\n            int k;\n            cin >> l >> r >> k;\n            Update_section_add(1, k, 1, n, l, r);\n        } else {\n            cin >> l >> r;\n            ll ans = query(1, 1, n, l, r);\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n```\n然后~ 恭喜ac ~ 耶~！\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200401195719322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)","sources":["xlog"],"attributes":[{"value":"RMQ-wen-ti--xian-duan-shu-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/RMQ-wen-ti--xian-duan-shu-md"],"date_published":"2020-04-01T20:08:52.000Z"}}}