{"characterId":52270,"noteId":39,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreic7eigo3vfiwkx7pwltbimeihzys3h3aqp447pejzr45k4o5uteh4","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:39:04.000Z","updatedAt":"2023-04-05T06:39:04.000Z","deletedAt":null,"publishedAt":"2022-05-08T23:44:01.000Z","transactionHash":"0xdc576b85b753d220cd2851aa2bc5e951b6f739ada0a82dfd613ec82afbd0296e","blockNumber":30317649,"logIndex":5,"updatedTransactionHash":"0xdc576b85b753d220cd2851aa2bc5e951b6f739ada0a82dfd613ec82afbd0296e","updatedBlockNumber":30317649,"updatedLogIndex":5,"metadata":{"uri":"ipfs://bafkreic7eigo3vfiwkx7pwltbimeihzys3h3aqp447pejzr45k4o5uteh4","type":"NOTE","content":{"tags":["post","后端","Go"],"type":"note","title":"Go语言初上手（二） 工程实践 | 青训营","content":"---\ntitle: Go语言初上手（二） 工程实践 | 青训营\nlink: back-end/go_learning_2\ncatalog: true\nlang: cn\ndate: 2022-05-08 23:44:01\nsubtitle: Go语言工程实践\nquiz: true\ntags:\n- 后端\n- Go\ncategories:\n- [笔记, 青训营笔记]\n---\n\n# 并发编程\n- **并发** 是多线程程序在一个核的cpu上运行\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a70946937e54495499958900ad320e99~tplv-k3u1fbpfcp-watermark.image?)\n\n- **并行** 是多线程程序在多个核的上运行\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4a9265f431c442a84b7012ac324c697~tplv-k3u1fbpfcp-watermark.image?)\n\n- Go可以充分发挥多核优势，高效运行\n一个重要概念\n## 协程\n- 协程的开销比线程小，可以理解为轻量级的线程，一个Go程序中可以创建上万个协程。\n\nGo 中 **开启协程** 非常简单，在函数前面增加一个 `go` 关键字就可以为一个函数开启一个协程。\n## CSP 与 Channel\nCSP(Communicating Sequential Process) \n\nGo 中提倡通过 **通信共享内存** 而不是通过共享内存而实现通信\n\n那么如何通信呢，通过 `channel`\n\n### Channel\n语法： `make(chan 元素类型, [缓冲大小])`\n- 无缓冲通道 `make(chan int)`\n- 有缓冲通道 `make(chan int, 2)`\n这个图就非常的生动形象~\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f103155c3ea8443a98bc54595e52cbfd~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7f6b92f7e344344a25b8fee23707079~tplv-k3u1fbpfcp-watermark.image?)\n\n以下是一个例子：\n- 第一个协程 作为生产者发送`0~9` 到 `src`中\n- 第二个协程 作为消费者计算 `src` 中每个数的平方发送到 `dest` 中\n- 主线程输出 `dest` 中每个数\n```go\npackage main\n\nfunc CalSquare() {\n   src := make(chan int)     // 生产者\n   dest := make(chan int, 3) // 消费者 带缓冲解决生产者太快的问题\n   go func() {               // 该线程发送0~9至src中\n      defer close(src) // defer 表示延迟到函数结束时执行 用于释放已分配的资源。\n      for i := 0; i < 10; i++ {\n         // <- 运算符 左侧为收集数据的一方 右侧为要传的数据\n         src <- i\n      }\n   }() // 立即执行\n   go func() {\n      defer close(dest)\n      for i := range src {\n         dest <- i * i\n      }\n   }()\n   for i := range dest {\n      // 其他复杂操作\n      println(i)\n   }\n}\nfunc main() {\n   CalSquare()\n}\n```\n可以看到每次都会是顺序输出，代表着Go是 **并发安全的**\n\nGo 语言也保留了共享内存的做法，使用sync进行同步，如下\n\n```go\npackage main\n\nimport (\n   \"sync\"\n   \"time\"\n)\n\nvar (\n   x    int64\n   lock sync.Mutex\n)\n\nfunc addWithLock() { // x加到2000 使用锁则很安全\n   for i := 0; i < 2000; i++ {\n      lock.Lock() // 加锁\n      x += 3\n      x -= 2\n      lock.Unlock() // 解锁\n   }\n}\nfunc addWithoutLock() { // 不使用锁\n   for i := 0; i < 2000; i++ {\n      x += 3\n      x -= 2\n   }\n}\nfunc Add() {\n   x = 0\n   for i := 0; i < 5; i++ {\n      go addWithoutLock()\n   }\n   time.Sleep(time.Second) // 休眠 1s\n   println(\"WithoutLock x =\", x)\n   x = 0\n   for i := 0; i < 5; i++ {\n      go addWithLock()\n   }\n   time.Sleep(time.Second) // 休眠 1s\n   println(\"WithLock x =\", x)\n}\nfunc main() {\n   Add()\n}\n```\n\nps：试了好多次都没冲突，乐。把运算稍微改复杂一点就有冲突了\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81e6a09747944a53be508927a76745ef~tplv-k3u1fbpfcp-watermark.image?)\n\n# 依赖管理\n任何大型项目开发都绕不开依赖管理，Go中的依赖主要经历了 GOPATH -> Go Vendor -> Go Module的演变 而现在主要采用Go Module的方式\n- 不同环境依赖的版本不同，所以如何控制依赖库的版本？\n## GOPATH\n- 项目代码直接依赖src下的代码\n- 通过 `go get` 下载最新版本的包到src目录下\n\n这样的话，就会出现一个问题：无法实现多版本的控制（A、B依赖于同一个包的不同版本，寄）\n## Go Vender\n- 项目目录下新增 `vendor`文件，所有依赖包副本形式放在其中\n- 通过 vendor => GOPATH 的方式曲线救国\n\nps：感觉挺像前端的package.json……依赖问题真是绕不过去\n\n这又产生了新的问题：\n- 无法控制依赖的版本\n- 更新项目时可能出现依赖冲突，从而导致编译出错\n\n## Go Module\n- 通过 `go.mod` 文件管理依赖包版本\n- 通过 `go get/go mod` 指令工具管理依赖包\n\n达成了终极目标：既能定义版本规则，又能管理项目依赖关系\n\n可以类比一下Java中的Maven\n\n## 依赖配置 `go.mod`\n依赖标识语法：模块路径+版本来进行唯一标识\n\n`[Module Path][Version/Pseudo-version]`\n\n```go\nmodule example/project/app     依赖管理基本单元\n\ngo 1.16     原生库\n\nrequire (    单元依赖\n    example/lib1 v1.0.2\n    example/lib2 v1.0.0 // indirect\n    example/lib3 v0.1.0-20190725025543-5a5fe074e612\n    example/lib4 v0.0.0-20180306012644-bacd9c7ef1dd // indirect\n    example/lib5/v3 v3.0.2\n    example/lib6 v3.2.0+incompatible\n)\n```\n如上，需要注意的是：\n- 主版本2+的模块会在路径后增加/vN后缀\n- 对于没有go.mod文件且主版本2+的依赖，会 `+incompatible`\n依赖的版本规则分为语义化版本和基于commit的伪版本\n### 语义化版本\n格式为：`${MAJOR}.${MINOR}.${PATCH}` V1.3.0、V2.3.0、 ……\n\n- 不同的 `MAJOR` 版本表示是**不兼容的API**\n    - 即使是同一个库，MAJOR 版本不同也会被认为是不同的模块\n- `MINOR` 版本通常是**新增函数或功能**，**向后兼容**\n- 而 `PATCH` 版本一般是 **修复 `bug`**\n\n### 基于commit的版本\n格式为：`${vx.0.0-yyyymmddhhmmss-abcdefgh1234}`\n- 版本前缀是和语义化版本一样的\n- 时间戳 (`yyyymmddhhmmss`)，也就是**提交 `Commit` 的时间**\n- 校验码 (`abcdefgh1234`), 12 位的哈希前缀\n    - 每次提交 `commit` 后 Go 都会默认生成一个伪版本号\n\n## 小测试\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/837629fe64b0400d87d21752eb2f2cef~tplv-k3u1fbpfcp-watermark.image?)\n\n\n1. 如果X项目依赖了A、B两个项目，且A、B分别依赖了C项目的v1.3、v1.4两个版本，依赖图如上，**最终编译**时所使用的C项目的版本为 []{.gap} ？ {.quiz}\n    - v1.3\n    - v1.4   {.correct}\n    - A用到c时用v1.3编译，B用到c时用v1.4编译\n{.options}\n    > 答案为：**B 选择最低的兼容版本** \\\n    > 这个是Go进行版本选择的算法，选择最低的兼容版本，而1.4版本是向下兼容1.3的（语义化版本）。为什么不选1.3呢？因为他又不会向上兼容ovo，倘若还有1.5的话则不会选用1.5，因为1.4就是满足要求的最低兼容版本。\n\n\n## 依赖分发\n\n这些依赖去哪里下载呢？就是依赖分发\n\n在github等代码托管系统中对应仓库上下载？\n\ngithub是比较常见给的代码托管系统平台，而`Go Modules` 系统中定义的依赖，最终可以**对应**到多版本代码管理系统中某一项目的**特定提交或版本**\n\n对于 `go.mod` 中定义的依赖，可以从对应仓库中下载指定软件依赖，从而完成依赖分发。\n\n问题也有：\n- **无法保证构建确定性**\n    - 软件作者直接修改软件版本，导致下次构建使用其他版本的依赖，或者找不到依赖版本\n- **无法保证依赖可用性**\n    - 软件作者直接代码平台删除软件，导致依赖不可用\n- **增加第三方代码托管平台压力**。\n\n通过Proxy方式来解决以上问题\n\n`Go Proxy` 是一个服务站点，它会**缓存源站中的软件内容**，缓存的软件版本不会改变，并且**在源站软件删除之后依然可用**\n\n使用 Go Proxy 之后，构建时会直接从 Go Proxy 站点拉取依赖。\n\nGo Modules通过 **`GOPROXY` 环境变量**控制如何使用 `Go Proxy`\n\n服务站点URL列表，direct表示源站：`GOPROXY=\"https://proxy1.cn, https://proxy2.cn,direct\"` \n \n- GOPROXY是一个 **Go Proxy 站点URL列表**，可以使用 `direct` 表示源站。整体的依赖寻址路径，会优先从 `proxy1` 下载依赖，如果 `proxy1` 不存在，就下到 `proxy2`寻找，如果`proxy2` 也不存在则会**回源**到源站直接下载依赖，缓存到 `proxy` 站点中。\n## 工具\n`go get example.org/pkg`\n| 后缀 | 含义 |\n| ---| --- |\n| @update | 默认 |\n| @none | 删除依赖 |\n| @v1.1.2 | tag版本，语义版本 |\n| @23dfdd5 | 特定的commit |\n| master | 分支的最新commit |\n\n`go mod`\n\n| 后缀 | 含义 |\n| ---| --- |\n| init | 初始化,创建go.mod文件 |\n| download | 下载模炔到本地缓存 |\n| tidy | 增加需要的依赖，删除不需要的依赖 |\ngo mod tidy 可以在每次提交代码前执行一下，就可以减少构建整个项目的时间\n\n# 测试\n测试一般分为**回归测试**、**集成测试**、**单元测试**，从前到后**覆盖率逐层变大**，**成本却逐层降低**，所以**单元测试的覆盖率**一定程度上决定这代码的质量。\n- 回归测试一般是QA同学手动通过终端回归一些固定的主流程场景\n- 集成测试是对系统功能维度做测试验证\n- 单元测试测试开发阶段，开发者对单独的函数、模块做功能验证\n\n单元测试主要包括：**输入**、**测试单元**、**输出**以及**校对**\n\n单元的概念较广，包括接口，函数，模块等，用最后的校对来保证代码的功能与我们的预期相符\n\n单元测试有以下几点好处\n- 保证质量\n    - 整体覆盖率足够时下，既保证了新功能正确性，又未破坏原有代码的正确性\n- 提升效率\n    - 代码有bug的情况下，通过单测，可以在一个较短周期内定位和修复问题\n    \nGo中的单元测试有以下规则：\n- 所有测试文件以 `_test.go` 结尾\n- `func TestXxx(testing.T)`\n- 初始化逻辑放到 `TestMain`函数中（测试前的数据装载配置、测试后的释放资源等）\n\n\n例子：\nmain.go\n```go\npackage main\n\nfunc HelloTom() string {\n   return \"Jerry\"\n}\n```\n\nmain_test.go\n```go\npackage main\n\nimport \"testing\"\n\nfunc TestHelloTom(t *testing.T) {\n   output := HelloTom()\n   expectOutput := \"Tom\"\n   if output != expectOutput {\n      t.Errorf(\"Expect %s do not match actual %s\", expectOutput, output)\n   }\n}\n```\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c37e39ccecd494e8fac79eaa42c5a87~tplv-k3u1fbpfcp-watermark.image?)\n\n在实际项目中，单测覆盖率\n- 一般项目的要求是50%~60%覆盖率\n- 对于重要的资金型服务，覆盖率可能要求达到80%\n\n单测需要保证**稳定性**和**幂等性**\n- 稳定是指**相互隔离**，能在任何时间，任何环境，运行测试\n- 幂等是指每一次测试运行都应该产生与之前**一样的结果**\n\n而要实现这一目的就要用到`mock`机制。\n\n[bouk/monkey: Monkey patching in Go](https://github.com/bouk/monkey)\n\nmonkey是一个开源的mock测试库，可以对method，或者实例的方法进行mock，反射，指针赋值Mockey Patch 的作用域在 Runtime，在运行时通过 Go 的 unsafe 包，能够将内存中函数A的地址替换为运行时函数B的地址，将待打桩函数的实现跳转。\n\nGo 语言还提供了基准测试框架\n- **基准测试**是指测试一段程序的运行性能及耗费 CPU 的程度。\n\n而我们在实际项目开发中，经常会遇到代码性能瓶颈问题，为了定位问题经常要对代码做**性能分析**，这就用到了基准测试。使用方法类似于单元测试\n> 提到了`fastrand`，地址： [bytedance/gopkg: Universal Utilities for Go](https://github.com/bytedance/gopkg)\n\n# 总结及心得\n本节课主要讲了Go中的并发管理、依赖配置和测试，内容较多，需要好好消化。后面还有个项目实践环节，等明天在进行一个实践。\n\n> 本节课内容来源于第三届青训营赵征老师的课程","sources":["xlog"],"attributes":[{"value":"go_learning_2md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/go_learning_2md"],"date_published":"2022-05-08T23:44:01.000Z"}}}