{"characterId":52270,"noteId":116,"linkItemType":null,"linkKey":"0x0000000000000000000000000000000000000000000000000000000000000000","deleted":false,"locked":false,"contractAddress":"0x0000000000000000000000000000000000000000","uri":"ipfs://bafkreieqieiglbk4qqueav2o3gdiqrmh3slwbvf3neizdu5d2rh7gy4qi4","operator":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","owner":"0x679658be03475d0a5393c70ea0e9a1158dfae1ff","createdAt":"2023-04-05T06:50:46.000Z","updatedAt":"2023-04-05T06:50:46.000Z","deletedAt":null,"publishedAt":"2020-03-02T00:10:39.000Z","transactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","blockNumber":30318351,"logIndex":19,"updatedTransactionHash":"0x6a0a82da03bb709c85a64b6b7d7760d871edebc9887dce726210d36e8b8f4430","updatedBlockNumber":30318351,"updatedLogIndex":19,"metadata":{"uri":"ipfs://bafkreieqieiglbk4qqueav2o3gdiqrmh3slwbvf3neizdu5d2rh7gy4qi4","type":"NOTE","content":{"tags":["post","c++","数据结构","队列"],"type":"note","title":"数据结构学习笔记＜3＞ 队列","content":"---\ntitle: 数据结构学习笔记＜3＞ 队列\nlink: 数据结构学习笔记＜3＞ 队列\ncatalog: true\nlang: cn\ndate: 2020-03-02 00:10:39 \nsubtitle: MOOC浙江大学的数据结构慕课学习记录——队列\ntags:\n- c++\n- 数据结构\n- 队列\ncategories:\n- [笔记, 数据结构]\n---\n\n##  一、队列的抽象数据类型描述\n类型名：队列（Queue）\n数据对象集：一个有0个或多个元素的有穷线性表\n操作集：长度为MaxSize的堆栈Q∈Queue, 队列元素item∈ElementType\n\n> **1.生成长度为MaxSize的空队列\n> \tQueue CreatQueue(int MaxSize);\n> 2.判断队列Q是否已满\n> bool IsFullQ(Queue Q, int MaxSize);\n> 3.将数据元素item插入队列Q中 \n> bool AddQ(Queue Q, ElementType item);\n> 4.判断队列Q是否已空\n>bool IsEmptyQ(Queue Q);\n> 5.删除并返回队首元素 \n> ElementType DeleteQ(Queue Q);**\n## 二、队列的顺序存储实现\n### 1.定义\n队列的顺序存储结构通常由一个**一维数组**和一个**记录队列头元素位置的变量front**以及一个**记录队列尾元素位置的变量rear**组成。\n形成的数组搬过来，变成一个环，便为循环队列。\n为了判断队列的空与满，循环队列仅使用n-1个数组空间\n![](https://img-blog.csdnimg.cn/20200301221006633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODkwNTMz,size_16,color_FFFFFF,t_70)\n定义代码如下\n```cpp\ntypedef struct QNode *Queue;\nstruct QNode {\n    ElementType Data[MaxSize];//一维数组\n    int rear;//记录队列尾元素位置\n    int front;//记录队列头元素位置  \n    int MaxSize;\n    //实际上front指向的是队列头元素下标的前一个\n};\n```\n### 2.操作\n#### (1)创建循环队列(CreateQueue)\n```cpp\nQueue CreateQueue( int MaxSize ) {\n    Queue Q = (Queue)malloc(sizeof(struct QNode));\n    Q->Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));\n    Q->front = Q->rear = 0;\n    Q->MaxSize = MaxSize;\n    return Q;\n}\n```\n#### (2)判断队列是否已满(IsFull)\n```cpp\nbool IsFull( Queue PtrQ ) {//front和rear+1的取余相等时队列满\n    return ((PtrQ->rear+1) % PtrQ->MaxSize == PtrQ->front);\n}\n```\n#### (3)入队列(AddQ)\n入队时要判断队列是否已满\n```cpp\nbool AddQ(Queue PtrQ, ElementType item) {\n    if ( IsFull(PtrQ) ) {\n        printf(\"队列满\");//front和rear+1的取余相等时队列满\n        return false;\n    } else {\n    \tPtrQ->rear = (PtrQ->rear+1) % PtrQ->MaxSize; \n    \t//移动队尾rear 以取余运算来实现循环\n    \tPtrQ->Data[PtrQ->rear] = item;\n    \treturn true;\n    }\n}\n```\n#### (4)判断队列是否已空(IsEmpty)\n```cpp\nbool IsEmpty(Queue PtrQ) {\n    return ( PtrQ->front == PtrQ->rear );\n}\n```\n#### (5)出队列(DeleteQ)\n出队时判断当前队列是否为空\n```cpp\nElementType DeleteQ(Queue PtrQ) {\n    if(IsEmpty(PtrQ)) {//rear和front相等时队列空\n        printf(\"队列空\");\n        return false;\n    } else {\n        PtrQ->front = (PtrQ->front+1) % PtrQ->MaxSize;//移动队首front\n        return PtrQ->Data[PtrQ->front];\n    }\n}\n```\n## 三、队列的链式存储实现\n### 1.定义\n队列的链式存储结构也可以用一个**单链表**实现，插入和删除操作分别在链表的两头进行。队列指针front应该指向链表头\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301223536717.png)\n```cpp\nstruct Node {\n    ElementType Data;\n    struct Node * Next;\n}\nstruct QNode {//链队列结构\n    struct Node *rear;  //指向队尾结点\n    struct Node *front;  //指向队头结点\n};\ntypedef struct QNode *Queue;\nQueue PtrQ;\n```\n### 2.操作\n#### (1)不带头结点的链式队列初始化（ CreateQueue）\n```cpp\nQueue CreateQueue() {\n    Queue Q;\n    Q = (Queue)malloc(sizeof(struct QNode));\n    Q->front = Q->rear = NULL;//两个指针都为空\n    return Q;\n}\n```\n#### (2)不带头结点的链式队列入队操作\n```cpp\nbool AddQ(Queue PtrQ, ElementType item) {\n\tstruct Node *RearCell = PtrQ->rear;//指向队尾元素的指针\n\tstruct Node *Temp = (struct Node *) malloc(sizeof(struct Node));\n\tTmp->Data = X;\n\tTmp->Next = NULL;\n    if ( PtrQ->front == NULL ) {//队列为空 进第一个元素\n        PtrQ->rear = PtrQ->front = Tmp;\n    } else {\n    \tRearCell->Next = Tmp;\n    \tPtrQ->rear = Tmp;\n    }\n    return true;\n}\n```\n#### (3)不带头结点的链式队列出队操作\n```cpp\nElementType DeleteQ(Queue PtrQ) {\n    struct Node * FrontCell;\n    ElementType FrontElem;//队首元素的值\n\n    if (PtrQ->front == NULL) {//1.先判断是否为空 为空无法进行出队操作\n        printf(\"队列空\");\n        return ERROR;\n    }\n    FrontCell = PtrQ->front;\n    if(PtrQ->front == PtrQ->rear) //若队列只有一个元素 则删除后队列置为空\n        PtrQ->front = PtrQ->rear = NULL;\n    else\n        PtrQ->front = FrontCell->Next;\n    FrontElem = FrontCell->Data;\n    free(FrontCell);    //释放被删除结点的空间\n    return FrontElem;\n}\n```\n","sources":["xlog"],"attributes":[{"value":"shu-ju-jie-gou-xue-xi-bi-ji-3-dui-lie-md","trait_type":"xlog_slug"}],"external_urls":["https://cosine.xlog.app/shu-ju-jie-gou-xue-xi-bi-ji-3-dui-lie-md"],"date_published":"2020-03-02T00:10:39.000Z"}}}